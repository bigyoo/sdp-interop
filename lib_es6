"use strict";

/* Copyright @ 2015 Atlassian Pty Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
module.exports = function arrayEquals(array) {
  // if the other array is a falsy value, return
  if (!array) return false; // compare lengths - can save a lot of time

  if (this.length != array.length) return false;

  for (var i = 0, l = this.length; i < l; i++) {
    // Check if we have nested arrays
    if (this[i] instanceof Array && array[i] instanceof Array) {
      // recurse into the nested arrays
      if (!arrayEquals.apply(this[i], [array[i]])) return false;
    } else if (this[i] != array[i]) {
      // Warning - two different object instances will never be equal:
      // {x:20} != {x:20}
      return false;
    }
  }

  return true;
};
"use strict";

/* Copyright @ 2015 Atlassian Pty Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.Interop = require('./interop');
/* Copyright @ 2015 Atlassian Pty Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* global RTCSessionDescription */

/* global RTCIceCandidate */

/* jshint -W097 */
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var transform = require('./transform');

var arrayEquals = require('./array-equals');
/**
 * Unified Plan mids may be parsed as integers
 */


function midToString(line) {
  if (typeof line.mid === 'number') {
    line.mid = line.mid.toString();
  }
}

function Interop() {
  /**
   * This map holds the most recent Unified Plan offer/answer SDP that was
   * converted to Plan B, with the SDP type ('offer' or 'answer') as keys and
   * the SDP string as values.
   *
   * @type {{}}
   */
  this.cache = {
    mlB2UMap: {},
    mlU2BMap: {}
  };
}

module.exports = Interop;
/**
 * Changes the candidate args to match with the related Unified Plan
 */

Interop.prototype.candidateToUnifiedPlan = function (candidate) {
  var cand = new RTCIceCandidate(candidate);
  cand.sdpMLineIndex = this.cache.mlB2UMap[cand.sdpMLineIndex];
  /* TODO: change sdpMid to (audio|video)-SSRC */

  return cand;
};
/**
 * Changes the candidate args to match with the related Plan B
 */


Interop.prototype.candidateToPlanB = function (candidate) {
  var cand = new RTCIceCandidate(candidate);

  if (cand.sdpMid.indexOf('audio') === 0) {
    cand.sdpMid = 'audio';
  } else if (cand.sdpMid.indexOf('video') === 0) {
    cand.sdpMid = 'video';
  } else {
    throw new Error('candidate with ' + cand.sdpMid + ' not allowed');
  }

  cand.sdpMLineIndex = this.cache.mlU2BMap[cand.sdpMLineIndex];
  return cand;
};
/**
 * Returns the index of the first m-line with the given media type and with a
 * direction which allows sending, in the last Unified Plan description with
 * type "answer" converted to Plan B. Returns {null} if there is no saved
 * answer, or if none of its m-lines with the given type allow sending.
 * @param type the media type ("audio" or "video").
 * @returns {*}
 */


Interop.prototype.getFirstSendingIndexFromAnswer = function (type) {
  if (!this.cache.answer) {
    return null;
  }

  var session = transform.parse(this.cache.answer);

  if (session && session.media && Array.isArray(session.media)) {
    for (var i = 0; i < session.media.length; i++) {
      if (session.media[i].type == type && (!session.media[i].direction
      /* default to sendrecv */
      || session.media[i].direction === 'sendrecv' || session.media[i].direction === 'sendonly')) {
        return i;
      }
    }
  }

  return null;
};
/**
 * This method transforms a Unified Plan SDP to an equivalent Plan B SDP. A
 * PeerConnection wrapper transforms the SDP to Plan B before passing it to the
 * application.
 *
 * @param desc
 * @returns {*}
 */


Interop.prototype.toPlanB = function (desc) {
  var self = this; //#region Preliminary input validation.

  if (_typeof(desc) !== 'object' || desc === null || typeof desc.sdp !== 'string') {
    console.warn('An empty description was passed as an argument.');
    return desc;
  } // Objectify the SDP for easier manipulation.


  var session = transform.parse(desc.sdp); // If the SDP contains no media, there's nothing to transform.

  if (typeof session.media === 'undefined' || !Array.isArray(session.media) || session.media.length === 0) {
    console.warn('The description has no media.');
    return desc;
  } // Try some heuristics to "make sure" this is a Unified Plan SDP. Plan B
  // SDP has a video, an audio and a data "channel" at most.


  if (session.media.length <= 3 && session.media.every(function (m) {
    return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;
  })) {
    console.warn('This description does not look like Unified Plan.');
    return desc;
  } //#endregion
  // HACK https://bugzilla.mozilla.org/show_bug.cgi?id=1113443


  var sdp = desc.sdp;
  var rewrite = false;

  for (var i = 0; i < session.media.length; i++) {
    var uLine = session.media[i];
    uLine.rtp.forEach(function (rtp) {
      if (rtp.codec === 'NULL') {
        rewrite = true;
        var offer = transform.parse(self.cache.offer);
        rtp.codec = offer.media[i].rtp[0].codec;
      }
    });
  }

  if (rewrite) {
    sdp = transform.write(session);
  } // Unified Plan SDP is our "precious". Cache it for later use in the Plan B
  // -> Unified Plan transformation.


  this.cache[desc.type] = sdp; //#region Convert from Unified Plan to Plan B.
  // We rebuild the session.media array.

  var media = session.media;
  session.media = []; // Associative array that maps channel types to channel objects for fast
  // access to channel objects by their type, e.g. type2bl['audio']->channel
  // obj.

  var type2bl = {}; // Used to build the group:BUNDLE value after the channels construction
  // loop.

  var types = []; // Used to aggregate the directions of the m-lines.

  var directionResult = {};
  media.forEach(function (uLine) {
    midToString(uLine); // rtcp-mux is required in the Plan B SDP.

    if ((typeof uLine.rtcpMux !== 'string' || uLine.rtcpMux !== 'rtcp-mux') && uLine.direction !== 'inactive' && uLine.type !== 'application') {
      throw new Error('Cannot convert to Plan B because m-lines ' + 'without the rtcp-mux attribute were found.');
    } // If we don't have a channel for this uLine.type OR the selected is
    // inactive, then select this uLine as the channel basis.


    if (typeof type2bl[uLine.type] === 'undefined' || type2bl[uLine.type].direction === 'inactive') {
      type2bl[uLine.type] = uLine;
    }
  }); // Implode the Unified Plan m-lines/tracks into Plan B channels.

  media.forEach(function (uLine) {
    var type = uLine.type;

    if (type === 'application') {
      uLine.mid = "data";
      session.media.push(uLine);
      types.push(uLine.mid);
      return;
    } // Add sources to the channel and handle a=msid.


    if (_typeof(uLine.sources) === 'object') {
      Object.keys(uLine.sources).forEach(function (ssrc) {
        if (_typeof(type2bl[type].sources) !== 'object') type2bl[type].sources = {}; // Assign the sources to the channel.

        type2bl[type].sources[ssrc] = uLine.sources[ssrc];

        if (typeof uLine.msid !== 'undefined') {
          // In Plan B the msid is an SSRC attribute. Also, we don't
          // care about the obsolete label and mslabel attributes.
          //
          // Note that it is not guaranteed that the uLine will
          // have an msid. recvonly channels in particular don't have
          // one.
          type2bl[type].sources[ssrc].msid = uLine.msid;
        } // NOTE ssrcs in ssrc groups will share msids, as
        // draft-uberti-rtcweb-plan-00 mandates.

      });
    } // Add ssrc groups to the channel.


    if (typeof uLine.ssrcGroups !== 'undefined' && Array.isArray(uLine.ssrcGroups)) {
      // Create the ssrcGroups array, if it's not defined.
      if (typeof type2bl[type].ssrcGroups === 'undefined' || !Array.isArray(type2bl[type].ssrcGroups)) {
        type2bl[type].ssrcGroups = [];
      } // Different ssrc may belong to the same group


      if (!arrayEquals.apply(type2bl[type].ssrcGroups, [uLine.ssrcGroups])) {
        type2bl[type].ssrcGroups = type2bl[type].ssrcGroups.concat(uLine.ssrcGroups);
      }
    }

    var direction = uLine.direction;
    directionResult[type] = (directionResult[type] || 0
    /* inactive */
    ) | directionMasks[direction || 'inactive'];

    if (type2bl[type] === uLine) {
      // Plan B mids are in ['audio', 'video', 'data']
      uLine.mid = type; // Plan B doesn't support/need the bundle-only attribute.

      delete uLine.bundleOnly; // In Plan B the msid is an SSRC attribute.

      delete uLine.msid;

      if (direction !== 'inactive') {
        // Used to build the group:BUNDLE value after this loop.
        types.push(type);
      } // Add the channel to the new media array.


      session.media.push(uLine);
    }
  }); // We regenerate the BUNDLE group with the new mids.

  session.groups.some(function (group) {
    if (group.type === 'BUNDLE') {
      group.mids = types.join(' ');
      return true;
    }
  }); // msid semantic

  session.msidSemantic = {
    semantic: 'WMS',
    token: '*'
  };
  var resStr = transform.write(session);
  return new RTCSessionDescription({
    type: desc.type,
    sdp: resStr
  }); //#endregion
};
/**
 * This method transforms a Plan B SDP to an equivalent Unified Plan SDP. A
 * PeerConnection wrapper transforms the SDP to Unified Plan before passing it
 * to FF.
 *
 * @param desc
 * @returns {*}
 */


Interop.prototype.toUnifiedPlan = function (desc) {
  var self = this; //#region Preliminary input validation.

  if (_typeof(desc) !== 'object' || desc === null || typeof desc.sdp !== 'string') {
    console.warn('An empty description was passed as an argument.');
    return desc;
  }

  var session = transform.parse(desc.sdp); // If the SDP contains no media, there's nothing to transform.

  if (typeof session.media === 'undefined' || !Array.isArray(session.media) || session.media.length === 0) {
    console.warn('The description has no media.');
    return desc;
  } // Try some heuristics to "make sure" this is a Plan B SDP. Plan B SDP has
  // a video, an audio and a data "channel" at most.


  if (session.media.length > 3 || !session.media.every(function (m) {
    return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;
  })) {
    console.warn('This description does not look like Plan B.');
    return desc;
  } // Make sure this Plan B SDP can be converted to a Unified Plan SDP.


  var mids = [];
  session.media.forEach(function (m) {
    mids.push(m.mid);
  });
  var hasBundle = false;

  if (typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {
    hasBundle = session.groups.every(function (g) {
      return g.type !== 'BUNDLE' || arrayEquals.apply(g.mids.sort(), [mids.sort()]);
    });
  }

  if (!hasBundle) {
    throw new Error("Cannot convert to Unified Plan because m-lines that" + " are not bundled were found.");
  } //#endregion
  //#region Convert from Plan B to Unified Plan.
  // Unfortunately, a Plan B offer/answer doesn't have enough information to
  // rebuild an equivalent Unified Plan offer/answer.
  //
  // For example, if this is a local answer (in Unified Plan style) that we
  // convert to Plan B prior to handing it over to the application (the
  // PeerConnection wrapper called us, for instance, after a successful
  // createAnswer), we want to remember the m-line at which we've seen the
  // (local) SSRC. That's because when the application wants to do call the
  // SLD method, forcing us to do the inverse transformation (from Plan B to
  // Unified Plan), we need to know to which m-line to assign the (local)
  // SSRC. We also need to know all the other m-lines that the original
  // answer had and include them in the transformed answer as well.
  //
  // Another example is if this is a remote offer that we convert to Plan B
  // prior to giving it to the application, we want to remember the mid at
  // which we've seen the (remote) SSRC.
  //
  // In the iteration that follows, we use the cached Unified Plan (if it
  // exists) to assign mids to ssrcs.


  var cached;

  if (typeof this.cache[desc.type] !== 'undefined') {
    cached = transform.parse(this.cache[desc.type]);
  }

  var recvonlySsrcs = {
    audio: {},
    video: {}
  }; // A helper map that sends mids to m-line objects. We use it later to
  // rebuild the Unified Plan style session.media array.

  var mid2ul = {};
  var bIdx = 0;
  var uIdx = 0;
  session.media.forEach(function (bLine) {
    if ((typeof bLine.rtcpMux !== 'string' || bLine.rtcpMux !== 'rtcp-mux') && bLine.direction !== 'inactive' && bLine.type !== 'application') {
      throw new Error("Cannot convert to Unified Plan because m-lines " + "without the rtcp-mux attribute were found.");
    }

    if (bLine.type === 'application') {
      var uLineData = null;

      if (cached && cached.media) {
        uLineData = cached.media.find(function (uLine) {
          return uLine.type === 'application';
        });
      }

      if (uLineData) {
        mid2ul[uLineData.mid] = uLineData;
      } else {
        mid2ul[bLine.mid] = bLine;
      }

      return;
    } // With rtcp-mux and bundle all the channels should have the same ICE
    // stuff.


    var sources = bLine.sources;
    var ssrcGroups = bLine.ssrcGroups;
    var candidates = bLine.candidates;
    var iceUfrag = bLine.iceUfrag;
    var icePwd = bLine.icePwd;
    var fingerprint = bLine.fingerprint;
    var port = bLine.port; // We'll use the "bLine" object as a prototype for each new "mLine"
    // that we create, but first we need to clean it up a bit.

    delete bLine.sources;
    delete bLine.ssrcGroups;
    delete bLine.candidates;
    delete bLine.iceUfrag;
    delete bLine.icePwd;
    delete bLine.fingerprint;
    delete bLine.port;
    delete bLine.mid; // inverted ssrc group map

    var ssrc2group = {};

    if (typeof ssrcGroups !== 'undefined' && Array.isArray(ssrcGroups)) {
      ssrcGroups.forEach(function (ssrcGroup) {
        // TODO(gp) find out how to receive simulcast with FF. For the
        // time being, hide it.
        if (ssrcGroup.semantics === 'SIM') {
          return;
        } // XXX This might brake if an SSRC is in more than one group
        // for some reason.


        if (typeof ssrcGroup.ssrcs !== 'undefined' && Array.isArray(ssrcGroup.ssrcs)) {
          ssrcGroup.ssrcs.forEach(function (ssrc) {
            if (typeof ssrc2group[ssrc] === 'undefined') {
              ssrc2group[ssrc] = [];
            }

            ssrc2group[ssrc].push(ssrcGroup);
          });
        }
      });
    } // ssrc to m-line index.


    var ssrc2ml = {};

    if (_typeof(sources) === 'object') {
      // Explode the Plan B channel sources with one m-line per source.
      Object.keys(sources).forEach(function (ssrc) {
        // The (unified) m-line for this SSRC. We either create it from
        // scratch or, if it's a grouped SSRC, we re-use a related
        // mline. In other words, if the source is grouped with another
        // source, put the two together in the same m-line.
        var uLine; // We assume here that we are the answerer in the O/A, so any
        // offers which we translate come from the remote side, while
        // answers are local. So the check below is to make that we
        // handle receive-only SSRCs in a special way only if they come
        // from the remote side.

        if (desc.type === 'offer') {
          // We want to detect SSRCs which are used by a remote peer
          // in an m-line with direction=recvonly (i.e. they are
          // being used for RTCP only).
          // This information would have gotten lost if the remote
          // peer used Unified Plan and their local description was
          // translated to Plan B. So we use the lack of an MSID
          // attribute to deduce a "receive only" SSRC.
          if (!sources[ssrc].msid) {
            recvonlySsrcs[bLine.type][ssrc] = sources[ssrc]; // Receive-only SSRCs must not create new m-lines. We
            // will assign them to an existing m-line later.

            return;
          }
        }

        if (typeof ssrc2group[ssrc] !== 'undefined' && Array.isArray(ssrc2group[ssrc])) {
          ssrc2group[ssrc].some(function (ssrcGroup) {
            // ssrcGroup.ssrcs *is* an Array, no need to check
            // again here.
            return ssrcGroup.ssrcs.some(function (related) {
              if (_typeof(ssrc2ml[related]) === 'object') {
                uLine = ssrc2ml[related];
                return true;
              }
            });
          });
        }

        if (_typeof(uLine) === 'object') {
          // the m-line already exists. Just add the source.
          uLine.sources[ssrc] = sources[ssrc];
          delete sources[ssrc].msid;
        } else {
          // Use the "bLine" as a prototype for the "uLine".
          uLine = Object.create(bLine);
          ssrc2ml[ssrc] = uLine;

          if (typeof sources[ssrc].msid !== 'undefined') {
            // Assign the msid of the source to the m-line. Note
            // that it is not guaranteed that the source will have
            // msid. In particular "recvonly" sources don't have an
            // msid. Note that "recvonly" is a term only defined
            // for m-lines.
            uLine.msid = sources[ssrc].msid;
            delete sources[ssrc].msid;
          } // We assign one SSRC per media line.


          uLine.sources = {};
          uLine.sources[ssrc] = sources[ssrc];
          uLine.ssrcGroups = ssrc2group[ssrc]; // Use the cached Unified Plan SDP (if it exists) to assign
          // SSRCs to mids.

          if (typeof cached !== 'undefined' && typeof cached.media !== 'undefined' && Array.isArray(cached.media)) {
            cached.media.forEach(function (m) {
              if (_typeof(m.sources) === 'object') {
                Object.keys(m.sources).forEach(function (s) {
                  if (s === ssrc) {
                    uLine.mid = m.mid;
                  }
                });
              }
            });
          }

          midToString(uLine);

          if (typeof uLine.mid === 'undefined') {
            // If this is an SSRC that we see for the first time
            // assign it a new mid. This is typically the case when
            // this method is called to transform a remote
            // description for the first time or when there is a
            // new SSRC in the remote description because a new
            // peer has joined the conference. Local SSRCs should
            // have already been added to the map in the toPlanB
            // method.
            //
            // Because FF generates answers in Unified Plan style,
            // we MUST already have a cached answer with all the
            // local SSRCs mapped to some m-line/mid.
            if (desc.type === 'answer') {
              console.log('An unmapped  SSRC was found: ' + desc.sdp);
              throw new Error("An unmapped SSRC was found.");
            }

            uLine.mid = [bLine.type, '-', ssrc].join('');
          } // Include the candidates in the 1st media line.


          uLine.candidates = candidates;
          uLine.iceUfrag = iceUfrag;
          uLine.icePwd = icePwd;
          uLine.fingerprint = fingerprint;
          uLine.port = port;
          mid2ul[uLine.mid] = uLine;
          self.cache.mlU2BMap[uIdx] = bIdx;

          if (typeof self.cache.mlB2UMap[bIdx] === 'undefined') {
            self.cache.mlB2UMap[bIdx] = uIdx;
          }

          uIdx++;
        }
      });
    }

    bIdx++;
  }); // Rebuild the media array in the right order and add the missing mLines
  // (missing from the Plan B SDP).

  session.media = [];
  mids = []; // reuse

  if (desc.type === 'answer') {
    // The media lines in the answer must match the media lines in the
    // offer. The order is important too. Here we assume that Firefox is
    // the answerer, so we merely have to use the reconstructed (unified)
    // answer to update the cached (unified) answer accordingly.
    //
    // In the general case, one would have to use the cached (unified)
    // offer to find the m-lines that are missing from the reconstructed
    // answer, potentially grabbing them from the cached (unified) answer.
    // One has to be careful with this approach because inactive m-lines do
    // not always have an mid, making it tricky (impossible?) to find where
    // exactly and which m-lines are missing from the reconstructed answer.
    for (var i = 0; i < cached.media.length; i++) {
      var uLine = cached.media[i];
      midToString(uLine);

      if (typeof mid2ul[uLine.mid] === 'undefined') {
        // The mid isn't in the reconstructed (unified) answer.
        // This is either a (unified) m-line containing a remote
        // track only, or a (unified) m-line containing a remote
        // track and a local track that has been removed.
        // In either case, it MUST exist in the cached
        // (unified) answer.
        //
        // In case this is a removed local track, clean-up
        // the (unified) m-line and make sure it's 'recvonly' or
        // 'inactive'.
        delete uLine.msid;
        delete uLine.sources;
        delete uLine.ssrcGroups;
        if (!uLine.direction || uLine.direction === 'sendrecv') uLine.direction = 'recvonly';else if (uLine.direction === 'sendonly') uLine.direction = 'inactive';
      } else {// This is an (unified) m-line/channel that contains a local
        // track (sendrecv or sendonly channel) or it's a unified
        // recvonly m-line/channel. In either case, since we're
        // going from PlanB -> Unified Plan this m-line MUST
        // exist in the cached answer.
      }

      session.media.push(uLine);

      if (typeof uLine.mid === 'string') {
        // inactive lines don't/may not have an mid.
        mids.push(uLine.mid);
      }
    }
  } else {
    // SDP offer/answer (and the JSEP spec) forbids removing an m-section
    // under any circumstances. If we are no longer interested in sending a
    // track, we just remove the msid and ssrc attributes and set it to
    // either a=recvonly (as the reofferer, we must use recvonly if the
    // other side was previously sending on the m-section, but we can also
    // leave the possibility open if it wasn't previously in use), or
    // a=inactive.
    if (typeof cached !== 'undefined' && typeof cached.media !== 'undefined' && Array.isArray(cached.media)) {
      cached.media.forEach(function (uLine) {
        midToString(uLine);
        mids.push(uLine.mid);

        if (typeof mid2ul[uLine.mid] !== 'undefined') {
          session.media.push(mid2ul[uLine.mid]);
        } else {
          delete uLine.msid;
          delete uLine.sources;
          delete uLine.ssrcGroups;
          if (!uLine.direction || uLine.direction === 'sendrecv') uLine.direction = 'recvonly';
          if (!uLine.direction || uLine.direction === 'sendonly') uLine.direction = 'inactive';
          session.media.push(uLine);
        }
      });
    } // Add all the remaining (new) m-lines of the transformed SDP.


    Object.keys(mid2ul).forEach(function (mid) {
      if (mids.indexOf(mid) === -1) {
        mids.push(mid);

        if (mid2ul[mid].direction === 'recvonly') {
          // This is a remote recvonly channel. Add its SSRC to the
          // appropriate sendrecv or sendonly channel.
          // TODO(gp) what if we don't have sendrecv/sendonly
          // channel?
          session.media.some(function (uLine) {
            if ((uLine.direction === 'sendrecv' || uLine.direction === 'sendonly') && uLine.type === mid2ul[mid].type) {
              // mid2ul[mid] shouldn't have any ssrc-groups
              Object.keys(mid2ul[mid].sources).forEach(function (ssrc) {
                uLine.sources[ssrc] = mid2ul[mid].sources[ssrc];
              });
              return true;
            }
          });
        } else {
          session.media.push(mid2ul[mid]);
        }
      }
    });
  } // After we have constructed the Plan Unified m-lines we can figure out
  // where (in which m-line) to place the 'recvonly SSRCs'.
  // Note: we assume here that we are the answerer in the O/A, so any offers
  // which we translate come from the remote side, while answers are local
  // (and so our last local description is cached as an 'answer').


  ["audio", "video"].forEach(function (type) {
    if (!session || !session.media || !Array.isArray(session.media)) return;
    var idx = null;

    if (Object.keys(recvonlySsrcs[type]).length > 0) {
      idx = self.getFirstSendingIndexFromAnswer(type);

      if (idx === null) {
        // If this is the first offer we receive, we don't have a
        // cached answer. Assume that we will be sending media using
        // the first m-line for each media type.
        for (var i = 0; i < session.media.length; i++) {
          if (session.media[i].type === type) {
            idx = i;
            break;
          }
        }
      }
    }

    if (idx && session.media.length > idx) {
      var mLine = session.media[idx];
      Object.keys(recvonlySsrcs[type]).forEach(function (ssrc) {
        if (mLine.sources && mLine.sources[ssrc]) {
          console.warn("Replacing an existing SSRC.");
        }

        if (!mLine.sources) {
          mLine.sources = {};
        }

        mLine.sources[ssrc] = recvonlySsrcs[type][ssrc];
      });
    }
  }); // We regenerate the BUNDLE group (since we regenerated the mids)

  session.groups.some(function (group) {
    if (group.type === 'BUNDLE') {
      group.mids = mids.join(' ');
      return true;
    }
  }); // msid semantic

  session.msidSemantic = {
    semantic: 'WMS',
    token: '*'
  };
  var resStr = transform.write(session); // Cache the transformed SDP (Unified Plan) for later re-use in this
  // function.

  this.cache[desc.type] = resStr;
  return new RTCSessionDescription({
    type: desc.type,
    sdp: resStr
  }); //#endregion
};
/**
 * Maps the direction strings to their binary representation. The binary
 * representation of the directions will contain only 2 bits. The least
 * significant bit will indicate the receiving direction and the other bit will
 * indicate the sending direction.
 *
 * @type {Map<string, number>}
 */


var directionMasks = {
  'inactive': 0,
  // 00
  'recvonly': 1,
  // 01
  'sendonly': 2,
  // 10
  'sendrecv': 3 // 11

};
/**
 * Parses a number into direction string.
 *
 * @param {number} direction - The number to be parsed.
 * @returns {string} - The parsed direction string.
 */

function parseDirection(direction) {
  // eslint-disable-line no-unused-vars
  // Filter all other bits except the 2 less significant.
  var directionMask = direction & 3;

  switch (directionMask) {
    case 0:
      return 'inactive';

    case 1:
      return 'recvonly';

    case 2:
      return 'sendonly';

    case 3:
      return 'sendrecv';
  }
}
"use strict";

/* Copyright @ 2015 Atlassian Pty Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var transform = require('sdp-transform');

exports.write = function (session, opts) {
  if (typeof session !== 'undefined' && typeof session.media !== 'undefined' && Array.isArray(session.media)) {
    session.media.forEach(function (mLine) {
      // expand sources to ssrcs
      if (typeof mLine.sources !== 'undefined' && Object.keys(mLine.sources).length !== 0) {
        mLine.ssrcs = [];
        Object.keys(mLine.sources).forEach(function (ssrc) {
          var source = mLine.sources[ssrc];
          Object.keys(source).forEach(function (attribute) {
            mLine.ssrcs.push({
              id: ssrc,
              attribute: attribute,
              value: source[attribute]
            });
          });
        });
        delete mLine.sources;
      } // join ssrcs in ssrc groups


      if (typeof mLine.ssrcGroups !== 'undefined' && Array.isArray(mLine.ssrcGroups)) {
        mLine.ssrcGroups.forEach(function (ssrcGroup) {
          if (typeof ssrcGroup.ssrcs !== 'undefined' && Array.isArray(ssrcGroup.ssrcs)) {
            ssrcGroup.ssrcs = ssrcGroup.ssrcs.join(' ');
          }
        });
      }
    });
  } // join group mids


  if (typeof session !== 'undefined' && typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {
    session.groups.forEach(function (g) {
      if (typeof g.mids !== 'undefined' && Array.isArray(g.mids)) {
        g.mids = g.mids.join(' ');
      }
    });
  }

  return transform.write(session, opts);
};

exports.parse = function (sdp) {
  var session = transform.parse(sdp);

  if (typeof session !== 'undefined' && typeof session.media !== 'undefined' && Array.isArray(session.media)) {
    session.media.forEach(function (mLine) {
      // group sources attributes by ssrc
      if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {
        mLine.sources = {};
        mLine.ssrcs.forEach(function (ssrc) {
          if (!mLine.sources[ssrc.id]) mLine.sources[ssrc.id] = {};
          mLine.sources[ssrc.id][ssrc.attribute] = ssrc.value;
        });
        delete mLine.ssrcs;
      } // split ssrcs in ssrc groups


      if (typeof mLine.ssrcGroups !== 'undefined' && Array.isArray(mLine.ssrcGroups)) {
        mLine.ssrcGroups.forEach(function (ssrcGroup) {
          if (typeof ssrcGroup.ssrcs === 'string') {
            ssrcGroup.ssrcs = ssrcGroup.ssrcs.split(' ');
          }
        });
      }
    });
  } // split group mids


  if (typeof session !== 'undefined' && typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {
    session.groups.forEach(function (g) {
      if (typeof g.mids === 'string') {
        g.mids = g.mids.split(' ');
      }
    });
  }

  return session;
};
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _strophe = require("strophe.js");

var _XMPPEvents = _interopRequireDefault(require("../../service/xmpp/XMPPEvents"));

var _Listenable2 = _interopRequireDefault(require("../util/Listenable"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * The property
 */
var IDENTITY_PROPERTIES = ['category', 'type', 'lang', 'name'];
var IDENTITY_PROPERTIES_FOR_COMPARE = ['category', 'type', 'lang'];
var HASH = 'sha-1';
/**
 *
 * @param a
 * @param b
 */

function compareIdentities(a, b) {
  var res = 0;
  IDENTITY_PROPERTIES_FOR_COMPARE.some(function (key) {
    return (res = a[key] > b[key] && 1 || a[key] < b[key] && -1) !== 0;
  });
  return res;
}
/**
 * Implements xep-0115 ( http://xmpp.org/extensions/xep-0115.html )
 */


var Caps =
/*#__PURE__*/
function (_Listenable) {
  _inherits(Caps, _Listenable);

  /**
   * Constructs new Caps instance.
   * @param {Strophe.Connection} connection the strophe connection object
   * @param {String} node the value of the node attribute of the "c" xml node
   * that will be sent to the other participants
   */
  function Caps() {
    var _this;

    var connection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'http://jitsi.org/jitsimeet';

    _classCallCheck(this, Caps);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Caps).call(this));
    _this.node = node;
    _this.disco = connection.disco;

    if (!_this.disco) {
      throw new Error('Missing strophe-plugins ' + '(disco plugin is required)!');
    }

    _this.versionToCapabilities = Object.create(null);
    _this.jidToVersion = Object.create(null);
    _this.version = '';
    _this.rooms = new Set();
    var emuc = connection.emuc;
    emuc.addListener(_XMPPEvents["default"].EMUC_ROOM_ADDED, function (room) {
      return _this._addChatRoom(room);
    });
    emuc.addListener(_XMPPEvents["default"].EMUC_ROOM_REMOVED, function (room) {
      return _this._removeChatRoom(room);
    });
    Object.keys(emuc.rooms).forEach(function (jid) {
      _this._addChatRoom(emuc.rooms[jid]);
    });

    _strophe.Strophe.addNamespace('CAPS', 'http://jabber.org/protocol/caps');

    _this.disco.addFeature(_strophe.Strophe.NS.CAPS);

    connection.addHandler(_this._handleCaps.bind(_assertThisInitialized(_this)), _strophe.Strophe.NS.CAPS);
    _this._onMucMemberLeft = _this._removeJidToVersionEntry.bind(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Adds new feature to the list of supported features for the local
   * participant
   * @param {String} feature the name of the feature.
   * @param {boolean} submit if true - new presence with updated "c" node
   * will be sent.
   */


  _createClass(Caps, [{
    key: "addFeature",
    value: function addFeature(feature) {
      var submit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.disco.addFeature(feature);

      this._generateVersion();

      if (submit) {
        this.submit();
      }
    }
    /**
     * Removes a feature from the list of supported features for the local
     * participant
     * @param {String} feature the name of the feature.
     * @param {boolean} submit if true - new presence with updated "c" node
     * will be sent.
     */

  }, {
    key: "removeFeature",
    value: function removeFeature(feature) {
      var submit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.disco.removeFeature(feature);

      this._generateVersion();

      if (submit) {
        this.submit();
      }
    }
    /**
     * Sends new presence stanza for every room from the list of rooms.
     */

  }, {
    key: "submit",
    value: function submit() {
      this.rooms.forEach(function (room) {
        return room.sendPresence();
      });
    }
    /**
     * Returns a set with the features for a participant.
     * @param {String} jid the jid of the participant
     * @param {int} timeout the timeout in ms for reply from the participant.
     * @returns {Promise<Set<String>, Error>}
     */

  }, {
    key: "getFeatures",
    value: function getFeatures(jid) {
      var _this2 = this;

      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;
      var user = jid in this.jidToVersion ? this.jidToVersion[jid] : null;

      if (!user || !(user.version in this.versionToCapabilities)) {
        var node = user ? "".concat(user.node, "#").concat(user.version) : null;
        return this._getDiscoInfo(jid, node, timeout).then(function (_ref) {
          var features = _ref.features;

          if (user) {
            // TODO: Maybe use the version + node + hash as keys?
            _this2.versionToCapabilities[user.version] = features;
          }

          return features;
        });
      }

      return Promise.resolve(this.versionToCapabilities[user.version]);
    }
    /**
     * Returns a set with the features for a host.
     * @param {String} jid the jid of the host
     * @param {int} timeout the timeout in ms for reply from the host.
     * @returns {Promise<Set<String>, Error>}
     */

  }, {
    key: "getFeaturesAndIdentities",
    value: function getFeaturesAndIdentities(jid) {
      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;
      return this._getDiscoInfo(jid, null, timeout);
    }
    /**
     * Returns a set with the features and identities for a host.
     * @param {String} jid the jid of the host
     * @param {String|null} node the node to query
     * @param {int} timeout the timeout in ms for reply from the host.
     * @returns {Promise<Object>}
     * @private
     */

  }, {
    key: "_getDiscoInfo",
    value: function _getDiscoInfo(jid, node, timeout) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        return _this3.disco.info(jid, node, function (response) {
          var features = new Set();
          var identities = new Set();
          $(response).find('>query>feature').each(function (_, el) {
            return features.add(el.getAttribute('var'));
          });
          $(response).find('>query>identity').each(function (_, el) {
            return identities.add({
              type: el.getAttribute('type'),
              name: el.getAttribute('name'),
              category: el.getAttribute('category')
            });
          });
          resolve({
            features: features,
            identities: identities
          });
        }, reject, timeout);
      });
    }
    /**
     * Adds ChatRoom instance to the list of rooms. Adds listeners to the room
     * and adds "c" element to the presences of the room.
     * @param {ChatRoom} room the room.
     */

  }, {
    key: "_addChatRoom",
    value: function _addChatRoom(room) {
      this.rooms.add(room);
      room.addListener(_XMPPEvents["default"].MUC_MEMBER_LEFT, this._onMucMemberLeft);

      this._fixChatRoomPresenceMap(room);
    }
    /**
     * Removes ChatRoom instance from the list of rooms. Removes listeners
     * added from the Caps class.
     * @param {ChatRoom} room the room.
     */

  }, {
    key: "_removeChatRoom",
    value: function _removeChatRoom(room) {
      this.rooms["delete"](room);
      room.removeListener(_XMPPEvents["default"].MUC_MEMBER_LEFT, this._onMucMemberLeft);
    }
    /**
     * Creates/updates the "c" xml node into the presence of the passed room.
     * @param {ChatRoom} room the room.
     */

  }, {
    key: "_fixChatRoomPresenceMap",
    value: function _fixChatRoomPresenceMap(room) {
      room.addToPresence('c', {
        attributes: {
          xmlns: _strophe.Strophe.NS.CAPS,
          hash: HASH,
          node: this.node,
          ver: this.version
        }
      });
    }
    /**
     * Handles this.version changes.
     */

  }, {
    key: "_notifyVersionChanged",
    value: function _notifyVersionChanged() {
      var _this4 = this;

      // update the version for all rooms
      this.rooms.forEach(function (room) {
        return _this4._fixChatRoomPresenceMap(room);
      });
      this.submit();
    }
    /**
     * Generates the value for the "ver" attribute.
     */

  }, {
    key: "_generateVersion",
    value: function _generateVersion() {
      var identities = this.disco._identities.sort(compareIdentities).reduce(function (accumulatedValue, identity) {
        return "".concat(IDENTITY_PROPERTIES.reduce(function (tmp, key, idx) {
          return tmp + (idx === 0 ? '' : '/') + identity[key];
        }, ''), "<");
      }, '');

      var features = this.disco._features.sort().reduce(function (tmp, feature) {
        return "".concat(tmp + feature, "<");
      }, '');

      this.version = (0, _strophe.b64_sha1)(identities + features);

      this._notifyVersionChanged();
    }
    /**
     * Parses the "c" xml node from presence.
     * @param {DOMElement} stanza the presence packet
     */

  }, {
    key: "_handleCaps",
    value: function _handleCaps(stanza) {
      var from = stanza.getAttribute('from');
      var caps = stanza.querySelector('c');
      var version = caps.getAttribute('ver');
      var node = caps.getAttribute('node');
      var oldVersion = this.jidToVersion[from];
      this.jidToVersion[from] = {
        version: version,
        node: node
      };

      if (oldVersion && oldVersion.version !== version) {
        this.eventEmitter.emit(_XMPPEvents["default"].PARTCIPANT_FEATURES_CHANGED, from);
      } // return true to not remove the handler from Strophe


      return true;
    }
    /**
     * Removes entry from this.jidToVersion map.
     * @param {String} jid the jid to be removed.
     */

  }, {
    key: "_removeJidToVersionEntry",
    value: function _removeJidToVersionEntry(jid) {
      if (jid in this.jidToVersion) {
        delete this.jidToVersion[jid];
      }
    }
  }]);

  return Caps;
}(_Listenable2["default"]);

exports["default"] = Caps;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.parser = void 0;

var _jitsiMeetLogger = require("jitsi-meet-logger");

var _strophe = require("strophe.js");

var _GlobalOnErrorHandler = _interopRequireDefault(require("../util/GlobalOnErrorHandler"));

var JitsiTranscriptionStatus = _interopRequireWildcard(require("../../JitsiTranscriptionStatus"));

var _Listenable2 = _interopRequireDefault(require("../util/Listenable"));

var _Settings = _interopRequireDefault(require("../settings/Settings"));

var MediaType = _interopRequireWildcard(require("../../service/RTC/MediaType"));

var _XMPPEvents = _interopRequireDefault(require("../../service/xmpp/XMPPEvents"));

var _moderator = _interopRequireDefault(require("./moderator"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var logger = (0, _jitsiMeetLogger.getLogger)(__filename);
var parser = {
  packet2JSON: function packet2JSON(xmlElement, nodes) {
    for (var _i = 0, _Array$from = Array.from(xmlElement.children); _i < _Array$from.length; _i++) {
      var child = _Array$from[_i];
      var node = {
        attributes: {},
        children: [],
        tagName: child.tagName
      };

      for (var _i2 = 0, _Array$from2 = Array.from(child.attributes); _i2 < _Array$from2.length; _i2++) {
        var attr = _Array$from2[_i2];
        node.attributes[attr.name] = attr.value;
      }

      var text = _strophe.Strophe.getText(child);

      if (text) {
        // Using Strophe.getText will do work for traversing all direct
        // child text nodes but returns an escaped value, which is not
        // desirable at this point.
        node.value = _strophe.Strophe.xmlunescape(text);
      }

      nodes.push(node);
      this.packet2JSON(child, node.children);
    }
  },
  json2packet: function json2packet(nodes, packet) {
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];

      if (node) {
        packet.c(node.tagName, node.attributes);

        if (node.value) {
          packet.t(node.value);
        }

        if (node.children) {
          this.json2packet(node.children, packet);
        }

        packet.up();
      }
    } // packet.up();

  }
};
/**
 * Returns array of JS objects from the presence JSON associated with the passed
 / nodeName
 * @param pres the presence JSON
 * @param nodeName the name of the node (videomuted, audiomuted, etc)
 */

exports.parser = parser;

function filterNodeFromPresenceJSON(pres, nodeName) {
  var res = [];

  for (var i = 0; i < pres.length; i++) {
    if (pres[i].tagName === nodeName) {
      res.push(pres[i]);
    }
  }

  return res;
} // XXX As ChatRoom constructs XMPP stanzas and Strophe is build around the idea
// of chaining function calls, allow long function call chains.

/* eslint-disable newline-per-chained-call */

/**
 *
 */


var ChatRoom =
/*#__PURE__*/
function (_Listenable) {
  _inherits(ChatRoom, _Listenable);

  /* eslint-disable max-params */

  /**
   *
   * @param connection
   * @param jid
   * @param password
   * @param XMPP
   * @param options
   * @param {boolean} options.disableFocus - when set to {@code false} will
   * not invite Jicofo into the room. This is intended to be used only by
   * jitsi-meet-spot.
   */
  function ChatRoom(connection, jid, password, XMPP, options) {
    var _this;

    _classCallCheck(this, ChatRoom);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ChatRoom).call(this));
    _this.xmpp = XMPP;
    _this.connection = connection;
    _this.roomjid = _strophe.Strophe.getBareJidFromJid(jid);
    _this.myroomjid = jid;
    _this.password = password;
    logger.info("Joined MUC as ".concat(_this.myroomjid));
    _this.members = {};
    _this.presMap = {};
    _this.presHandlers = {};
    _this.joined = false;
    _this.role = null;
    _this.focusMucJid = null;
    _this.noBridgeAvailable = false;
    _this.options = options || {};
    _this.moderator = new _moderator["default"](_this.roomjid, _this.xmpp, _this.eventEmitter, {
      connection: _this.xmpp.options,
      conference: _this.options
    });

    _this.initPresenceMap(options);

    _this.lastPresences = {};
    _this.phoneNumber = null;
    _this.phonePin = null;
    _this.connectionTimes = {};
    _this.participantPropertyListener = null;
    _this.locked = false;
    _this.transcriptionStatus = JitsiTranscriptionStatus.OFF;
    return _this;
  }
  /* eslint-enable max-params */

  /**
   *
   */


  _createClass(ChatRoom, [{
    key: "initPresenceMap",
    value: function initPresenceMap() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.presMap.to = this.myroomjid;
      this.presMap.xns = 'http://jabber.org/protocol/muc';
      this.presMap.nodes = [];

      if (options.enableStatsID) {
        this.presMap.nodes.push({
          'tagName': 'stats-id',
          'value': _Settings["default"].callStatsUserName
        });
      } // We need to broadcast 'videomuted' status from the beginning, cause
      // Jicofo makes decisions based on that. Initialize it with 'false'
      // here.


      this.addVideoInfoToPresence(false);

      if (options.deploymentInfo && options.deploymentInfo.userRegion) {
        this.presMap.nodes.push({
          'tagName': 'region',
          'attributes': {
            id: options.deploymentInfo.userRegion,
            xmlns: 'http://jitsi.org/jitsi-meet'
          }
        });
      }
    }
    /**
     * Joins the chat room.
     * @param password
     * @returns {Promise} - resolved when join completes. At the time of this
     * writing it's never rejected.
     */

  }, {
    key: "join",
    value: function join(password) {
      var _this2 = this;

      this.password = password;
      return new Promise(function (resolve) {
        _this2.options.disableFocus && logger.info('Conference focus disabled');
        var preJoin = _this2.options.disableFocus ? Promise.resolve() : _this2.moderator.allocateConferenceFocus();
        preJoin.then(function () {
          _this2.sendPresence(true);

          resolve();
        });
      });
    }
    /**
     *
     * @param fromJoin
     */

  }, {
    key: "sendPresence",
    value: function sendPresence(fromJoin) {
      var to = this.presMap.to;

      if (!to || !this.joined && !fromJoin) {
        // Too early to send presence - not initialized
        return;
      }

      var pres = (0, _strophe.$pres)({
        to: to
      }); // xep-0045 defines: "including in the initial presence stanza an empty
      // <x/> element qualified by the 'http://jabber.org/protocol/muc'
      // namespace" and subsequent presences should not include that or it can
      // be considered as joining, and server can send us the message history
      // for the room on every presence

      if (fromJoin) {
        pres.c('x', {
          xmlns: this.presMap.xns
        });

        if (this.password) {
          pres.c('password').t(this.password).up();
        }

        pres.up();
      }

      parser.json2packet(this.presMap.nodes, pres);
      this.connection.send(pres);

      if (fromJoin) {
        // XXX We're pressed for time here because we're beginning a complex
        // and/or lengthy conference-establishment process which supposedly
        // involves multiple RTTs. We don't have the time to wait for
        // Strophe to decide to send our IQ.
        this.connection.flush();
      }
    }
    /**
     * Sends the presence unavailable, signaling the server
     * we want to leave the room.
     */

  }, {
    key: "doLeave",
    value: function doLeave() {
      logger.log('do leave', this.myroomjid);
      var pres = (0, _strophe.$pres)({
        to: this.myroomjid,
        type: 'unavailable'
      });
      this.presMap.length = 0; // XXX Strophe is asynchronously sending by default. Unfortunately, that
      // means that there may not be enough time to send the unavailable
      // presence. Switching Strophe to synchronous sending is not much of an
      // option because it may lead to a noticeable delay in navigating away
      // from the current location. As a compromise, we will try to increase
      // the chances of sending the unavailable presence within the short time
      // span that we have upon unloading by invoking flush() on the
      // connection. We flush() once before sending/queuing the unavailable
      // presence in order to attemtp to have the unavailable presence at the
      // top of the send queue. We flush() once more after sending/queuing the
      // unavailable presence in order to attempt to have it sent as soon as
      // possible.

      this.connection.flush();
      this.connection.send(pres);
      this.connection.flush();
    }
    /**
     *
     */

  }, {
    key: "discoRoomInfo",
    value: function discoRoomInfo() {
      var _this3 = this;

      // https://xmpp.org/extensions/xep-0045.html#disco-roominfo
      var getInfo = (0, _strophe.$iq)({
        type: 'get',
        to: this.roomjid
      }).c('query', {
        xmlns: _strophe.Strophe.NS.DISCO_INFO
      });
      this.connection.sendIQ(getInfo, function (result) {
        var locked = $(result).find('>query>feature[var="muc_passwordprotected"]').length === 1;

        if (locked !== _this3.locked) {
          _this3.eventEmitter.emit(_XMPPEvents["default"].MUC_LOCK_CHANGED, locked);

          _this3.locked = locked;
        }
      }, function (error) {
        _GlobalOnErrorHandler["default"].callErrorHandler(error);

        logger.error('Error getting room info: ', error);
      });
    }
    /**
     *
     */

  }, {
    key: "createNonAnonymousRoom",
    value: function createNonAnonymousRoom() {
      // http://xmpp.org/extensions/xep-0045.html#createroom-reserved
      var getForm = (0, _strophe.$iq)({
        type: 'get',
        to: this.roomjid
      }).c('query', {
        xmlns: 'http://jabber.org/protocol/muc#owner'
      }).c('x', {
        xmlns: 'jabber:x:data',
        type: 'submit'
      });
      var self = this;
      this.connection.sendIQ(getForm, function (form) {
        if (!$(form).find('>query>x[xmlns="jabber:x:data"]' + '>field[var="muc#roomconfig_whois"]').length) {
          var errmsg = 'non-anonymous rooms not supported';

          _GlobalOnErrorHandler["default"].callErrorHandler(new Error(errmsg));

          logger.error(errmsg);
          return;
        }

        var formSubmit = (0, _strophe.$iq)({
          to: self.roomjid,
          type: 'set'
        }).c('query', {
          xmlns: 'http://jabber.org/protocol/muc#owner'
        });
        formSubmit.c('x', {
          xmlns: 'jabber:x:data',
          type: 'submit'
        });
        formSubmit.c('field', {
          'var': 'FORM_TYPE'
        }).c('value').t('http://jabber.org/protocol/muc#roomconfig').up().up();
        formSubmit.c('field', {
          'var': 'muc#roomconfig_whois'
        }).c('value').t('anyone').up().up();
        self.connection.sendIQ(formSubmit);
      }, function (error) {
        _GlobalOnErrorHandler["default"].callErrorHandler(error);

        logger.error('Error getting room configuration form: ', error);
      });
    }
    /**
     *
     * @param pres
     */

  }, {
    key: "onPresence",
    value: function onPresence(pres) {
      var from = pres.getAttribute('from');
      var member = {};
      var statusEl = pres.getElementsByTagName('status')[0];

      if (statusEl) {
        member.status = statusEl.textContent || '';
      }

      var hasStatusUpdate = false;
      var xElement = pres.getElementsByTagNameNS('http://jabber.org/protocol/muc#user', 'x')[0];
      var mucUserItem = xElement && xElement.getElementsByTagName('item')[0];
      member.affiliation = mucUserItem && mucUserItem.getAttribute('affiliation');
      member.role = mucUserItem && mucUserItem.getAttribute('role'); // Focus recognition

      var jid = mucUserItem && mucUserItem.getAttribute('jid');
      member.jid = jid;
      member.isFocus = jid && jid.indexOf("".concat(this.moderator.getFocusUserJid(), "/")) === 0;
      member.isHiddenDomain = jid && jid.indexOf('@') > 0 && this.options.hiddenDomain === jid.substring(jid.indexOf('@') + 1, jid.indexOf('/'));
      this.eventEmitter.emit(_XMPPEvents["default"].PRESENCE_RECEIVED, {
        fromHiddenDomain: member.isHiddenDomain,
        presence: pres
      });
      var xEl = pres.querySelector('x');

      if (xEl) {
        xEl.remove();
      }

      var nodes = [];
      parser.packet2JSON(pres, nodes);
      this.lastPresences[from] = nodes; // process nodes to extract data needed for MUC_JOINED and
      // MUC_MEMBER_JOINED events

      var extractIdentityInformation = function extractIdentityInformation(node) {
        var identity = {};
        var userInfo = node.children.find(function (c) {
          return c.tagName === 'user';
        });

        if (userInfo) {
          identity.user = {};

          var _loop = function _loop() {
            var tag = _arr[_i3];
            var child = userInfo.children.find(function (c) {
              return c.tagName === tag;
            });

            if (child) {
              identity.user[tag] = child.value;
            }
          };

          for (var _i3 = 0, _arr = ['id', 'name', 'avatar']; _i3 < _arr.length; _i3++) {
            _loop();
          }
        }

        var groupInfo = node.children.find(function (c) {
          return c.tagName === 'group';
        });

        if (groupInfo) {
          identity.group = groupInfo.value;
        }

        return identity;
      };

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];

        switch (node.tagName) {
          case 'bot':
            {
              var attributes = node.attributes;

              if (!attributes) {
                break;
              }

              var type = attributes.type;
              member.botType = type;
              break;
            }

          case 'nick':
            member.nick = node.value;
            break;

          case 'userId':
            member.id = node.value;
            break;

          case 'stats-id':
            member.statsID = node.value;
            break;

          case 'identity':
            member.identity = extractIdentityInformation(node);
            break;
        }
      }

      if (from === this.myroomjid) {
        var newRole = member.affiliation === 'owner' ? member.role : 'none';

        if (this.role !== newRole) {
          this.role = newRole;
          this.eventEmitter.emit(_XMPPEvents["default"].LOCAL_ROLE_CHANGED, this.role);
        }

        if (!this.joined) {
          this.joined = true;
          var now = this.connectionTimes['muc.joined'] = window.performance.now();
          logger.log('(TIME) MUC joined:\t', now); // set correct initial state of locked

          if (this.password) {
            this.locked = true;
          }

          this.eventEmitter.emit(_XMPPEvents["default"].MUC_JOINED);
        }
      } else if (this.members[from] === undefined) {
        // new participant
        this.members[from] = member;
        logger.log('entered', from, member);
        hasStatusUpdate = member.status !== undefined;

        if (member.isFocus) {
          this._initFocus(from, jid);
        } else {
          // identity is being added to member joined, so external
          // services can be notified for that (currently identity is
          // not used inside library)
          this.eventEmitter.emit(_XMPPEvents["default"].MUC_MEMBER_JOINED, from, member.nick, member.role, member.isHiddenDomain, member.statsID, member.status, member.identity, member.botType); // we are reporting the status with the join
          // so we do not want a second event about status update

          hasStatusUpdate = false;
        }
      } else {
        // Presence update for existing participant
        // Watch role change:
        var memberOfThis = this.members[from];

        if (memberOfThis.role !== member.role) {
          memberOfThis.role = member.role;
          this.eventEmitter.emit(_XMPPEvents["default"].MUC_ROLE_CHANGED, from, member.role);
        } // fire event that botType had changed


        if (memberOfThis.botType !== member.botType) {
          memberOfThis.botType = member.botType;
          this.eventEmitter.emit(_XMPPEvents["default"].MUC_MEMBER_BOT_TYPE_CHANGED, from, member.botType);
        }

        if (member.isFocus) {
          // From time to time first few presences of the focus are not
          // containing it's jid. That way we can mark later the focus
          // member instead of not marking it at all and not starting the
          // conference.
          // FIXME: Maybe there is a better way to handle this issue. It
          // seems there is some period of time in prosody that the
          // configuration form is received but not applied. And if any
          // participant joins during that period of time the first
          // presence from the focus won't contain
          // <item jid="focus..." />.
          memberOfThis.isFocus = true;

          this._initFocus(from, jid);
        } // store the new display name


        if (member.displayName) {
          memberOfThis.displayName = member.displayName;
        } // update stored status message to be able to detect changes


        if (memberOfThis.status !== member.status) {
          hasStatusUpdate = true;
          memberOfThis.status = member.status;
        }
      } // after we had fired member or room joined events, lets fire events
      // for the rest info we got in presence


      for (var _i4 = 0; _i4 < nodes.length; _i4++) {
        var _node = nodes[_i4];

        switch (_node.tagName) {
          case 'nick':
            if (!member.isFocus) {
              var displayName = this.xmpp.options.displayJids ? _strophe.Strophe.getResourceFromJid(from) : member.nick;
              this.eventEmitter.emit(_XMPPEvents["default"].DISPLAY_NAME_CHANGED, from, displayName);
            }

            break;

          case 'bridgeNotAvailable':
            if (member.isFocus && !this.noBridgeAvailable) {
              this.noBridgeAvailable = true;
              this.eventEmitter.emit(_XMPPEvents["default"].BRIDGE_DOWN);
            }

            break;

          case 'conference-properties':
            if (member.isFocus) {
              var properties = {};

              for (var j = 0; j < _node.children.length; j++) {
                var _attributes = _node.children[j].attributes;

                if (_attributes && _attributes.key) {
                  properties[_attributes.key] = _attributes.value;
                }
              }

              this.eventEmitter.emit(_XMPPEvents["default"].CONFERENCE_PROPERTIES_CHANGED, properties);
            }

            break;

          case 'transcription-status':
            {
              var _attributes2 = _node.attributes;

              if (!_attributes2) {
                break;
              }

              var status = _attributes2.status;

              if (status && status !== this.transcriptionStatus) {
                this.transcriptionStatus = status;
                this.eventEmitter.emit(_XMPPEvents["default"].TRANSCRIPTION_STATUS_CHANGED, status);
              }

              break;
            }

          case 'call-control':
            {
              var att = _node.attributes;

              if (!att) {
                break;
              }

              this.phoneNumber = att.phone || null;
              this.phonePin = att.pin || null;
              this.eventEmitter.emit(_XMPPEvents["default"].PHONE_NUMBER_CHANGED);
              break;
            }

          default:
            this.processNode(_node, from);
        }
      } // Trigger status message update if necessary


      if (hasStatusUpdate) {
        this.eventEmitter.emit(_XMPPEvents["default"].PRESENCE_STATUS, from, member.status);
      }
    }
    /**
     * Initialize some properties when the focus participant is verified.
     * @param from jid of the focus
     * @param mucJid the jid of the focus in the muc
     */

  }, {
    key: "_initFocus",
    value: function _initFocus(from, mucJid) {
      this.focusMucJid = from;
      logger.info("Ignore focus: ".concat(from, ", real JID: ").concat(mucJid));
    }
    /**
     * Sets the special listener to be used for "command"s whose name starts
     * with "jitsi_participant_".
     */

  }, {
    key: "setParticipantPropertyListener",
    value: function setParticipantPropertyListener(listener) {
      this.participantPropertyListener = listener;
    }
    /**
     *
     * @param node
     * @param from
     */

  }, {
    key: "processNode",
    value: function processNode(node, from) {
      // make sure we catch all errors coming from any handler
      // otherwise we can remove the presence handler from strophe
      try {
        var tagHandlers = this.presHandlers[node.tagName];

        if (node.tagName.startsWith('jitsi_participant_')) {
          tagHandlers = [this.participantPropertyListener];
        }

        if (tagHandlers) {
          tagHandlers.forEach(function (handler) {
            handler(node, _strophe.Strophe.getResourceFromJid(from), from);
          });
        }
      } catch (e) {
        _GlobalOnErrorHandler["default"].callErrorHandler(e);

        logger.error("Error processing:".concat(node.tagName, " node."), e);
      }
    }
    /**
     * Send text message to the other participants in the conference
     * @param message
     * @param elementName
     * @param nickname
     */

  }, {
    key: "sendMessage",
    value: function sendMessage(message, elementName, nickname) {
      var msg = (0, _strophe.$msg)({
        to: this.roomjid,
        type: 'groupchat'
      }); // We are adding the message in a packet extension. If this element
      // is different from 'body', we add a custom namespace.
      // e.g. for 'json-message' extension of message stanza.

      if (elementName === 'body') {
        msg.c(elementName, message).up();
      } else {
        msg.c(elementName, {
          xmlns: 'http://jitsi.org/jitmeet'
        }, message).up();
      }

      if (nickname) {
        msg.c('nick', {
          xmlns: 'http://jabber.org/protocol/nick'
        }).t(nickname).up().up();
      }

      this.connection.send(msg);
      this.eventEmitter.emit(_XMPPEvents["default"].SENDING_CHAT_MESSAGE, message);
    }
    /* eslint-disable max-params */

    /**
     * Send private text message to another participant of the conference
     * @param id id/muc resource of the receiver
     * @param message
     * @param elementName
     * @param nickname
     */

  }, {
    key: "sendPrivateMessage",
    value: function sendPrivateMessage(id, message, elementName, nickname) {
      var msg = (0, _strophe.$msg)({
        to: "".concat(this.roomjid, "/").concat(id),
        type: 'chat'
      }); // We are adding the message in packet. If this element is different
      // from 'body', we add our custom namespace for the same.
      // e.g. for 'json-message' message extension.

      if (elementName === 'body') {
        msg.c(elementName, message).up();
      } else {
        msg.c(elementName, {
          xmlns: 'http://jitsi.org/jitmeet'
        }, message).up();
      }

      if (nickname) {
        msg.c('nick', {
          xmlns: 'http://jabber.org/protocol/nick'
        }).t(nickname).up().up();
      }

      this.connection.send(msg);
      this.eventEmitter.emit(_XMPPEvents["default"].SENDING_PRIVATE_CHAT_MESSAGE, message);
    }
    /* eslint-enable max-params */

    /**
     *
     * @param subject
     */

  }, {
    key: "setSubject",
    value: function setSubject(subject) {
      var msg = (0, _strophe.$msg)({
        to: this.roomjid,
        type: 'groupchat'
      });
      msg.c('subject', subject);
      this.connection.send(msg);
    }
    /**
     * Called when participant leaves.
     * @param jid the jid of the participant that leaves
     * @param skipEvents optional params to skip any events, including check
     * whether this is the focus that left
     */

  }, {
    key: "onParticipantLeft",
    value: function onParticipantLeft(jid, skipEvents) {
      delete this.lastPresences[jid];

      if (skipEvents) {
        return;
      }

      this.eventEmitter.emit(_XMPPEvents["default"].MUC_MEMBER_LEFT, jid);
      this.moderator.onMucMemberLeft(jid);
    }
    /**
     *
     * @param pres
     * @param from
     */

  }, {
    key: "onPresenceUnavailable",
    value: function onPresenceUnavailable(pres, from) {
      var _this4 = this;

      // ignore presence
      if ($(pres).find('>ignore[xmlns="http://jitsi.org/jitmeet/"]').length) {
        return true;
      } // room destroyed ?


      if ($(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]' + '>destroy').length) {
        var reason;
        var reasonSelect = $(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]' + '>destroy>reason');

        if (reasonSelect.length) {
          reason = reasonSelect.text();
        }

        this.eventEmitter.emit(_XMPPEvents["default"].MUC_DESTROYED, reason);
        this.connection.emuc.doLeave(this.roomjid);
        return true;
      } // Status code 110 indicates that this notification is "self-presence".


      var isSelfPresence = $(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>' + 'status[code="110"]').length;
      var isKick = $(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]' + '>status[code="307"]').length;
      var membersKeys = Object.keys(this.members);

      if (isSelfPresence) {
        // If the status code is 110 this means we're leaving and we would
        // like to remove everyone else from our view, so we trigger the
        // event.
        membersKeys.forEach(function (jid) {
          var member = _this4.members[jid];
          delete _this4.members[jid];

          _this4.onParticipantLeft(jid, member.isFocus);
        });
        this.connection.emuc.doLeave(this.roomjid); // we fire muc_left only if this is not a kick,
        // kick has both statuses 110 and 307.

        if (!isKick) {
          this.eventEmitter.emit(_XMPPEvents["default"].MUC_LEFT);
        }
      } else {
        delete this.members[from];
        this.onParticipantLeft(from, false);
      }

      if (isKick && this.myroomjid === from) {
        this.eventEmitter.emit(_XMPPEvents["default"].KICKED);
      }
    }
    /**
     *
     * @param msg
     * @param from
     */

  }, {
    key: "onMessage",
    value: function onMessage(msg, from) {
      var nick = $(msg).find('>nick[xmlns="http://jabber.org/protocol/nick"]').text() || _strophe.Strophe.getResourceFromJid(from);

      var txt = $(msg).find('>body').text();
      var type = msg.getAttribute('type');

      if (type === 'error') {
        this.eventEmitter.emit(_XMPPEvents["default"].CHAT_ERROR_RECEIVED, $(msg).find('>text').text(), txt);
        return true;
      }

      var subject = $(msg).find('>subject');

      if (subject.length) {
        var subjectText = subject.text();

        if (subjectText || subjectText === '') {
          this.eventEmitter.emit(_XMPPEvents["default"].SUBJECT_CHANGED, subjectText);
          logger.log("Subject is changed to ".concat(subjectText));
        }
      } // xep-0203 delay


      var stamp = $(msg).find('>delay').attr('stamp');

      if (!stamp) {
        // or xep-0091 delay, UTC timestamp
        stamp = $(msg).find('>[xmlns="jabber:x:delay"]').attr('stamp');

        if (stamp) {
          // the format is CCYYMMDDThh:mm:ss
          var dateParts = stamp.match(/(\d{4})(\d{2})(\d{2}T\d{2}:\d{2}:\d{2})/);
          stamp = "".concat(dateParts[1], "-").concat(dateParts[2], "-").concat(dateParts[3], "Z");
        }
      }

      if (from === this.roomjid && $(msg).find('>x[xmlns="http://jabber.org/protocol/muc#user"]' + '>status[code="104"]').length) {
        this.discoRoomInfo();
      }

      var jsonMessage = $(msg).find('>json-message').text();
      var parsedJson = this.xmpp.tryParseJSONAndVerify(jsonMessage); // We emit this event if the message is a valid json, and is not
      // delivered after a delay, i.e. stamp is undefined.
      // e.g. - subtitles should not be displayed if delayed.

      if (parsedJson && stamp === undefined) {
        this.eventEmitter.emit(_XMPPEvents["default"].JSON_MESSAGE_RECEIVED, from, parsedJson);
        return;
      }

      if (txt) {
        if (type === 'chat') {
          this.eventEmitter.emit(_XMPPEvents["default"].PRIVATE_MESSAGE_RECEIVED, from, nick, txt, this.myroomjid, stamp);
        } else if (type === 'groupchat') {
          this.eventEmitter.emit(_XMPPEvents["default"].MESSAGE_RECEIVED, from, nick, txt, this.myroomjid, stamp);
        }
      }
    }
    /**
     *
     * @param pres
     * @param from
     */

  }, {
    key: "onPresenceError",
    value: function onPresenceError(pres, from) {
      if ($(pres).find('>error[type="auth"]' + '>not-authorized[' + 'xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
        logger.log('on password required', from);
        this.eventEmitter.emit(_XMPPEvents["default"].PASSWORD_REQUIRED);
      } else if ($(pres).find('>error[type="cancel"]' + '>not-allowed[' + 'xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
        var toDomain = _strophe.Strophe.getDomainFromJid(pres.getAttribute('to'));

        if (toDomain === this.xmpp.options.hosts.anonymousdomain) {
          // enter the room by replying with 'not-authorized'. This would
          // result in reconnection from authorized domain.
          // We're either missing Jicofo/Prosody config for anonymous
          // domains or something is wrong.
          this.eventEmitter.emit(_XMPPEvents["default"].ROOM_JOIN_ERROR);
        } else {
          logger.warn('onPresError ', pres);
          this.eventEmitter.emit(_XMPPEvents["default"].ROOM_CONNECT_NOT_ALLOWED_ERROR);
        }
      } else if ($(pres).find('>error>service-unavailable').length) {
        logger.warn('Maximum users limit for the room has been reached', pres);
        this.eventEmitter.emit(_XMPPEvents["default"].ROOM_MAX_USERS_ERROR);
      } else {
        logger.warn('onPresError ', pres);
        this.eventEmitter.emit(_XMPPEvents["default"].ROOM_CONNECT_ERROR);
      }
    }
    /**
     *
     * @param jid
     */

  }, {
    key: "kick",
    value: function kick(jid) {
      var kickIQ = (0, _strophe.$iq)({
        to: this.roomjid,
        type: 'set'
      }).c('query', {
        xmlns: 'http://jabber.org/protocol/muc#admin'
      }).c('item', {
        nick: _strophe.Strophe.getResourceFromJid(jid),
        role: 'none'
      }).c('reason').t('You have been kicked.').up().up().up();
      this.connection.sendIQ(kickIQ, function (result) {
        return logger.log('Kick participant with jid: ', jid, result);
      }, function (error) {
        return logger.log('Kick participant error: ', error);
      });
    }
    /* eslint-disable max-params */

    /**
     *
     * @param key
     * @param onSuccess
     * @param onError
     * @param onNotSupported
     */

  }, {
    key: "lockRoom",
    value: function lockRoom(key, onSuccess, onError, onNotSupported) {
      var _this5 = this;

      // http://xmpp.org/extensions/xep-0045.html#roomconfig
      this.connection.sendIQ((0, _strophe.$iq)({
        to: this.roomjid,
        type: 'get'
      }).c('query', {
        xmlns: 'http://jabber.org/protocol/muc#owner'
      }), function (res) {
        if ($(res).find('>query>x[xmlns="jabber:x:data"]' + '>field[var="muc#roomconfig_roomsecret"]').length) {
          var formsubmit = (0, _strophe.$iq)({
            to: _this5.roomjid,
            type: 'set'
          }).c('query', {
            xmlns: 'http://jabber.org/protocol/muc#owner'
          });
          formsubmit.c('x', {
            xmlns: 'jabber:x:data',
            type: 'submit'
          });
          formsubmit.c('field', {
            'var': 'FORM_TYPE'
          }).c('value').t('http://jabber.org/protocol/muc#roomconfig').up().up();
          formsubmit.c('field', {
            'var': 'muc#roomconfig_roomsecret'
          }).c('value').t(key).up().up(); // Fixes a bug in prosody 0.9.+
          // https://prosody.im/issues/issue/373

          formsubmit.c('field', {
            'var': 'muc#roomconfig_whois'
          }).c('value').t('anyone').up().up(); // FIXME: is muc#roomconfig_passwordprotectedroom required?

          _this5.connection.sendIQ(formsubmit, onSuccess, onError);
        } else {
          onNotSupported();
        }
      }, onError);
    }
    /* eslint-enable max-params */

    /**
     *
     * @param key
     * @param values
     */

  }, {
    key: "addToPresence",
    value: function addToPresence(key, values) {
      values.tagName = key;
      this.removeFromPresence(key);
      this.presMap.nodes.push(values);
    }
    /**
     *
     * @param key
     */

  }, {
    key: "removeFromPresence",
    value: function removeFromPresence(key) {
      var nodes = this.presMap.nodes.filter(function (node) {
        return key !== node.tagName;
      });
      this.presMap.nodes = nodes;
    }
    /**
     *
     * @param name
     * @param handler
     */

  }, {
    key: "addPresenceListener",
    value: function addPresenceListener(name, handler) {
      if (typeof handler !== 'function') {
        throw new Error('"handler" is not a function');
      }

      var tagHandlers = this.presHandlers[name];

      if (!tagHandlers) {
        this.presHandlers[name] = tagHandlers = [];
      }

      if (tagHandlers.indexOf(handler) === -1) {
        tagHandlers.push(handler);
      } else {
        logger.warn("Trying to add the same handler more than once for: ".concat(name));
      }
    }
    /**
     *
     * @param name
     * @param handler
     */

  }, {
    key: "removePresenceListener",
    value: function removePresenceListener(name, handler) {
      var tagHandlers = this.presHandlers[name];
      var handlerIdx = tagHandlers ? tagHandlers.indexOf(handler) : -1; // eslint-disable-next-line no-negated-condition

      if (handlerIdx !== -1) {
        tagHandlers.splice(handlerIdx, 1);
      } else {
        logger.warn("Handler for: ".concat(name, " was not registered"));
      }
    }
    /**
     * Checks if the user identified by given <tt>mucJid</tt> is the conference
     * focus.
     * @param mucJid the full MUC address of the user to be checked.
     * @returns {boolean|null} <tt>true</tt> if MUC user is the conference focus
     * or <tt>false</tt> if is not. When given <tt>mucJid</tt> does not exist in
     * the MUC then <tt>null</tt> is returned.
     */

  }, {
    key: "isFocus",
    value: function isFocus(mucJid) {
      var member = this.members[mucJid];

      if (member) {
        return member.isFocus;
      }

      return null;
    }
    /**
     *
     */

  }, {
    key: "isModerator",
    value: function isModerator() {
      return this.role === 'moderator';
    }
    /**
     *
     * @param peerJid
     */

  }, {
    key: "getMemberRole",
    value: function getMemberRole(peerJid) {
      if (this.members[peerJid]) {
        return this.members[peerJid].role;
      }

      return null;
    }
    /**
     *
     * @param mute
     * @param callback
     */

  }, {
    key: "setVideoMute",
    value: function setVideoMute(mute, callback) {
      this.sendVideoInfoPresence(mute);

      if (callback) {
        callback(mute);
      }
    }
    /**
     *
     * @param mute
     * @param callback
     */

  }, {
    key: "setAudioMute",
    value: function setAudioMute(mute, callback) {
      return this.sendAudioInfoPresence(mute, callback);
    }
    /**
     *
     * @param mute
     */

  }, {
    key: "addAudioInfoToPresence",
    value: function addAudioInfoToPresence(mute) {
      this.removeFromPresence('audiomuted');
      this.addToPresence('audiomuted', {
        attributes: {
          'xmlns': 'http://jitsi.org/jitmeet/audio'
        },
        value: mute.toString()
      });
    }
    /**
     *
     * @param mute
     * @param callback
     */

  }, {
    key: "sendAudioInfoPresence",
    value: function sendAudioInfoPresence(mute, callback) {
      this.addAudioInfoToPresence(mute);

      if (this.connection) {
        this.sendPresence();
      }

      if (callback) {
        callback();
      }
    }
    /**
     *
     * @param mute
     */

  }, {
    key: "addVideoInfoToPresence",
    value: function addVideoInfoToPresence(mute) {
      this.removeFromPresence('videomuted');
      this.addToPresence('videomuted', {
        attributes: {
          'xmlns': 'http://jitsi.org/jitmeet/video'
        },
        value: mute.toString()
      });
    }
    /**
     *
     * @param mute
     */

  }, {
    key: "sendVideoInfoPresence",
    value: function sendVideoInfoPresence(mute) {
      this.addVideoInfoToPresence(mute);

      if (!this.connection) {
        return;
      }

      this.sendPresence();
    }
    /**
     * Obtains the info about given media advertised in the MUC presence of
     * the participant identified by the given endpoint JID.
     * @param {string} endpointId the endpoint ID mapped to the participant
     * which corresponds to MUC nickname.
     * @param {MediaType} mediaType the type of the media for which presence
     * info will be obtained.
     * @return {PeerMediaInfo} presenceInfo an object with media presence
     * info or <tt>null</tt> either if there is no presence available or if
     * the media type given is invalid.
     */

  }, {
    key: "getMediaPresenceInfo",
    value: function getMediaPresenceInfo(endpointId, mediaType) {
      // Will figure out current muted status by looking up owner's presence
      var pres = this.lastPresences["".concat(this.roomjid, "/").concat(endpointId)];

      if (!pres) {
        // No presence available
        return null;
      }

      var data = {
        muted: false,
        // unmuted by default
        videoType: undefined // no video type by default

      };
      var mutedNode = null;

      if (mediaType === MediaType.AUDIO) {
        mutedNode = filterNodeFromPresenceJSON(pres, 'audiomuted');
      } else if (mediaType === MediaType.VIDEO) {
        mutedNode = filterNodeFromPresenceJSON(pres, 'videomuted');
        var videoTypeNode = filterNodeFromPresenceJSON(pres, 'videoType');

        if (videoTypeNode.length > 0) {
          data.videoType = videoTypeNode[0].value;
        }
      } else {
        logger.error("Unsupported media type: ".concat(mediaType));
        return null;
      }

      data.muted = mutedNode.length > 0 && mutedNode[0].value === 'true';
      return data;
    }
    /**
     * Returns true if the SIP calls are supported and false otherwise
     */

  }, {
    key: "isSIPCallingSupported",
    value: function isSIPCallingSupported() {
      if (this.moderator) {
        return this.moderator.isSipGatewayEnabled();
      }

      return false;
    }
    /**
     * Dials a number.
     * @param number the number
     */

  }, {
    key: "dial",
    value: function dial(number) {
      return this.connection.rayo.dial(number, 'fromnumber', _strophe.Strophe.getBareJidFromJid(this.myroomjid), this.password, this.focusMucJid);
    }
    /**
     * Hangup an existing call
     */

  }, {
    key: "hangup",
    value: function hangup() {
      return this.connection.rayo.hangup();
    }
    /**
     * Returns the phone number for joining the conference.
     */

  }, {
    key: "getPhoneNumber",
    value: function getPhoneNumber() {
      return this.phoneNumber;
    }
    /**
     * Returns the pin for joining the conference with phone.
     */

  }, {
    key: "getPhonePin",
    value: function getPhonePin() {
      return this.phonePin;
    }
    /**
     * Mutes remote participant.
     * @param jid of the participant
     * @param mute
     */

  }, {
    key: "muteParticipant",
    value: function muteParticipant(jid, mute) {
      logger.info('set mute', mute);
      var iqToFocus = (0, _strophe.$iq)({
        to: this.focusMucJid,
        type: 'set'
      }).c('mute', {
        xmlns: 'http://jitsi.org/jitmeet/audio',
        jid: jid
      }).t(mute.toString()).up();
      this.connection.sendIQ(iqToFocus, function (result) {
        return logger.log('set mute', result);
      }, function (error) {
        return logger.log('set mute error', error);
      });
    }
    /**
     * TODO: Document
     * @param iq
     */

  }, {
    key: "onMute",
    value: function onMute(iq) {
      var from = iq.getAttribute('from');

      if (from !== this.focusMucJid) {
        logger.warn('Ignored mute from non focus peer');
        return;
      }

      var mute = $(iq).find('mute');

      if (mute.length && mute.text() === 'true') {
        this.eventEmitter.emit(_XMPPEvents["default"].AUDIO_MUTED_BY_FOCUS);
      } else {
        // XXX Why do we support anything but muting? Why do we encode the
        // value in the text of the element? Why do we use a separate XML
        // namespace?
        logger.warn('Ignoring a mute request which does not explicitly ' + 'specify a positive mute command.');
      }
    }
    /**
     * Leaves the room. Closes the jingle session.
     * @returns {Promise} which is resolved if XMPPEvents.MUC_LEFT is received
     * less than 10s after sending presence unavailable.
     * Otherwise the promise is rejected.
     */

  }, {
    key: "leave",
    value: function leave() {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        var timeout = setTimeout(function () {
          return onMucLeft(true);
        }, 10000);
        var eventEmitter = _this6.eventEmitter;
        /**
         *
         * @param doReject
         */

        function onMucLeft() {
          var doReject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          eventEmitter.removeListener(_XMPPEvents["default"].MUC_LEFT, onMucLeft);
          clearTimeout(timeout);

          if (doReject) {
            // the timeout expired
            reject(new Error('The timeout for the confirmation about ' + 'leaving the room expired.'));
          } else {
            resolve();
          }
        }

        eventEmitter.on(_XMPPEvents["default"].MUC_LEFT, onMucLeft);

        _this6.doLeave();
      });
    }
  }]);

  return ChatRoom;
}(_Listenable2["default"]);
/* eslint-enable newline-per-chained-call */


exports["default"] = ChatRoom;
"use strict";

var _ChatRoom = _interopRequireWildcard(require("./ChatRoom"));

var _strophe = require("strophe.js");

var _XMPPEvents = _interopRequireDefault(require("../../service/xmpp/XMPPEvents"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// This rule makes creating the xml elements take up way more
// space than necessary.

/* eslint-disable newline-per-chained-call */
// These rules makes the xml strings harder to read

/* eslint-disable operator-linebreak, max-len */
describe('ChatRoom', function () {
  describe('packet2JSON', function () {
    var nodes = [];
    beforeEach(function () {
      nodes = [];
    });
    it('translates attributes correctly', function () {
      var p = (0, _strophe.$pres)({
        to: 'tojid',
        from: 'fromjid'
      }).c('fake-with-attr', {
        fakeAttr1: 'attrValue1',
        fakeAttr2: 'attrValue2'
      }).up();

      _ChatRoom.parser.packet2JSON(p.tree(), nodes);

      expect(nodes.length).toBe(1);
      var fakeWithAttr = nodes.find(function (n) {
        return n.tagName === 'fake-with-attr';
      });
      expect(fakeWithAttr).toBeTruthy();
      expect(Object.keys(fakeWithAttr.attributes).length).toEqual(2);
      expect(fakeWithAttr.attributes.fakeAttr1).toBeTruthy();
      expect(fakeWithAttr.attributes.fakeAttr1).toEqual('attrValue1');
      expect(fakeWithAttr.attributes.fakeAttr2).toBeTruthy();
      expect(fakeWithAttr.attributes.fakeAttr2).toEqual('attrValue2');
      expect(fakeWithAttr.children.length).toEqual(0);
      expect(fakeWithAttr.value).toBeFalsy();
    });
    it('translates element text correctly', function () {
      var p = (0, _strophe.$pres)({
        to: 'tojid',
        from: 'fromjid'
      }).c('element-name').t('element-name-text').up();

      _ChatRoom.parser.packet2JSON(p.tree(), nodes);

      expect(nodes.length).toBe(1);
      var elem = nodes.find(function (n) {
        return n.tagName === 'element-name';
      });
      expect(elem).toBeTruthy();
      expect(Object.keys(elem.attributes).length).toEqual(0);
      expect(elem.children.length).toEqual(0);
      expect(elem.value).toEqual('element-name-text');
    });
    it('translates elements with children correctly', function () {
      var p = (0, _strophe.$pres)({
        to: 'tojid',
        from: 'fromjid'
      }).c('identity').c('user').c('id').t('id-text').up().c('name').t('name-text').up().c('avatar').t('avatar-text').up().up().c('group').t('group-text').up().up();

      _ChatRoom.parser.packet2JSON(p.tree(), nodes);

      var identity = nodes.find(function (n) {
        return n.tagName === 'identity';
      });
      expect(identity).toBeTruthy();
      expect(Object.keys(identity.attributes).length).toEqual(0);
      expect(identity.children.length).toEqual(2);
      {
        var user = identity.children.find(function (n) {
          return n.tagName === 'user';
        });
        expect(user).toBeTruthy();
        expect(Object.keys(user.attributes).length).toEqual(0);
        expect(user.children.length).toEqual(3);
        {
          var id = user.children.find(function (n) {
            return n.tagName === 'id';
          });
          expect(id).toBeTruthy();
          expect(Object.keys(id.attributes).length).toEqual(0);
          expect(id.children.length).toEqual(0);
          expect(id.value).toEqual('id-text');
        }
        {
          var name = user.children.find(function (n) {
            return n.tagName === 'name';
          });
          expect(name).toBeTruthy();
          expect(Object.keys(name.attributes).length).toEqual(0);
          expect(name.children.length).toEqual(0);
          expect(name.value).toEqual('name-text');
        }
        {
          var avatar = user.children.find(function (n) {
            return n.tagName === 'avatar';
          });
          expect(avatar).toBeTruthy();
          expect(Object.keys(avatar.attributes).length).toEqual(0);
          expect(avatar.children.length).toEqual(0);
          expect(avatar.value).toEqual('avatar-text');
        }
        expect(user.value).toBeFalsy();
      }
      {
        var group = identity.children.find(function (n) {
          return n.tagName === 'group';
        });
        expect(group).toBeTruthy();
        expect(Object.keys(group.attributes).length).toEqual(0);
        expect(group.children.length).toEqual(0);
        expect(group.value).toEqual('group-text');
      }
      expect(identity.value).toBeFalsy();
    });
  });
  describe('onPresence', function () {
    var room;
    var emitterSpy;
    beforeEach(function () {
      var xmpp = {
        options: {}
      };
      room = new _ChatRoom["default"]({}
      /* connection */
      , 'jid', 'password', xmpp, {}
      /* options */
      );
      emitterSpy = spyOn(room.eventEmitter, 'emit');
    });
    it('parses status correctly', function () {
      var presStr = '' + '<presence to="tojid" from="fromjid">' + '<status>status-text</status>' + '</presence>';
      var pres = new DOMParser().parseFromString(presStr, 'text/xml').documentElement;
      room.onPresence(pres);
      expect(emitterSpy.calls.count()).toEqual(2);
      expect(emitterSpy.calls.argsFor(0)).toEqual([_XMPPEvents["default"].PRESENCE_RECEIVED, jasmine.any(Object)]);
      expect(emitterSpy).toHaveBeenCalledWith(_XMPPEvents["default"].MUC_MEMBER_JOINED, 'fromjid', undefined, // nick
      undefined, // role
      undefined, // isHiddenDomain
      undefined, // statsID
      'status-text', undefined, undefined);
    });
    it('parses muc user item correctly', function () {
      var presStr = '' + '<presence to="tojid" from="fromjid">' + '<x xmlns="http://jabber.org/protocol/muc#user">' + '<item jid="jid=attr" affiliation="affiliation-attr" role="role-attr"/>' + '</x>' + '</presence>';
      var pres = new DOMParser().parseFromString(presStr, 'text/xml').documentElement;
      room.onPresence(pres);
      expect(emitterSpy.calls.count()).toEqual(2);
      expect(emitterSpy.calls.argsFor(0)).toEqual([_XMPPEvents["default"].PRESENCE_RECEIVED, jasmine.any(Object)]);
      expect(emitterSpy).toHaveBeenCalledWith(_XMPPEvents["default"].MUC_MEMBER_JOINED, 'fromjid', undefined, // nick
      'role-attr', // role
      jasmine.any(Boolean), // isHiddenDomain
      undefined, // statsID
      undefined, undefined, undefined);
    });
    it('parses identity correctly', function () {
      var presStr = '' + '<presence to="tojid" from="fromjid">' + '<status>status-text</status>' + '<identity>' + '<user>' + '<id>id-text</id>' + '<name>name-text</name>' + '<avatar>avatar-text</avatar>' + '</user>' + '<group>group-text</group>' + '</identity>' + '</presence>';
      var pres = new DOMParser().parseFromString(presStr, 'text/xml').documentElement;
      var expectedIdentity = {
        user: {
          id: 'id-text',
          name: 'name-text',
          avatar: 'avatar-text'
        },
        group: 'group-text'
      };
      room.onPresence(pres);
      expect(emitterSpy.calls.count()).toEqual(2);
      expect(emitterSpy.calls.argsFor(0)).toEqual([_XMPPEvents["default"].PRESENCE_RECEIVED, jasmine.any(Object)]);
      expect(emitterSpy).toHaveBeenCalledWith(_XMPPEvents["default"].MUC_MEMBER_JOINED, 'fromjid', undefined, // nick
      undefined, // role
      undefined, // isHiddenDomain
      undefined, // statsID
      'status-text', expectedIdentity, undefined);
    });
    it('parses bot correctly', function () {
      var expectedBotType = 'some_bot_type';
      var presStr = '' + '<presence to="tojid" from="fromjid">' + '<status>status-text</status>' + "<bot type=\"".concat(expectedBotType, "\"/>") + '</presence>';
      var pres = new DOMParser().parseFromString(presStr, 'text/xml').documentElement;
      room.onPresence(pres);
      expect(emitterSpy.calls.count()).toEqual(2);
      expect(emitterSpy.calls.argsFor(0)).toEqual([_XMPPEvents["default"].PRESENCE_RECEIVED, jasmine.any(Object)]);
      expect(emitterSpy).toHaveBeenCalledWith(_XMPPEvents["default"].MUC_MEMBER_JOINED, 'fromjid', undefined, // nick
      undefined, // role
      undefined, // isHiddenDomain
      undefined, // statsID
      'status-text', undefined, expectedBotType);
    });
  });
});
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConnectionPluginListenable = exports["default"] = void 0;

var _Listenable = _interopRequireDefault(require("../util/Listenable"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Creates ConnectionPlugin class that extends the passed class.
 * @param {Class} base the definition of the class that will be extended by
 * ConnectionPlugin
 */
function getConnectionPluginDefinition() {
  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] :
  /*#__PURE__*/
  function () {
    function _class() {
      _classCallCheck(this, _class);
    }

    return _class;
  }();

  /**
   * Base class for strophe connection plugins.
   */
  return (
    /*#__PURE__*/
    function (_base) {
      _inherits(_class2, _base);

      /**
       *
       */
      function _class2() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck(this, _class2);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(_class2)).call.apply(_getPrototypeOf2, [this].concat(args)));
        _this.connection = null;
        return _this;
      }
      /**
       *
       * @param connection
       */


      _createClass(_class2, [{
        key: "init",
        value: function init(connection) {
          this.connection = connection;
        }
      }]);

      return _class2;
    }(base)
  );
}
/**
 * ConnectionPlugin class.
 */


var _default = getConnectionPluginDefinition();
/**
 * ConnectionPlugin class that extends Listenable.
 */


exports["default"] = _default;
var ConnectionPluginListenable = getConnectionPluginDefinition(_Listenable["default"]);
exports.ConnectionPluginListenable = ConnectionPluginListenable;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jitsiMeetLogger = require("jitsi-meet-logger");

var JingleSessionState = _interopRequireWildcard(require("./JingleSessionState"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var logger = (0, _jitsiMeetLogger.getLogger)(__filename);
/**
 * JingleSession provides an API to manage a single Jingle session. We will
 * have different implementations depending on the underlying interface used
 * (i.e. WebRTC and ORTC) and here we hold the code common to all of them.
 */

var JingleSession =
/*#__PURE__*/
function () {
  /* eslint-disable max-params */

  /**
   * Creates new <tt>JingleSession</tt>.
   * @param {string} sid the Jingle session identifier
   * @param {string} localJid our JID
   * @param {string} remoteJid the JID of the remote peer
   * @param {Strophe.Connection} connection the XMPP connection
   * @param {Object} mediaConstraints the media constraints object passed to
   * the PeerConnection onCreateAnswer/Offer as defined by the WebRTC.
   * @param {Object} iceConfig the ICE servers config object as defined by
   * the WebRTC. Passed to the PeerConnection's constructor.
   * @param {boolean} isInitiator indicates if it will be the side which
   * initiates the session.
   */
  function JingleSession(sid, localJid, remoteJid, connection, mediaConstraints, iceConfig, isInitiator) {
    _classCallCheck(this, JingleSession);

    this.sid = sid;
    this.localJid = localJid;
    this.remoteJid = remoteJid;
    this.connection = connection;
    this.mediaConstraints = mediaConstraints;
    this.iceConfig = iceConfig;
    /**
     * Indicates whether this instance is an initiator or an answerer of
     * the Jingle session.
     * @type {boolean}
     */

    this.isInitiator = isInitiator;
    /**
     * Whether to use dripping or not. Dripping is sending trickle
     * candidates not one-by-one.
     */

    this.usedrip = true;
    /**
     *  When dripping is used, stores ICE candidates which are to be sent.
     */

    this.dripContainer = [];
    /**
     * The chat room instance associated with the session.
     * @type {ChatRoom}
     */

    this.room = null;
    /**
     * Jingle session state - uninitialized until {@link initialize} is
     * called @type {JingleSessionState}
     */

    this.state = null;
    /**
     * The RTC service instance
     * @type {RTC}
     */

    this.rtc = null;
  }
  /**
   * Returns XMPP address of this session's initiator.
   * @return {string}
   */


  _createClass(JingleSession, [{
    key: "initialize",

    /* eslint-enable max-params */

    /**
     * Prepares this object to initiate a session.
     * @param {ChatRoom} room the chat room for the conference associated with
     * this session
     * @param {RTC} rtc the RTC service instance
     * @param {object} options - the options, see implementing class's
     * {@link #doInitialize} description for more details.
     */
    value: function initialize(room, rtc, options) {
      if (this.state !== null) {
        var errmsg = "attempt to initiate on session ".concat(this.sid, "\n                   in state ").concat(this.state);
        logger.error(errmsg);
        throw new Error(errmsg);
      }

      this.room = room;
      this.rtc = rtc;
      this.state = JingleSessionState.PENDING;
      this.doInitialize(options);
    }
    /**
     * The implementing class finishes initialization here. Called at the end of
     * {@link initialize}.
     * @param {Object} options - The options specific to the implementing class.
     * @protected
     */

  }, {
    key: "doInitialize",
    value: function doInitialize(options) {} // eslint-disable-line no-unused-vars, no-empty-function, max-len

    /* eslint-disable no-unused-vars, no-empty-function */

    /**
     * Adds the ICE candidates found in the 'contents' array as remote
     * candidates?
     * Note: currently only used on transport-info
     *
     * @param contents
     */

  }, {
    key: "addIceCandidates",
    value: function addIceCandidates(contents) {}
    /* eslint-enable no-unused-vars, no-empty-function */

    /**
     * Returns current state of this <tt>JingleSession</tt> instance.
     * @returns {JingleSessionState} the current state of this session instance.
     */

  }, {
    key: "getState",
    value: function getState() {
      return this.state;
    }
    /* eslint-disable no-unused-vars, no-empty-function */

    /**
     * Handles an 'add-source' event.
     *
     * @param contents an array of Jingle 'content' elements.
     */

  }, {
    key: "addSources",
    value: function addSources(contents) {}
    /**
     * Handles a 'remove-source' event.
     *
     * @param contents an array of Jingle 'content' elements.
     */

  }, {
    key: "removeSources",
    value: function removeSources(contents) {}
    /**
     * Terminates this Jingle session by sending session-terminate
     * @param success a callback called once the 'session-terminate' packet has
     * been acknowledged with RESULT.
     * @param failure a callback called when either timeout occurs or ERROR
     * response is received.
     * @param {Object} options
     * @param {string} [options.reason] XMPP Jingle error condition
     * @param {string} [options.reasonDescription] some meaningful error message
     * @param {boolean} [options.sendSessionTerminate=true] set to false to skip
     * sending session-terminate. It may not make sense to send it if the XMPP
     * connection has been closed already or if the remote peer has disconnected
     */

  }, {
    key: "terminate",
    value: function terminate(success, failure, options) {}
    /**
     * Handles an offer from the remote peer (prepares to accept a session).
     * @param jingle the 'jingle' XML element.
     * @param success callback called when we the incoming session has been
     * accepted
     * @param failure callback called when we fail for any reason, will supply
     * error object with details(which is meant more to be printed to the logger
     * than analysed in the code, as the error is unrecoverable anyway)
     */

  }, {
    key: "acceptOffer",
    value: function acceptOffer(jingle, success, failure) {}
    /**
     * Returns the JID of the initiator of the jingle session.
     */

  }, {
    key: "_getInitiatorJid",
    value: function _getInitiatorJid() {
      return this.isInitiator ? this.localJid : this.remoteJid;
    }
    /* eslint-enable no-unused-vars, no-empty-function */

  }, {
    key: "initiatorJid",
    get: function get() {
      return this.isInitiator ? this.localJid : this.remoteJid;
    }
    /**
     * Returns XMPP address of this session's responder.
     * @return {string}
     */

  }, {
    key: "responderJid",
    get: function get() {
      return this.isInitiator ? this.remoteJid : this.localJid;
    }
  }]);

  return JingleSession;
}();

exports["default"] = JingleSession;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _AnalyticsEvents = require("../../service/statistics/AnalyticsEvents");

var _async = _interopRequireDefault(require("async"));

var _jitsiMeetLogger = require("jitsi-meet-logger");

var _strophe = require("strophe.js");

var _StringUtils = require("../util/StringUtils");

var _JingleSession2 = _interopRequireDefault(require("./JingleSession"));

var JingleSessionState = _interopRequireWildcard(require("./JingleSessionState"));

var _SDP = _interopRequireDefault(require("./SDP"));

var _SDPDiffer = _interopRequireDefault(require("./SDPDiffer"));

var _SDPUtil = _interopRequireDefault(require("./SDPUtil"));

var _SignalingLayerImpl = _interopRequireDefault(require("./SignalingLayerImpl"));

var _RTCEvents = _interopRequireDefault(require("../../service/RTC/RTCEvents"));

var _statistics = _interopRequireDefault(require("../statistics/statistics"));

var _XMPPEvents = _interopRequireDefault(require("../../service/xmpp/XMPPEvents"));

var _GlobalOnErrorHandler = _interopRequireDefault(require("../util/GlobalOnErrorHandler"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var logger = (0, _jitsiMeetLogger.getLogger)(__filename);
/**
 * Constant tells how long we're going to wait for IQ response, before timeout
 * error is  triggered.
 * @type {number}
 */

var IQ_TIMEOUT = 10000;
/*
 * The default number of samples (per stat) to keep when webrtc stats gathering
 * is enabled in TraceablePeerConnection.
 */

var DEFAULT_MAX_STATS = 300;
/**
 * @typedef {Object} JingleSessionPCOptions
 * @property {Object} abTesting - A/B testing related options (ask George).
 * @property {boolean} abTesting.enableSuspendVideoTest - enables the suspend
 * video test ?(ask George).
 * @property {boolean} disableH264 - Described in the config.js[1].
 * @property {boolean} disableRtx - Described in the config.js[1].
 * @property {boolean} disableSimulcast - Described in the config.js[1].
 * @property {boolean} enableLayerSuspension - Described in the config.js[1].
 * @property {boolean} failICE - it's an option used in the tests. Set to
 * <tt>true</tt> to block any real candidates and make the ICE fail.
 * @property {boolean} gatherStats - Described in the config.js[1].
 * @property {object} p2p - Peer to peer related options (FIXME those could be
 * fetched from config.p2p on the upper level).
 * @property {boolean} p2p.disableH264 - Described in the config.js[1].
 * @property {boolean} p2p.preferH264 - Described in the config.js[1].
 * @property {boolean} preferH264 - Described in the config.js[1].
 * @property {Object} testing - Testing and/or experimental options.
 * @property {boolean} testing.enableFirefoxSimulcast - Described in the
 * config.js[1].
 * @property {boolean} webrtcIceUdpDisable - Described in the config.js[1].
 * @property {boolean} webrtcIceTcpDisable - Described in the config.js[1].
 *
 * [1]: https://github.com/jitsi/jitsi-meet/blob/master/config.js
 */

/**
 *
 */

var JingleSessionPC =
/*#__PURE__*/
function (_JingleSession) {
  _inherits(JingleSessionPC, _JingleSession);

  _createClass(JingleSessionPC, null, [{
    key: "parseVideoSenders",

    /**
     * Parses 'senders' attribute of the video content.
     * @param {jQuery} jingleContents
     * @return {string|null} one of the values of content "senders" attribute
     * defined by Jingle. If there is no "senders" attribute or if the value is
     * invalid then <tt>null</tt> will be returned.
     * @private
     */
    value: function parseVideoSenders(jingleContents) {
      var videoContents = jingleContents.find('>content[name="video"]');

      if (videoContents.length) {
        var senders = videoContents[0].getAttribute('senders');

        if (senders === 'both' || senders === 'initiator' || senders === 'responder' || senders === 'none') {
          return senders;
        }
      }

      return null;
    }
    /* eslint-disable max-params */

    /**
     * Creates new <tt>JingleSessionPC</tt>
     * @param {string} sid the Jingle Session ID - random string which
     * identifies the session
     * @param {string} localJid our JID
     * @param {string} remoteJid remote peer JID
     * @param {Strophe.Connection} connection Strophe XMPP connection instance
     * used to send packets.
     * @param mediaConstraints the media constraints object passed to
     * createOffer/Answer, as defined by the WebRTC standard
     * @param iceConfig the ICE servers config object as defined by the WebRTC
     * standard.
     * @param {boolean} isP2P indicates whether this instance is
     * meant to be used in a direct, peer to peer connection or <tt>false</tt>
     * if it's a JVB connection.
     * @param {boolean} isInitiator indicates if it will be the side which
     * initiates the session.
     * @constructor
     *
     * @implements {SignalingLayer}
     */

  }]);

  function JingleSessionPC(sid, localJid, remoteJid, connection, mediaConstraints, iceConfig, isP2P, isInitiator) {
    var _this;

    _classCallCheck(this, JingleSessionPC);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(JingleSessionPC).call(this, sid, localJid, remoteJid, connection, mediaConstraints, iceConfig, isInitiator));
    /**
     * The bridge session's identifier. One Jingle session can during
     * it's lifetime participate in multiple bridge sessions managed by
     * Jicofo. A new bridge session is started whenever Jicofo sends
     * 'session-initiate' or 'transport-replace'.
     *
     * @type {?string}
     * @private
     */

    _this._bridgeSessionId = null;
    /**
     * Stores result of {@link window.performance.now()} at the time when
     * ICE enters 'checking' state.
     * @type {number|null} null if no value has been stored yet
     * @private
     */

    _this._iceCheckingStartedTimestamp = null;
    /**
     * Stores result of {@link window.performance.now()} at the time when
     * first ICE candidate is spawned by the peerconnection to mark when
     * ICE gathering started. That's, because ICE gathering state changed
     * events are not supported by most of the browsers, so we try something
     * that will work everywhere. It may not be as accurate, but given that
     * 'host' candidate usually comes first, the delay should be minimal.
     * @type {number|null} null if no value has been stored yet
     * @private
     */

    _this._gatheringStartedTimestamp = null;
    /**
     * Indicates whether or not this session is willing to send/receive
     * video media. When set to <tt>false</tt> the underlying peer
     * connection will disable local video transfer and the remote peer will
     * be will be asked to stop sending video via 'content-modify' IQ
     * (the senders attribute of video contents will be adjusted
     * accordingly). Note that this notification is sent only in P2P
     * session, because Jicofo does not support it yet. Obviously when
     * the value is changed from <tt>false</tt> to <tt>true</tt> another
     * notification will be sent to resume video transfer on the remote
     * side.
     * @type {boolean}
     * @private
     */

    _this._localVideoActive = true;
    /**
     * Indicates whether or not the remote peer has video transfer active.
     * When set to <tt>true</tt> it means that remote peer is neither
     * sending nor willing to receive video. In such case we'll ask
     * our peerconnection to stop sending video by calling
     * {@link TraceablePeerConnection.setVideoTransferActive} with
     * <tt>false</tt>.
     * @type {boolean}
     * @private
     */

    _this._remoteVideoActive = true;
    /**
     * Marks that ICE gathering duration has been reported already. That
     * prevents reporting it again, after eventual 'transport-replace' (JVB
     * conference migration/ICE restart).
     * @type {boolean}
     * @private
     */

    _this._gatheringReported = false;
    _this.lasticecandidate = false;
    _this.closed = false;
    /**
     * Indicates whether or not this <tt>JingleSessionPC</tt> is used in
     * a peer to peer type of session.
     * @type {boolean} <tt>true</tt> if it's a peer to peer
     * session or <tt>false</tt> if it's a JVB session
     */

    _this.isP2P = isP2P;
    /**
     * The signaling layer implementation.
     * @type {SignalingLayerImpl}
     */

    _this.signalingLayer = new _SignalingLayerImpl["default"]();
    _this.modificationQueue = _async["default"].queue(_this._processQueueTasks.bind(_assertThisInitialized(_this)), 1);
    /**
     * Flag used to guarantee that the connection established event is
     * triggered just once.
     * @type {boolean}
     */

    _this.wasConnected = false;
    /**
     * Keeps track of how long (in ms) it took from ICE start to ICE
     * connect.
     *
     * @type {number}
     */

    _this.establishmentDuration = undefined;
    return _this;
  }
  /* eslint-enable max-params */

  /**
   * Checks whether or not this session instance has been ended and eventually
   * logs a message which mentions that given <tt>actionName</tt> was
   * cancelled.
   * @param {string} actionName
   * @return {boolean} <tt>true</tt> if this {@link JingleSessionPC} has
   * entered {@link JingleSessionState.ENDED} or <tt>false</tt> otherwise.
   * @private
   */


  _createClass(JingleSessionPC, [{
    key: "_assertNotEnded",
    value: function _assertNotEnded(actionName) {
      if (this.state === JingleSessionState.ENDED) {
        logger.log("The session has ended - cancelling action: ".concat(actionName));
        return false;
      }

      return true;
    }
    /**
     * @inheritDoc
     * @param {JingleSessionPCOptions} options  - a set of config options.
     */

  }, {
    key: "doInitialize",
    value: function doInitialize(options) {
      var _this2 = this;

      this.failICE = Boolean(options.failICE);
      this.lasticecandidate = false;
      this.options = options;
      /**
       * {@code true} if reconnect is in progress.
       * @type {boolean}
       */

      this.isReconnect = false;
      /**
       * Set to {@code true} if the connection was ever stable
       * @type {boolean}
       */

      this.wasstable = false;
      this.webrtcIceUdpDisable = Boolean(options.webrtcIceUdpDisable);
      this.webrtcIceTcpDisable = Boolean(options.webrtcIceTcpDisable);
      var pcOptions = {
        disableRtx: options.disableRtx
      };

      if (options.gatherStats) {
        pcOptions.maxstats = DEFAULT_MAX_STATS;
      }

      if (this.isP2P) {
        // simulcast needs to be disabled for P2P (121) calls
        pcOptions.disableSimulcast = true;
        pcOptions.disableH264 = options.p2p && options.p2p.disableH264;
        pcOptions.preferH264 = options.p2p && options.p2p.preferH264;

        var abtestSuspendVideo = this._abtestSuspendVideoEnabled(options);

        if (typeof abtestSuspendVideo !== 'undefined') {
          pcOptions.abtestSuspendVideo = abtestSuspendVideo;
        }
      } else {
        // H264 does not support simulcast, so it needs to be disabled.
        pcOptions.disableSimulcast = options.disableSimulcast || options.preferH264 && !options.disableH264;
        pcOptions.preferH264 = options.preferH264;
        pcOptions.enableFirefoxSimulcast = options.testing && options.testing.enableFirefoxSimulcast;
        pcOptions.enableLayerSuspension = options.enableLayerSuspension;
      }

      this.peerconnection = this.rtc.createPeerConnection(this.signalingLayer, this.iceConfig, this.isP2P, pcOptions);

      this.peerconnection.onicecandidate = function (ev) {
        if (!ev) {
          // There was an incomplete check for ev before which left
          // the last line of the function unprotected from a potential
          // throw of an exception. Consequently, it may be argued that
          // the check is unnecessary. Anyway, I'm leaving it and making
          // the check complete.
          return;
        } // XXX this is broken, candidate is not parsed.


        var candidate = ev.candidate;
        var now = window.performance.now();

        if (candidate) {
          if (_this2._gatheringStartedTimestamp === null) {
            _this2._gatheringStartedTimestamp = now;
          } // Discard candidates of disabled protocols.


          var protocol = candidate.protocol;

          if (typeof protocol === 'string') {
            protocol = protocol.toLowerCase();

            if (protocol === 'tcp' || protocol === 'ssltcp') {
              if (_this2.webrtcIceTcpDisable) {
                return;
              }
            } else if (protocol === 'udp') {
              if (_this2.webrtcIceUdpDisable) {
                return;
              }
            }
          }
        } else if (!_this2._gatheringReported) {
          // End of gathering
          _statistics["default"].sendAnalytics(_AnalyticsEvents.ICE_DURATION, {
            phase: 'gathering',
            value: now - _this2._gatheringStartedTimestamp,
            p2p: _this2.isP2P,
            initiator: _this2.isInitiator
          });

          _this2._gatheringReported = true;
        }

        _this2.sendIceCandidate(candidate);
      }; // Note there is a change in the spec about closed:
      // This value moved into the RTCPeerConnectionState enum in
      // the May 13, 2016 draft of the specification, as it reflects the state
      // of the RTCPeerConnection, not the signaling connection. You now
      // detect a closed connection by checking for connectionState to be
      // "closed" instead.
      // I suppose at some point this will be moved to onconnectionstatechange


      this.peerconnection.onsignalingstatechange = function () {
        if (!_this2.peerconnection) {
          return;
        }

        if (_this2.peerconnection.signalingState === 'stable') {
          _this2.wasstable = true;
        } else if ((_this2.peerconnection.signalingState === 'closed' || _this2.peerconnection.connectionState === 'closed') && !_this2.closed) {
          _this2.room.eventEmitter.emit(_XMPPEvents["default"].SUSPEND_DETECTED, _this2);
        }
      };
      /**
       * The oniceconnectionstatechange event handler contains the code to
       * execute when the iceconnectionstatechange event, of type Event,
       * is received by this RTCPeerConnection. Such an event is sent when
       * the value of RTCPeerConnection.iceConnectionState changes.
       */


      this.peerconnection.oniceconnectionstatechange = function () {
        if (!_this2.peerconnection || !_this2._assertNotEnded('oniceconnectionstatechange')) {
          return;
        }

        var now = window.performance.now();

        if (!_this2.isP2P) {
          _this2.room.connectionTimes["ice.state.".concat(_this2.peerconnection.iceConnectionState)] = now;
        }

        logger.log("(TIME) ICE ".concat(_this2.peerconnection.iceConnectionState) + " P2P? ".concat(_this2.isP2P, ":\t"), now);

        _statistics["default"].sendAnalytics(_AnalyticsEvents.ICE_STATE_CHANGED, {
          p2p: _this2.isP2P,
          state: _this2.peerconnection.iceConnectionState,
          'signaling_state': _this2.peerconnection.signalingState,
          reconnect: _this2.isReconnect,
          value: now
        });

        _this2.room.eventEmitter.emit(_XMPPEvents["default"].ICE_CONNECTION_STATE_CHANGED, _this2, _this2.peerconnection.iceConnectionState);

        switch (_this2.peerconnection.iceConnectionState) {
          case 'checking':
            _this2._iceCheckingStartedTimestamp = now;
            break;

          case 'connected':
            // Informs interested parties that the connection has been
            // restored.
            if (_this2.peerconnection.signalingState === 'stable') {
              if (_this2.isReconnect) {
                _this2.room.eventEmitter.emit(_XMPPEvents["default"].CONNECTION_RESTORED, _this2);
              }
            }

            if (!_this2.wasConnected && _this2.wasstable) {
              _statistics["default"].sendAnalytics(_AnalyticsEvents.ICE_DURATION, {
                phase: 'checking',
                value: now - _this2._iceCheckingStartedTimestamp,
                p2p: _this2.isP2P,
                initiator: _this2.isInitiator
              }); // Switch between ICE gathering and ICE checking whichever
              // started first (scenarios are different for initiator
              // vs responder)


              var iceStarted = Math.min(_this2._iceCheckingStartedTimestamp, _this2._gatheringStartedTimestamp);
              _this2.establishmentDuration = now - iceStarted;

              _statistics["default"].sendAnalytics(_AnalyticsEvents.ICE_DURATION, {
                phase: 'establishment',
                value: _this2.establishmentDuration,
                p2p: _this2.isP2P,
                initiator: _this2.isInitiator
              });

              _this2.wasConnected = true;

              _this2.room.eventEmitter.emit(_XMPPEvents["default"].CONNECTION_ESTABLISHED, _this2);
            }

            _this2.isReconnect = false;
            break;

          case 'disconnected':
            if (_this2.closed) {
              break;
            }

            _this2.isReconnect = true; // Informs interested parties that the connection has been
            // interrupted.

            if (_this2.wasstable) {
              _this2.room.eventEmitter.emit(_XMPPEvents["default"].CONNECTION_INTERRUPTED, _this2);
            }

            break;

          case 'failed':
            _this2.room.eventEmitter.emit(_XMPPEvents["default"].CONNECTION_ICE_FAILED, _this2);

            break;
        }
      };

      this.peerconnection.onnegotiationneeded = function () {
        _this2.room.eventEmitter.emit(_XMPPEvents["default"].PEERCONNECTION_READY, _this2);
      }; // The signaling layer will bind it's listeners at this point


      this.signalingLayer.setChatRoom(this.room);

      if (!this.isP2P && options.enableLayerSuspension) {
        // If this is the bridge session, we'll listen for
        // IS_SELECTED_CHANGED events and notify the peer connection
        this.rtc.addListener(_RTCEvents["default"].IS_SELECTED_CHANGED, function (isSelected) {
          _this2.peerconnection.setIsSelected(isSelected);

          logger.info('Doing local O/A due to ' + 'IS_SELECTED_CHANGED event');

          _this2.modificationQueue.push(function (finishedCallback) {
            _this2._renegotiate().then(finishedCallback)["catch"](finishedCallback);
          });
        });
      }
    }
    /**
     * Sends given candidate in Jingle 'transport-info' message.
     * @param {RTCIceCandidate} candidate the WebRTC ICE candidate instance
     * @private
     */

  }, {
    key: "sendIceCandidate",
    value: function sendIceCandidate(candidate) {
      var _this3 = this;

      var localSDP = new _SDP["default"](this.peerconnection.localDescription.sdp);

      if (candidate && !this.lasticecandidate) {
        var ice = _SDPUtil["default"].iceparams(localSDP.media[candidate.sdpMLineIndex], localSDP.session);

        var jcand = _SDPUtil["default"].candidateToJingle(candidate.candidate);

        if (!(ice && jcand)) {
          var errorMesssage = 'failed to get ice && jcand';

          _GlobalOnErrorHandler["default"].callErrorHandler(new Error(errorMesssage));

          logger.error(errorMesssage);
          return;
        }

        ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';

        if (this.usedrip) {
          if (this.dripContainer.length === 0) {
            // start 20ms callout
            setTimeout(function () {
              if (_this3.dripContainer.length === 0) {
                return;
              }

              _this3.sendIceCandidates(_this3.dripContainer);

              _this3.dripContainer = [];
            }, 20);
          }

          this.dripContainer.push(candidate);
        } else {
          this.sendIceCandidates([candidate]);
        }
      } else {
        logger.log('sendIceCandidate: last candidate.'); // FIXME: remember to re-think in ICE-restart

        this.lasticecandidate = true;
      }
    }
    /**
     * Sends given candidates in Jingle 'transport-info' message.
     * @param {Array<RTCIceCandidate>} candidates an array of the WebRTC ICE
     * candidate instances
     * @private
     */

  }, {
    key: "sendIceCandidates",
    value: function sendIceCandidates(candidates) {
      var _this4 = this;

      if (!this._assertNotEnded('sendIceCandidates')) {
        return;
      }

      logger.log('sendIceCandidates', candidates);
      var cand = (0, _strophe.$iq)({
        to: this.remoteJid,
        type: 'set'
      }).c('jingle', {
        xmlns: 'urn:xmpp:jingle:1',
        action: 'transport-info',
        initiator: this.initiatorJid,
        sid: this.sid
      });
      var localSDP = new _SDP["default"](this.peerconnection.localDescription.sdp);

      var _loop = function _loop(mid) {
        var cands = candidates.filter(function (el) {
          return el.sdpMLineIndex === mid;
        });

        var mline = _SDPUtil["default"].parseMLine(localSDP.media[mid].split('\r\n')[0]);

        if (cands.length > 0) {
          var ice = _SDPUtil["default"].iceparams(localSDP.media[mid], localSDP.session);

          ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';
          cand.c('content', {
            creator: _this4.initiatorJid === _this4.localJid ? 'initiator' : 'responder',
            name: cands[0].sdpMid ? cands[0].sdpMid : mline.media
          }).c('transport', ice);

          for (var i = 0; i < cands.length; i++) {
            var candidate = _SDPUtil["default"].candidateToJingle(cands[i].candidate); // Mangle ICE candidate if 'failICE' test option is enabled


            if (_this4.failICE) {
              candidate.ip = '1.1.1.1';
            }

            cand.c('candidate', candidate).up();
          } // add fingerprint


          var fingerprintLine = _SDPUtil["default"].findLine(localSDP.media[mid], 'a=fingerprint:', localSDP.session);

          if (fingerprintLine) {
            var tmp = _SDPUtil["default"].parseFingerprint(fingerprintLine);

            tmp.required = true;
            cand.c('fingerprint', {
              xmlns: 'urn:xmpp:jingle:apps:dtls:0'
            }).t(tmp.fingerprint);
            delete tmp.fingerprint;
            cand.attrs(tmp);
            cand.up();
          }

          cand.up(); // transport

          cand.up(); // content
        }
      };

      for (var mid = 0; mid < localSDP.media.length; mid++) {
        _loop(mid);
      } // might merge last-candidate notification into this, but it is called
      // a lot later. See webrtc issue #2340
      // logger.log('was this the last candidate', this.lasticecandidate);


      this.connection.sendIQ(cand, null, this.newJingleErrorHandler(cand), IQ_TIMEOUT);
    }
    /**
     * Sends Jingle 'session-info' message which includes custom Jitsi Meet
     * 'ice-state' element with the text value 'failed' to let Jicofo know
     * that the ICE connection has entered the failed state. It can then
     * choose to re-create JVB channels and send 'transport-replace' to
     * retry the connection.
     */

  }, {
    key: "sendIceFailedNotification",
    value: function sendIceFailedNotification() {
      var sessionInfo = (0, _strophe.$iq)({
        to: this.remoteJid,
        type: 'set'
      }).c('jingle', {
        xmlns: 'urn:xmpp:jingle:1',
        action: 'session-info',
        initiator: this.initiatorJid,
        sid: this.sid
      }).c('ice-state', {
        xmlns: 'http://jitsi.org/protocol/focus'
      }).t('failed').up();
      this._bridgeSessionId && sessionInfo.c('bridge-session', {
        xmlns: 'http://jitsi.org/protocol/focus',
        id: this._bridgeSessionId
      });
      this.connection.sendIQ(sessionInfo, null, this.newJingleErrorHandler(sessionInfo),
      /*
       * This message will be often sent when there are connectivity
       * issues, so make it slightly longer than Prosody's default BOSH
       * inactivity timeout of 60 seconds.
       */
      65);
    }
    /**
     * {@inheritDoc}
     */

  }, {
    key: "addIceCandidates",
    value: function addIceCandidates(elem) {
      var _this5 = this;

      if (this.peerconnection.signalingState === 'closed') {
        logger.warn('Ignored add ICE candidate when in closed state');
        return;
      }

      var iceCandidates = [];
      elem.find('>content>transport>candidate').each(function (idx, candidate) {
        var line = _SDPUtil["default"].candidateFromJingle(candidate);

        line = line.replace('\r\n', '').replace('a=', ''); // FIXME this code does not care to handle
        // non-bundle transport

        var rtcCandidate = new RTCIceCandidate({
          sdpMLineIndex: 0,
          // FF comes up with more complex names like audio-23423,
          // Given that it works on both Chrome and FF without
          // providing it, let's leave it like this for the time
          // being...
          // sdpMid: 'audio',
          sdpMid: '',
          candidate: line
        });
        iceCandidates.push(rtcCandidate);
      });

      if (!iceCandidates.length) {
        logger.error('No ICE candidates to add ?', elem[0] && elem[0].outerHTML);
        return;
      } // We want to have this task queued, so that we know it is executed,
      // after the initial sRD/sLD offer/answer cycle was done (based on
      // the assumption that candidates are spawned after the offer/answer
      // and XMPP preserves order).


      var workFunction = function workFunction(finishedCallback) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = iceCandidates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var iceCandidate = _step.value;

            _this5.peerconnection.addIceCandidate(iceCandidate).then(function () {
              return logger.debug('addIceCandidate ok!');
            }, function (err) {
              return logger.error('addIceCandidate failed!', err);
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        finishedCallback();
      };

      logger.debug("Queued add (".concat(iceCandidates.length, ") ICE candidates task..."));
      this.modificationQueue.push(workFunction);
    }
    /**
     *
     * @param contents
     */

  }, {
    key: "readSsrcInfo",
    value: function readSsrcInfo(contents) {
      var _this6 = this;

      var ssrcs = $(contents).find('>description>' + 'source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]');
      ssrcs.each(function (i, ssrcElement) {
        var ssrc = Number(ssrcElement.getAttribute('ssrc'));

        if (_this6.isP2P) {
          // In P2P all SSRCs are owner by the remote peer
          _this6.signalingLayer.setSSRCOwner(ssrc, _strophe.Strophe.getResourceFromJid(_this6.remoteJid));
        } else {
          $(ssrcElement).find('>ssrc-info[xmlns="http://jitsi.org/jitmeet"]').each(function (i3, ssrcInfoElement) {
            var owner = ssrcInfoElement.getAttribute('owner');

            if (owner && owner.length) {
              if (isNaN(ssrc) || ssrc < 0) {
                logger.warn("Invalid SSRC ".concat(ssrc, " value received") + " for ".concat(owner));
              } else {
                _this6.signalingLayer.setSSRCOwner(ssrc, _strophe.Strophe.getResourceFromJid(owner));
              }
            }
          });
        }
      });
    }
    /**
     * Makes the underlying TraceablePeerConnection generate new SSRC for
     * the recvonly video stream.
     * @deprecated
     */

  }, {
    key: "generateRecvonlySsrc",
    value: function generateRecvonlySsrc() {
      if (this.peerconnection) {
        this.peerconnection.generateRecvonlySsrc();
      } else {
        logger.error('Unable to generate recvonly SSRC - no peerconnection');
      }
    }
    /* eslint-disable max-params */

    /**
     * Accepts incoming Jingle 'session-initiate' and should send
     * 'session-accept' in result.
     * @param jingleOffer jQuery selector pointing to the jingle element of
     * the offer IQ
     * @param success callback called when we accept incoming session
     * successfully and receive RESULT packet to 'session-accept' sent.
     * @param failure function(error) called if for any reason we fail to accept
     * the incoming offer. 'error' argument can be used to log some details
     * about the error.
     * @param {Array<JitsiLocalTrack>} [localTracks] the optional list of
     * the local tracks that will be added, before the offer/answer cycle
     * executes. We allow the localTracks to optionally be passed in so that
     * the addition of the local tracks and the processing of the initial offer
     * can all be done atomically. We want to make sure that any other
     * operations which originate in the XMPP Jingle messages related with
     * this session to be executed with an assumption that the initial
     * offer/answer cycle has been executed already.
     */

  }, {
    key: "acceptOffer",
    value: function acceptOffer(jingleOffer, success, failure, localTracks) {
      var _this7 = this;

      this.setOfferAnswerCycle(jingleOffer, function () {
        // FIXME we may not care about RESULT packet for session-accept
        // then we should either call 'success' here immediately or
        // modify sendSessionAccept method to do that
        _this7.sendSessionAccept(success, failure);
      }, failure, localTracks);
    }
    /* eslint-enable max-params */

    /**
     * Creates an offer and sends Jingle 'session-initiate' to the remote peer.
     * @param {Array<JitsiLocalTrack>} localTracks the local tracks that will be
     * added, before the offer/answer cycle executes (for the local track
     * addition to be an atomic operation together with the offer/answer).
     */

  }, {
    key: "invite",
    value: function invite(localTracks) {
      var _this8 = this;

      if (!this.isInitiator) {
        throw new Error('Trying to invite from the responder session');
      }

      var workFunction = function workFunction(finishedCallback) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = localTracks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var localTrack = _step2.value;

            _this8.peerconnection.addTrack(localTrack);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        _this8.peerconnection.createOffer(_this8.mediaConstraints).then(function (offerSdp) {
          _this8.peerconnection.setLocalDescription(offerSdp).then(function () {
            // NOTE that the offer is obtained from
            // the localDescription getter as it needs to go
            // though the transformation chain.
            _this8.sendSessionInitiate(_this8.peerconnection.localDescription.sdp);

            finishedCallback();
          }, function (error) {
            logger.error('Failed to set local SDP', error, offerSdp);
            finishedCallback(error);
          });
        }, function (error) {
          logger.error('Failed to create an offer', error, _this8.mediaConstraints);
          finishedCallback(error);
        });
      };

      this.modificationQueue.push(workFunction, function (error) {
        if (error) {
          logger.error('invite error', error);
        } else {
          logger.debug('invite executed - OK');
        }
      });
    }
    /**
     * Sends 'session-initiate' to the remote peer.
     *
     * NOTE this method is synchronous and we're not waiting for the RESULT
     * response which would delay the startup process.
     *
     * @param {string} offerSdp  - The local session description which will be
     * used to generate an offer.
     * @private
     */

  }, {
    key: "sendSessionInitiate",
    value: function sendSessionInitiate(offerSdp) {
      var init = (0, _strophe.$iq)({
        to: this.remoteJid,
        type: 'set'
      }).c('jingle', {
        xmlns: 'urn:xmpp:jingle:1',
        action: 'session-initiate',
        initiator: this.initiatorJid,
        sid: this.sid
      });
      new _SDP["default"](offerSdp).toJingle(init, this.isInitiator ? 'initiator' : 'responder');
      init = init.tree();
      logger.info('Session-initiate: ', init);
      this.connection.sendIQ(init, function () {
        logger.info('Got RESULT for "session-initiate"');
      }, function (error) {
        logger.error('"session-initiate" error', error);
      }, IQ_TIMEOUT);
    }
    /**
     * Sets the answer received from the remote peer.
     * @param jingleAnswer
     */

  }, {
    key: "setAnswer",
    value: function setAnswer(jingleAnswer) {
      if (!this.isInitiator) {
        throw new Error('Trying to set an answer on the responder session');
      }

      this.setOfferAnswerCycle(jingleAnswer, function () {
        logger.info('setAnswer - succeeded');
      }, function (error) {
        logger.error('setAnswer failed: ', error);
      });
    }
    /* eslint-disable max-params */

    /**
     * This is a setRemoteDescription/setLocalDescription cycle which starts at
     * converting Strophe Jingle IQ into remote offer SDP. Once converted
     * setRemoteDescription, createAnswer and setLocalDescription calls follow.
     * @param jingleOfferAnswerIq jQuery selector pointing to the jingle element
     *        of the offer (or answer) IQ
     * @param success callback called when sRD/sLD cycle finishes successfully.
     * @param failure callback called with an error object as an argument if we
     *        fail at any point during setRD, createAnswer, setLD.
     * @param {Array<JitsiLocalTrack>} [localTracks] the optional list of
     * the local tracks that will be added, before the offer/answer cycle
     * executes (for the local track addition to be an atomic operation together
     * with the offer/answer).
     */

  }, {
    key: "setOfferAnswerCycle",
    value: function setOfferAnswerCycle(jingleOfferAnswerIq, success, failure, localTracks) {
      var _this9 = this;

      var workFunction = function workFunction(finishedCallback) {
        if (localTracks) {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = localTracks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var track = _step3.value;

              _this9.peerconnection.addTrack(track);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }

        var newRemoteSdp = _this9._processNewJingleOfferIq(jingleOfferAnswerIq);

        var oldLocalSdp = _this9.peerconnection.localDescription.sdp;
        var bridgeSession = $(jingleOfferAnswerIq).find('>bridge-session[' + 'xmlns="http://jitsi.org/protocol/focus"]');
        var bridgeSessionId = bridgeSession.attr('id');

        if (bridgeSessionId !== _this9._bridgeSessionId) {
          _this9._bridgeSessionId = bridgeSessionId;
        }

        _this9._renegotiate(newRemoteSdp.raw).then(function () {
          if (_this9.state === JingleSessionState.PENDING) {
            _this9.state = JingleSessionState.ACTIVE; // Sync up video transfer active/inactive only after
            // the initial O/A cycle. We want to adjust the video
            // media direction only in the local SDP and the Jingle
            // contents direction included in the initial
            // offer/answer is mapped to the remote SDP. Jingle
            // 'content-modify' IQ is processed in a way that it
            // will only modify local SDP when remote peer is no
            // longer interested in receiving video content.
            // Changing media direction in the remote SDP will mess
            // up our SDP translation chain (simulcast, video mute,
            // RTX etc.)

            if (_this9.isP2P && !_this9._localVideoActive) {
              _this9.sendContentModify(_this9._localVideoActive);
            }
          } // Old local SDP will be available when we're setting answer
          // for the first time, but not when offer and it's fine
          // since we're generating an answer now it will contain all
          // our SSRCs


          if (oldLocalSdp) {
            var newLocalSdp = new _SDP["default"](_this9.peerconnection.localDescription.sdp);

            _this9.notifyMySSRCUpdate(new _SDP["default"](oldLocalSdp), newLocalSdp);
          }

          finishedCallback();
        }, function (error) {
          logger.error("Error renegotiating after setting new remote ".concat(_this9.isInitiator ? 'answer: ' : 'offer: ').concat(error), newRemoteSdp);

          _this9._onJingleFatalError(error);

          finishedCallback(error);
        });
      };

      this.modificationQueue.push(workFunction, function (error) {
        error ? failure(error) : success();
      });
    }
    /* eslint-enable max-params */

    /**
     * Although it states "replace transport" it does accept full Jingle offer
     * which should contain new ICE transport details.
     * @param jingleOfferElem an element Jingle IQ that contains new offer and
     *        transport info.
     * @param success callback called when we succeed to accept new offer.
     * @param failure function(error) called when we fail to accept new offer.
     */

  }, {
    key: "replaceTransport",
    value: function replaceTransport(jingleOfferElem, success, failure) {
      var _this10 = this;

      this.room.eventEmitter.emit(_XMPPEvents["default"].ICE_RESTARTING, this); // We need to first reject the 'data' section to have the SCTP stack
      // cleaned up to signal the known data channel is now invalid. After
      // that the original offer is set to have the SCTP connection
      // established with the new bridge.

      var originalOffer = jingleOfferElem.clone();
      jingleOfferElem.find('>content[name=\'data\']').attr('senders', 'rejected'); // Remove all remote sources in order to reset the client's state
      // for the remote MediaStreams. When a conference is moved to
      // another bridge it will start streaming with a sequence number
      // that is not in sync with the most recently seen by the client.
      // The symptoms include frozen or black video and lots of "failed to
      // unprotect SRTP packets" in Chrome logs.

      jingleOfferElem.find('>content>description>source').remove();
      jingleOfferElem.find('>content>description>ssrc-group').remove(); // First set an offer with a rejected 'data' section

      this.setOfferAnswerCycle(jingleOfferElem, function () {
        // Now set the original offer(with the 'data' section)
        _this10.setOfferAnswerCycle(originalOffer, function () {
          var localSDP = new _SDP["default"](_this10.peerconnection.localDescription.sdp);

          _this10.sendTransportAccept(localSDP, success, failure);

          _this10.room.eventEmitter.emit(_XMPPEvents["default"].ICE_RESTART_SUCCESS, _this10, originalOffer);
        }, failure);
      }, failure);
    }
    /**
     * Sends Jingle 'session-accept' message.
     * @param {function()} success callback called when we receive 'RESULT'
     *        packet for the 'session-accept'
     * @param {function(error)} failure called when we receive an error response
     *        or when the request has timed out.
     * @private
     */

  }, {
    key: "sendSessionAccept",
    value: function sendSessionAccept(success, failure) {
      var _this11 = this;

      // NOTE: since we're just reading from it, we don't need to be within
      //  the modification queue to access the local description
      var localSDP = new _SDP["default"](this.peerconnection.localDescription.sdp);
      var accept = (0, _strophe.$iq)({
        to: this.remoteJid,
        type: 'set'
      }).c('jingle', {
        xmlns: 'urn:xmpp:jingle:1',
        action: 'session-accept',
        initiator: this.initiatorJid,
        responder: this.responderJid,
        sid: this.sid
      });

      if (this.webrtcIceTcpDisable) {
        localSDP.removeTcpCandidates = true;
      }

      if (this.webrtcIceUdpDisable) {
        localSDP.removeUdpCandidates = true;
      }

      if (this.failICE) {
        localSDP.failICE = true;
      }

      localSDP.toJingle(accept, this.initiatorJid === this.localJid ? 'initiator' : 'responder', null); // Calling tree() to print something useful

      accept = accept.tree();
      logger.info('Sending session-accept', accept);
      this.connection.sendIQ(accept, success, this.newJingleErrorHandler(accept, function (error) {
        failure(error); // 'session-accept' is a critical timeout and we'll
        // have to restart

        _this11.room.eventEmitter.emit(_XMPPEvents["default"].SESSION_ACCEPT_TIMEOUT, _this11);
      }), IQ_TIMEOUT); // XXX Videobridge needs WebRTC's answer (ICE ufrag and pwd, DTLS
      // fingerprint and setup) ASAP in order to start the connection
      // establishment.
      //
      // FIXME Flushing the connection at this point triggers an issue with
      // BOSH request handling in Prosody on slow connections.
      //
      // The problem is that this request will be quite large and it may take
      // time before it reaches Prosody. In the meantime Strophe may decide
      // to send the next one. And it was observed that a small request with
      // 'transport-info' usually follows this one. It does reach Prosody
      // before the previous one was completely received. 'rid' on the server
      // is increased and Prosody ignores the request with 'session-accept'.
      // It will never reach Jicofo and everything in the request table is
      // lost. Removing the flush does not guarantee it will never happen, but
      // makes it much less likely('transport-info' is bundled with
      // 'session-accept' and any immediate requests).
      //
      // this.connection.flush();
    }
    /**
     * Will send 'content-modify' IQ in order to ask the remote peer to
     * either stop or resume sending video media.
     * @param {boolean} videoTransferActive <tt>false</tt> to let the other peer
     * know that we're not sending nor interested in receiving video contents.
     * When set to <tt>true</tt> remote peer will be asked to resume video
     * transfer.
     * @private
     */

  }, {
    key: "sendContentModify",
    value: function sendContentModify(videoTransferActive) {
      var newSendersValue = videoTransferActive ? 'both' : 'none';
      var sessionModify = (0, _strophe.$iq)({
        to: this.remoteJid,
        type: 'set'
      }).c('jingle', {
        xmlns: 'urn:xmpp:jingle:1',
        action: 'content-modify',
        initiator: this.initiatorJid,
        sid: this.sid
      }).c('content', {
        name: 'video',
        senders: newSendersValue
      });
      logger.info("Sending content-modify, video senders: ".concat(newSendersValue));
      this.connection.sendIQ(sessionModify, null, this.newJingleErrorHandler(sessionModify), IQ_TIMEOUT);
    }
    /**
     * Sends Jingle 'transport-accept' message which is a response to
     * 'transport-replace'.
     * @param localSDP the 'SDP' object with local session description
     * @param success callback called when we receive 'RESULT' packet for
     *        'transport-replace'
     * @param failure function(error) called when we receive an error response
     *        or when the request has timed out.
     * @private
     */

  }, {
    key: "sendTransportAccept",
    value: function sendTransportAccept(localSDP, success, failure) {
      var _this12 = this;

      var transportAccept = (0, _strophe.$iq)({
        to: this.remoteJid,
        type: 'set'
      }).c('jingle', {
        xmlns: 'urn:xmpp:jingle:1',
        action: 'transport-accept',
        initiator: this.initiatorJid,
        sid: this.sid
      });
      localSDP.media.forEach(function (medialines, idx) {
        var mline = _SDPUtil["default"].parseMLine(medialines.split('\r\n')[0]);

        transportAccept.c('content', {
          creator: _this12.initiatorJid === _this12.localJid ? 'initiator' : 'responder',
          name: mline.media
        });
        localSDP.transportToJingle(idx, transportAccept);
        transportAccept.up();
      }); // Calling tree() to print something useful to the logger

      transportAccept = transportAccept.tree();
      logger.info('Sending transport-accept: ', transportAccept);
      this.connection.sendIQ(transportAccept, success, this.newJingleErrorHandler(transportAccept, failure), IQ_TIMEOUT);
    }
    /**
     * Sends Jingle 'transport-reject' message which is a response to
     * 'transport-replace'.
     * @param success callback called when we receive 'RESULT' packet for
     *        'transport-replace'
     * @param failure function(error) called when we receive an error response
     *        or when the request has timed out.
     *
     * FIXME method should be marked as private, but there's some spaghetti that
     *       needs to be fixed prior doing that
     */

  }, {
    key: "sendTransportReject",
    value: function sendTransportReject(success, failure) {
      // Send 'transport-reject', so that the focus will
      // know that we've failed
      var transportReject = (0, _strophe.$iq)({
        to: this.remoteJid,
        type: 'set'
      }).c('jingle', {
        xmlns: 'urn:xmpp:jingle:1',
        action: 'transport-reject',
        initiator: this.initiatorJid,
        sid: this.sid
      });
      transportReject = transportReject.tree();
      logger.info('Sending \'transport-reject', transportReject);
      this.connection.sendIQ(transportReject, success, this.newJingleErrorHandler(transportReject, failure), IQ_TIMEOUT);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "terminate",
    value: function terminate(success, failure, options) {
      if (this.state === JingleSessionState.ENDED) {
        return;
      }

      if (!options || Boolean(options.sendSessionTerminate)) {
        var sessionTerminate = (0, _strophe.$iq)({
          to: this.remoteJid,
          type: 'set'
        }).c('jingle', {
          xmlns: 'urn:xmpp:jingle:1',
          action: 'session-terminate',
          initiator: this.initiatorJid,
          sid: this.sid
        }).c('reason').c(options && options.reason || 'success');

        if (options && options.reasonDescription) {
          sessionTerminate.up().c('text').t(options.reasonDescription);
        } // Calling tree() to print something useful


        sessionTerminate = sessionTerminate.tree();
        logger.info('Sending session-terminate', sessionTerminate);
        this.connection.sendIQ(sessionTerminate, success, this.newJingleErrorHandler(sessionTerminate, failure), IQ_TIMEOUT);
      } else {
        logger.info("Skipped sending session-terminate for ".concat(this));
      } // this should result in 'onTerminated' being called by strope.jingle.js


      this.connection.jingle.terminate(this.sid);
    }
    /**
     *
     * @param reasonCondition
     * @param reasonText
     */

  }, {
    key: "onTerminated",
    value: function onTerminated(reasonCondition, reasonText) {
      this.state = JingleSessionState.ENDED;
      this.establishmentDuration = undefined; // Do something with reason and reasonCondition when we start to care
      // this.reasonCondition = reasonCondition;
      // this.reasonText = reasonText;

      logger.info("Session terminated ".concat(this), reasonCondition, reasonText);
      this.close();
    }
    /**
     * Parse the information from the xml sourceAddElem and translate it
     *  into sdp lines
     * @param {jquery xml element} sourceAddElem the source-add
     *  element from jingle
     * @param {SDP object} currentRemoteSdp the current remote
     *  sdp (as of this new source-add)
     * @returns {list} a list of SDP line strings that should
     *  be added to the remote SDP
     */

  }, {
    key: "_parseSsrcInfoFromSourceAdd",
    value: function _parseSsrcInfoFromSourceAdd(sourceAddElem, currentRemoteSdp) {
      var addSsrcInfo = [];
      $(sourceAddElem).each(function (i1, content) {
        var name = $(content).attr('name');
        var lines = '';
        $(content).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(function () {
          // eslint-disable-next-line no-invalid-this
          var semantics = this.getAttribute('semantics');
          var ssrcs = $(this) // eslint-disable-line no-invalid-this
          .find('>source').map(function () {
            // eslint-disable-next-line no-invalid-this
            return this.getAttribute('ssrc');
          }).get();

          if (ssrcs.length) {
            lines += "a=ssrc-group:".concat(semantics, " ").concat(ssrcs.join(' '), "\r\n");
          }
        }); // handles both >source and >description>source

        var tmp = $(content).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]');
        /* eslint-disable no-invalid-this */

        tmp.each(function () {
          var ssrc = $(this).attr('ssrc');

          if (currentRemoteSdp.containsSSRC(ssrc)) {
            logger.warn("Source-add request for existing SSRC: ".concat(ssrc));
            return;
          } // eslint-disable-next-line newline-per-chained-call


          $(this).find('>parameter').each(function () {
            lines += "a=ssrc:".concat(ssrc, " ").concat($(this).attr('name'));

            if ($(this).attr('value') && $(this).attr('value').length) {
              lines += ":".concat($(this).attr('value'));
            }

            lines += '\r\n';
          });
        });
        /* eslint-enable no-invalid-this */

        currentRemoteSdp.media.forEach(function (media, i2) {
          if (!_SDPUtil["default"].findLine(media, "a=mid:".concat(name))) {
            return;
          }

          if (!addSsrcInfo[i2]) {
            addSsrcInfo[i2] = '';
          }

          addSsrcInfo[i2] += lines;
        });
      });
      return addSsrcInfo;
    }
    /**
     * Handles a Jingle source-add message for this Jingle session.
     * @param elem An array of Jingle "content" elements.
     */

  }, {
    key: "addRemoteStream",
    value: function addRemoteStream(elem) {
      this._addOrRemoveRemoteStream(true
      /* add */
      , elem);
    }
    /**
     * Handles a Jingle source-remove message for this Jingle session.
     * @param elem An array of Jingle "content" elements.
     */

  }, {
    key: "removeRemoteStream",
    value: function removeRemoteStream(elem) {
      this._addOrRemoveRemoteStream(false
      /* remove */
      , elem);
    }
    /**
     * Handles either Jingle 'source-add' or 'source-remove' message for this
     * Jingle session.
     * @param {boolean} isAdd <tt>true</tt> for 'source-add' or <tt>false</tt>
     * otherwise.
     * @param {Array<Element>} elem an array of Jingle "content" elements.
     * @private
     */

  }, {
    key: "_addOrRemoveRemoteStream",
    value: function _addOrRemoveRemoteStream(isAdd, elem) {
      var _this13 = this;

      var logPrefix = isAdd ? 'addRemoteStream' : 'removeRemoteStream';

      if (isAdd) {
        this.readSsrcInfo(elem);
      }

      var workFunction = function workFunction(finishedCallback) {
        if (!_this13.peerconnection.localDescription || !_this13.peerconnection.localDescription.sdp) {
          var errMsg = "".concat(logPrefix, " - localDescription not ready yet");
          logger.error(errMsg);
          finishedCallback(errMsg);
          return;
        }

        logger.log("Processing ".concat(logPrefix));
        logger.log('ICE connection state: ', _this13.peerconnection.iceConnectionState);
        var oldLocalSdp = new _SDP["default"](_this13.peerconnection.localDescription.sdp);
        var sdp = new _SDP["default"](_this13.peerconnection.remoteDescription.sdp);
        var addOrRemoveSsrcInfo = isAdd ? _this13._parseSsrcInfoFromSourceAdd(elem, sdp) : _this13._parseSsrcInfoFromSourceRemove(elem, sdp);
        var newRemoteSdp = isAdd ? _this13._processRemoteAddSource(addOrRemoveSsrcInfo) : _this13._processRemoteRemoveSource(addOrRemoveSsrcInfo);

        _this13._renegotiate(newRemoteSdp.raw).then(function () {
          var newLocalSdp = new _SDP["default"](_this13.peerconnection.localDescription.sdp);
          logger.log("".concat(logPrefix, " - OK, SDPs: "), oldLocalSdp, newLocalSdp);

          _this13.notifyMySSRCUpdate(oldLocalSdp, newLocalSdp);

          finishedCallback();
        }, function (error) {
          logger.error("".concat(logPrefix, " failed:"), error);
          finishedCallback(error);
        });
      }; // Queue and execute


      this.modificationQueue.push(workFunction);
    }
    /**
     * The 'task' function will be given a callback it MUST call with either:
     *  1) No arguments if it was successful or
     *  2) An error argument if there was an error
     * If the task wants to process the success or failure of the task, it
     * should pass a handler to the .push function, e.g.:
     * queue.push(task, (err) => {
     *     if (err) {
     *         // error handling
     *     } else {
     *         // success handling
     *     }
     * });
     */

  }, {
    key: "_processQueueTasks",
    value: function _processQueueTasks(task, finishedCallback) {
      task(finishedCallback);
    }
    /**
     * Takes in a jingle offer iq, returns the new sdp offer
     * @param {jquery xml element} offerIq the incoming offer
     * @returns {SDP object} the jingle offer translated to SDP
     */

  }, {
    key: "_processNewJingleOfferIq",
    value: function _processNewJingleOfferIq(offerIq) {
      var remoteSdp = new _SDP["default"]('');

      if (this.webrtcIceTcpDisable) {
        remoteSdp.removeTcpCandidates = true;
      }

      if (this.webrtcIceUdpDisable) {
        remoteSdp.removeUdpCandidates = true;
      }

      if (this.failICE) {
        remoteSdp.failICE = true;
      }

      remoteSdp.fromJingle(offerIq);
      this.readSsrcInfo($(offerIq).find('>content'));
      return remoteSdp;
    }
    /**
     * Remove the given ssrc lines from the current remote sdp
     * @param {list} removeSsrcInfo a list of SDP line strings that
     *  should be removed from the remote SDP
     * @returns type {SDP Object} the new remote SDP (after removing the lines
     *  in removeSsrcInfo
     */

  }, {
    key: "_processRemoteRemoveSource",
    value: function _processRemoteRemoveSource(removeSsrcInfo) {
      var remoteSdp = new _SDP["default"](this.peerconnection.remoteDescription.sdp);
      removeSsrcInfo.forEach(function (lines, idx) {
        // eslint-disable-next-line no-param-reassign
        lines = lines.split('\r\n');
        lines.pop(); // remove empty last element;

        lines.forEach(function (line) {
          remoteSdp.media[idx] = remoteSdp.media[idx].replace("".concat(line, "\r\n"), '');
        });
      });
      remoteSdp.raw = remoteSdp.session + remoteSdp.media.join('');
      return remoteSdp;
    }
    /**
     * Add the given ssrc lines to the current remote sdp
     * @param {list} addSsrcInfo a list of SDP line strings that
     *  should be added to the remote SDP
     * @returns type {SDP Object} the new remote SDP (after removing the lines
     *  in removeSsrcInfo
     */

  }, {
    key: "_processRemoteAddSource",
    value: function _processRemoteAddSource(addSsrcInfo) {
      var remoteSdp = new _SDP["default"](this.peerconnection.remoteDescription.sdp);
      addSsrcInfo.forEach(function (lines, idx) {
        remoteSdp.media[idx] += lines;
      });
      remoteSdp.raw = remoteSdp.session + remoteSdp.media.join('');
      return remoteSdp;
    }
    /**
     * Do a new o/a flow using the existing remote description
     * @param {string} [optionalRemoteSdp] optional, raw remote sdp
     *  to use.  If not provided, the remote sdp from the
     *  peerconnection will be used
     * @returns {Promise} promise which resolves when the
     *  o/a flow is complete with no arguments or
     *  rejects with an error {string}
     */

  }, {
    key: "_renegotiate",
    value: function _renegotiate(optionalRemoteSdp) {
      if (this.peerconnection.signalingState === 'closed') {
        return Promise.reject('Attempted to renegotiate in state closed');
      }

      var remoteSdp = optionalRemoteSdp || this.peerconnection.remoteDescription.sdp;

      if (!remoteSdp) {
        return Promise.reject('Can not renegotiate without remote description,' + "- current state: ".concat(this.state));
      }

      var remoteDescription = new RTCSessionDescription({
        type: this.isInitiator ? 'answer' : 'offer',
        sdp: remoteSdp
      });

      if (this.isInitiator) {
        return this._initiatorRenegotiate(remoteDescription);
      }

      return this._responderRenegotiate(remoteDescription);
    }
    /**
     * Renegotiate cycle implementation for the responder case.
     * @param {object} remoteDescription the SDP object as defined by the WebRTC
     * which will be used as remote description in the cycle.
     * @private
     */

  }, {
    key: "_responderRenegotiate",
    value: function _responderRenegotiate(remoteDescription) {
      var _this14 = this;

      logger.debug('Renegotiate: setting remote description');
      return this.peerconnection.setRemoteDescription(remoteDescription).then(function () {
        logger.debug('Renegotiate: creating answer');
        return _this14.peerconnection.createAnswer(_this14.mediaConstraints).then(function (answer) {
          logger.debug('Renegotiate: setting local description');
          return _this14.peerconnection.setLocalDescription(answer);
        });
      });
    }
    /**
     * Renegotiate cycle implementation for the initiator's case.
     * @param {object} remoteDescription the SDP object as defined by the WebRTC
     * which will be used as remote description in the cycle.
     * @private
     */

  }, {
    key: "_initiatorRenegotiate",
    value: function _initiatorRenegotiate(remoteDescription) {
      var _this15 = this;

      if (this.peerconnection.signalingState === 'have-local-offer') {
        // Skip createOffer and setLocalDescription or FF will fail
        logger.debug('Renegotiate: setting remote description');
        /* eslint-disable arrow-body-style */

        return this.peerconnection.setRemoteDescription(remoteDescription).then(function () {
          // In case when the answer is being set for the first time,
          // full sRD/sLD cycle is required to have the local
          // description updated and SSRCs synchronized correctly.
          // Otherwise SSRCs for streams added after invite, but
          // before the answer was accepted will not be detected.
          // The reason for that is that renegotiate can not be called
          // when adding tracks and they will not be reflected in
          // the local SDP.
          return _this15._initiatorRenegotiate(remoteDescription);
        });
        /* eslint-enable arrow-body-style */
      }

      logger.debug('Renegotiate: creating offer');
      return this.peerconnection.createOffer(this.mediaConstraints).then(function (offer) {
        logger.debug('Renegotiate: setting local description');
        return _this15.peerconnection.setLocalDescription(offer).then(function () {
          logger.debug('Renegotiate: setting remote description'); // eslint-disable-next-line max-len

          return _this15.peerconnection.setRemoteDescription(remoteDescription);
        });
      });
    }
    /**
     * Replaces <tt>oldTrack</tt> with <tt>newTrack</tt> and performs a single
     * offer/answer cycle after both operations are done. Either
     * <tt>oldTrack</tt> or <tt>newTrack</tt> can be null; replacing a valid
     * <tt>oldTrack</tt> with a null <tt>newTrack</tt> effectively just removes
     * <tt>oldTrack</tt>
     * @param {JitsiLocalTrack|null} oldTrack the current track in use to be
     * replaced
     * @param {JitsiLocalTrack|null} newTrack the new track to use
     * @returns {Promise} which resolves once the replacement is complete
     *  with no arguments or rejects with an error {string}
     */

  }, {
    key: "replaceTrack",
    value: function replaceTrack(oldTrack, newTrack) {
      var _this16 = this;

      var workFunction = function workFunction(finishedCallback) {
        // Check if the connection was closed and pretend everything is OK.
        // This can happen if a track removal is scheduled but takes place
        // after the connection is closed.
        if (_this16.peerconnection.signalingState === 'closed' || _this16.peerconnection.connectionState === 'closed' || _this16.closed) {
          finishedCallback();
          return;
        }

        var oldLocalSdp = _this16.peerconnection.localDescription.sdp; // NOTE the code below assumes that no more than 1 video track
        // can be added to the peer connection.
        // Transition from no video to video (possibly screen sharing)

        if (!oldTrack && newTrack && newTrack.isVideoTrack()) {
          // Clearing current primary SSRC will make
          // the SdpConsistency generate a new one which will result
          // with:
          // 1. source-remove for the recvonly
          // 2. source-add for the new video stream
          _this16.peerconnection.clearRecvonlySsrc(); // Transition from video to no video

        } else if (oldTrack && oldTrack.isVideoTrack() && !newTrack) {
          // Clearing current primary SSRC and generating the recvonly
          // will result in:
          // 1. source-remove for the old video stream
          // 2. source-add for the recvonly stream
          _this16.peerconnection.clearRecvonlySsrc();

          _this16.peerconnection.generateRecvonlySsrc();
        }

        _this16.peerconnection.replaceTrack(oldTrack, newTrack).then(function (shouldRenegotiate) {
          if (shouldRenegotiate && (oldTrack || newTrack) && _this16.state === JingleSessionState.ACTIVE) {
            _this16._renegotiate().then(function () {
              var newLocalSDP = new _SDP["default"](_this16.peerconnection.localDescription.sdp);

              _this16.notifyMySSRCUpdate(new _SDP["default"](oldLocalSdp), newLocalSDP);

              finishedCallback();
            }, finishedCallback
            /* will be called with en error */
            );
          } else {
            finishedCallback();
          }
        });
      };

      return new Promise(function (resolve, reject) {
        _this16.modificationQueue.push(workFunction, function (error) {
          if (error) {
            logger.error('Replace track error:', error);
            reject(error);
          } else {
            logger.info('Replace track done!');
            resolve();
          }
        });
      });
    }
    /**
     * Parse the information from the xml sourceRemoveElem and translate it
     *  into sdp lines
     * @param {jquery xml element} sourceRemoveElem the source-remove
     *  element from jingle
     * @param {SDP object} currentRemoteSdp the current remote
     *  sdp (as of this new source-remove)
     * @returns {list} a list of SDP line strings that should
     *  be removed from the remote SDP
     */

  }, {
    key: "_parseSsrcInfoFromSourceRemove",
    value: function _parseSsrcInfoFromSourceRemove(sourceRemoveElem, currentRemoteSdp) {
      var removeSsrcInfo = [];
      $(sourceRemoveElem).each(function (i1, content) {
        var name = $(content).attr('name');
        var lines = '';
        $(content).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(function () {
          /* eslint-disable no-invalid-this */
          var semantics = this.getAttribute('semantics');
          var ssrcs = $(this).find('>source').map(function () {
            return this.getAttribute('ssrc');
          }).get();

          if (ssrcs.length) {
            lines += "a=ssrc-group:".concat(semantics, " ").concat(ssrcs.join(' '), "\r\n");
          }
          /* eslint-enable no-invalid-this */

        });
        var ssrcs = []; // handles both >source and >description>source versions

        var tmp = $(content).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]');
        tmp.each(function () {
          // eslint-disable-next-line no-invalid-this
          var ssrc = $(this).attr('ssrc');
          ssrcs.push(ssrc);
        });
        currentRemoteSdp.media.forEach(function (media, i2) {
          if (!_SDPUtil["default"].findLine(media, "a=mid:".concat(name))) {
            return;
          }

          if (!removeSsrcInfo[i2]) {
            removeSsrcInfo[i2] = '';
          }

          ssrcs.forEach(function (ssrc) {
            var ssrcLines = _SDPUtil["default"].findLines(media, "a=ssrc:".concat(ssrc));

            if (ssrcLines.length) {
              removeSsrcInfo[i2] += "".concat(ssrcLines.join('\r\n'), "\r\n");
            }
          });
          removeSsrcInfo[i2] += lines;
        });
      });
      return removeSsrcInfo;
    }
    /**
     * Will print an error if there is any difference, between the SSRCs given
     * in the <tt>oldSDP</tt> and the ones currently described in
     * the peerconnection's local description.
     * @param {string} operationName the operation's name which will be printed
     * in the error message.
     * @param {SDP} oldSDP the old local SDP which will be compared with
     * the current one.
     * @return {boolean} <tt>true</tt> if there was any change or <tt>false</tt>
     * otherwise.
     * @private
     */

  }, {
    key: "_verifyNoSSRCChanged",
    value: function _verifyNoSSRCChanged(operationName, oldSDP) {
      var currentLocalSDP = new _SDP["default"](this.peerconnection.localDescription.sdp);
      var sdpDiff = new _SDPDiffer["default"](oldSDP, currentLocalSDP);
      var addedMedia = sdpDiff.getNewMedia();

      if (Object.keys(addedMedia).length) {
        logger.error("".concat(this, " - some SSRC were added on ").concat(operationName), addedMedia);
        return false;
      }

      sdpDiff = new _SDPDiffer["default"](currentLocalSDP, oldSDP);
      var removedMedia = sdpDiff.getNewMedia();

      if (Object.keys(removedMedia).length) {
        logger.error("".concat(this, " - some SSRCs were removed on ").concat(operationName), removedMedia);
        return false;
      }

      return true;
    }
    /**
     * Adds local track back to this session, as part of the unmute operation.
     * @param {JitsiLocalTrack} track
     * @return {Promise} a promise that will resolve once the local track is
     * added back to this session and renegotiation succeeds. Will be rejected
     * with a <tt>string</tt> that provides some error details in case something
     * goes wrong.
     */

  }, {
    key: "addTrackAsUnmute",
    value: function addTrackAsUnmute(track) {
      return this._addRemoveTrackAsMuteUnmute(false
      /* add as unmute */
      , track);
    }
    /**
     * Remove local track as part of the mute operation.
     * @param {JitsiLocalTrack} track the local track to be removed
     * @return {Promise} a promise which will be resolved once the local track
     * is removed from this session and the renegotiation is performed.
     * The promise will be rejected with a <tt>string</tt> that the describes
     * the error if anything goes wrong.
     */

  }, {
    key: "removeTrackAsMute",
    value: function removeTrackAsMute(track) {
      return this._addRemoveTrackAsMuteUnmute(true
      /* remove as mute */
      , track);
    }
    /**
     * See {@link addTrackAsUnmute} and {@link removeTrackAsMute}.
     * @param {boolean} isMute <tt>true</tt> for "remove as mute" or
     * <tt>false</tt> for "add as unmute".
     * @param {JitsiLocalTrack} track the track that will be added/removed
     * @private
     */

  }, {
    key: "_addRemoveTrackAsMuteUnmute",
    value: function _addRemoveTrackAsMuteUnmute(isMute, track) {
      var _this17 = this;

      if (!track) {
        return Promise.reject('invalid "track" argument value');
      }

      var operationName = isMute ? 'removeTrackMute' : 'addTrackUnmute';

      var workFunction = function workFunction(finishedCallback) {
        var tpc = _this17.peerconnection;

        if (!tpc) {
          finishedCallback("Error:  tried ".concat(operationName, " track with no active peer") + 'connection');
          return;
        }

        var oldLocalSDP = tpc.localDescription.sdp;
        var tpcOperation = isMute ? tpc.removeTrackMute.bind(tpc, track) : tpc.addTrackUnmute.bind(tpc, track);

        if (!tpcOperation()) {
          finishedCallback("".concat(operationName, " failed!"));
        } else if (!oldLocalSDP || !tpc.remoteDescription.sdp) {
          finishedCallback();
        } else {
          _this17._renegotiate().then(function () {
            // The results are ignored, as this check failure is not
            // enough to fail the whole operation. It will log
            // an error inside.
            _this17._verifyNoSSRCChanged(operationName, new _SDP["default"](oldLocalSDP));

            finishedCallback();
          }, finishedCallback
          /* will be called with an error */
          );
        }
      };

      return new Promise(function (resolve, reject) {
        _this17.modificationQueue.push(workFunction, function (error) {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    }
    /**
     * Resumes or suspends media transfer over the underlying peer connection.
     * @param {boolean} audioActive <tt>true</tt> to enable audio media
     * transfer or <tt>false</tt> to suspend audio media transmission.
     * @param {boolean} videoActive <tt>true</tt> to enable video media
     * transfer or <tt>false</tt> to suspend video media transmission.
     * @return {Promise} a <tt>Promise</tt> which will resolve once
     * the operation is done. It will be rejected with an error description as
     * a string in case anything goes wrong.
     */

  }, {
    key: "setMediaTransferActive",
    value: function setMediaTransferActive(audioActive, videoActive) {
      var _this18 = this;

      if (!this.peerconnection) {
        return Promise.reject('Can not modify transfer active state,' + ' before "initialize" is called');
      }

      var logAudioStr = audioActive ? 'audio active' : 'audio inactive';
      var logVideoStr = videoActive ? 'video active' : 'video inactive';
      logger.info("Queued make ".concat(logVideoStr, ", ").concat(logAudioStr, " task..."));

      var workFunction = function workFunction(finishedCallback) {
        var isSessionActive = _this18.state === JingleSessionState.ACTIVE; // Because the value is modified on the queue it's impossible to
        // check it's final value reliably prior to submitting the task.
        // The rule here is that the last submitted state counts.
        // Check the values here to avoid unnecessary renegotiation cycle.

        var audioActiveChanged = _this18.peerconnection.setAudioTransferActive(audioActive);

        if (_this18._localVideoActive !== videoActive) {
          _this18._localVideoActive = videoActive; // Do only for P2P - Jicofo will reply with 'bad-request'
          // We don't want to send 'content-modify', before the initial
          // O/A (state === JingleSessionState.ACTIVE), because that will
          // mess up video media direction in the remote SDP.
          // 'content-modify' when processed only affects the media
          // direction in the local SDP. We're doing that, because setting
          // 'inactive' on video media in remote SDP will mess up our SDP
          // translation chain (simulcast, RTX, video mute etc.).

          if (_this18.isP2P && isSessionActive) {
            _this18.sendContentModify(videoActive);
          }
        }

        var pcVideoActiveChanged = _this18.peerconnection.setVideoTransferActive(_this18._localVideoActive && _this18._remoteVideoActive); // Will do the sRD/sLD cycle to update SDPs and adjust the media
        // direction


        if (isSessionActive && (audioActiveChanged || pcVideoActiveChanged)) {
          _this18._renegotiate().then(finishedCallback, finishedCallback
          /* will be called with an error */
          );
        } else {
          finishedCallback();
        }
      };

      return new Promise(function (resolve, reject) {
        _this18.modificationQueue.push(workFunction, function (error) {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    }
    /**
     * Will put and execute on the queue a session modify task. Currently it
     * only checks the senders attribute of the video content in order to figure
     * out if the remote peer has video in the inactive state (stored locally
     * in {@link _remoteVideoActive} - see field description for more info).
     * @param {jQuery} jingleContents jQuery selector pointing to the jingle
     * element of the session modify IQ.
     * @see {@link _remoteVideoActive}
     * @see {@link _localVideoActive}
     */

  }, {
    key: "modifyContents",
    value: function modifyContents(jingleContents) {
      var _this19 = this;

      var newVideoSenders = JingleSessionPC.parseVideoSenders(jingleContents);

      if (newVideoSenders === null) {
        logger.error("".concat(this, " - failed to parse video \"senders\" attribute in") + '"content-modify" action');
        return;
      }

      var workFunction = function workFunction(finishedCallback) {
        if (_this19._assertNotEnded('content-modify') && _this19._modifyRemoteVideoActive(newVideoSenders)) {
          // Will do the sRD/sLD cycle to update SDPs and adjust
          // the media direction
          _this19._renegotiate().then(finishedCallback, finishedCallback
          /* (error) */
          );
        } else {
          finishedCallback();
        }
      };

      logger.debug("".concat(this, " queued \"content-modify\" task") + "(video senders=\"".concat(newVideoSenders, "\")"));
      this.modificationQueue.push(workFunction, function (error) {
        if (error) {
          logger.error('"content-modify" failed', error);
        }
      });
    }
    /**
     * Processes new value of remote video "senders" Jingle attribute and tries
     * to apply it for {@link _remoteVideoActive}.
     * @param {string} remoteVideoSenders the value of "senders" attribute of
     * Jingle video content element advertised by remote peer.
     * @return {boolean} <tt>true</tt> if the change affected state of
     * the underlying peerconnection and renegotiation is required for
     * the changes to take effect.
     * @private
     */

  }, {
    key: "_modifyRemoteVideoActive",
    value: function _modifyRemoteVideoActive(remoteVideoSenders) {
      var isRemoteVideoActive = remoteVideoSenders === 'both' || remoteVideoSenders === 'initiator' && this.isInitiator || remoteVideoSenders === 'responder' && !this.isInitiator;

      if (isRemoteVideoActive !== this._remoteVideoActive) {
        logger.debug("".concat(this, " new remote video active: ").concat(isRemoteVideoActive));
        this._remoteVideoActive = isRemoteVideoActive;
      }

      return this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive);
    }
    /**
     * Figures out added/removed ssrcs and send update IQs.
     * @param oldSDP SDP object for old description.
     * @param newSDP SDP object for new description.
     */

  }, {
    key: "notifyMySSRCUpdate",
    value: function notifyMySSRCUpdate(oldSDP, newSDP) {
      if (this.state !== JingleSessionState.ACTIVE) {
        logger.warn("Skipping SSRC update in '".concat(this.state, " ' state."));
        return;
      } // send source-remove IQ.


      var sdpDiffer = new _SDPDiffer["default"](newSDP, oldSDP);
      var remove = (0, _strophe.$iq)({
        to: this.remoteJid,
        type: 'set'
      }).c('jingle', {
        xmlns: 'urn:xmpp:jingle:1',
        action: 'source-remove',
        initiator: this.initiatorJid,
        sid: this.sid
      });
      var removedAnySSRCs = sdpDiffer.toJingle(remove);

      if (removedAnySSRCs) {
        logger.info('Sending source-remove', remove.tree());
        this.connection.sendIQ(remove, null, this.newJingleErrorHandler(remove), IQ_TIMEOUT);
      } else {
        logger.log('removal not necessary');
      } // send source-add IQ.


      sdpDiffer = new _SDPDiffer["default"](oldSDP, newSDP);
      var add = (0, _strophe.$iq)({
        to: this.remoteJid,
        type: 'set'
      }).c('jingle', {
        xmlns: 'urn:xmpp:jingle:1',
        action: 'source-add',
        initiator: this.initiatorJid,
        sid: this.sid
      });
      var containsNewSSRCs = sdpDiffer.toJingle(add);

      if (containsNewSSRCs) {
        logger.info('Sending source-add', add.tree());
        this.connection.sendIQ(add, null, this.newJingleErrorHandler(add), IQ_TIMEOUT);
      } else {
        logger.log('addition not necessary');
      }
    }
    /**
     * Method returns function(errorResponse) which is a callback to be passed
     * to Strophe connection.sendIQ method. An 'error' structure is created that
     * is passed as 1st argument to given <tt>failureCb</tt>. The format of this
     * structure is as follows:
     * {
     *  code: {XMPP error response code}
     *  reason: {the name of XMPP error reason element or 'timeout' if the
      *          request has timed out within <tt>IQ_TIMEOUT</tt> milliseconds}
     *  source: {request.tree() that provides original request}
     *  session: {this JingleSessionPC.toString()}
     * }
     * @param request Strophe IQ instance which is the request to be dumped into
     *        the error structure
     * @param failureCb function(error) called when error response was returned
     *        or when a timeout has occurred.
     * @returns {function(this:JingleSessionPC)}
     */

  }, {
    key: "newJingleErrorHandler",
    value: function newJingleErrorHandler(request, failureCb) {
      var _this20 = this;

      return function (errResponse) {
        var error = {}; // Get XMPP error code and condition(reason)

        var errorElSel = $(errResponse).find('error');

        if (errorElSel.length) {
          error.code = errorElSel.attr('code');
          var errorReasonSel = $(errResponse).find('error :first');

          if (errorReasonSel.length) {
            error.reason = errorReasonSel[0].tagName;
          }

          var errorMsgSel = errorElSel.find('>text');

          if (errorMsgSel.length) {
            error.msg = errorMsgSel.text();
          }
        }

        if (!errResponse) {
          error.reason = 'timeout';
        }

        error.session = _this20.toString();

        if (failureCb) {
          failureCb(error);
        } else if (_this20.state === JingleSessionState.ENDED && error.reason === 'item-not-found') {
          // When remote peer decides to terminate the session, but it
          // still have few messages on the queue for processing,
          // it will first send us 'session-terminate' (we enter ENDED)
          // and then follow with 'item-not-found' for the queued requests
          // We don't want to have that logged on error level.
          logger.debug("Jingle error: ".concat(JSON.stringify(error)));
        } else {
          _GlobalOnErrorHandler["default"].callErrorHandler(new Error("Jingle error: ".concat(JSON.stringify(error))));
        }
      };
    }
    /**
     *
     * @param error
     * @private
     */

  }, {
    key: "_onJingleFatalError",
    value: function _onJingleFatalError(error) {
      if (this.room) {
        this.room.eventEmitter.emit(_XMPPEvents["default"].CONFERENCE_SETUP_FAILED, this, error);
        this.room.eventEmitter.emit(_XMPPEvents["default"].JINGLE_FATAL_ERROR, this, error);
      }
    }
    /**
     * Returns the ice connection state for the peer connection.
     * @returns the ice connection state for the peer connection.
     */

  }, {
    key: "getIceConnectionState",
    value: function getIceConnectionState() {
      return this.peerconnection.iceConnectionState;
    }
    /**
     * Closes the peerconnection.
     */

  }, {
    key: "close",
    value: function close() {
      this.closed = true; // The signaling layer will remove it's listeners

      this.signalingLayer.setChatRoom(null); // do not try to close if already closed.

      this.peerconnection && (this.peerconnection.signalingState && this.peerconnection.signalingState !== 'closed' || this.peerconnection.connectionState && this.peerconnection.connectionState !== 'closed') && this.peerconnection.close();
    }
    /**
     * Converts to string with minor summary.
     * @return {string}
     */

  }, {
    key: "toString",
    value: function toString() {
      return "JingleSessionPC[p2p=".concat(this.isP2P, ",") + "initiator=".concat(this.isInitiator, ",sid=").concat(this.sid, "]");
    }
    /**
     * If the A/B test for suspend video is disabled according to the room's
     * configuration, returns undefined. Otherwise returns a boolean which
     * indicates whether the suspend video option should be enabled or disabled.
     * @param {JingleSessionPCOptions} options - The config options.
     */

  }, {
    key: "_abtestSuspendVideoEnabled",
    value: function _abtestSuspendVideoEnabled(_ref) {
      var abTesting = _ref.abTesting;

      if (!abTesting || !abTesting.enableSuspendVideoTest) {
        return;
      } // We want the two participants in a P2P call to agree on the value of
      // the "suspend" option. We use the JID of the initiator, because it is
      // both randomly selected and agreed upon by both participants.


      var jid = this._getInitiatorJid();

      return (0, _StringUtils.integerHash)(jid) % 2 === 0;
    }
  }]);

  return JingleSessionPC;
}(_JingleSession2["default"]);

exports["default"] = JingleSessionPC;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ENDED = exports.ACTIVE = exports.PENDING = void 0;

/**
 * The pending Jingle session state which means the session as defined in
 * XEP-0166(before 'session-invite/session-accept' took place).
 *
 * @type {string}
 */
var PENDING = 'pending';
/**
 * The active Jingle session state as defined in XEP-0166
 * (after 'session-invite'/'session-accept').
 *
 * @type {string}
 */

exports.PENDING = PENDING;
var ACTIVE = 'active';
/**
 * The ended Jingle session state as defined in XEP-0166
 * (after 'session-terminate').
 * @type {string}
 */

exports.ACTIVE = ACTIVE;
var ENDED = 'ended';
exports.ENDED = ENDED;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = Moderator;

var _strophe = require("strophe.js");

var _browser = _interopRequireDefault(require("../browser"));

var _Settings = _interopRequireDefault(require("../settings/Settings"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/* global $, Promise */
var logger = require('jitsi-meet-logger').getLogger(__filename);

var XMPPEvents = require('../../service/xmpp/XMPPEvents');

var AuthenticationEvents = require('../../service/authentication/AuthenticationEvents');

var GlobalOnErrorHandler = require('../util/GlobalOnErrorHandler');

/**
 *
 * @param step
 */
function createExpBackoffTimer(step) {
  var count = 1;
  return function (reset) {
    // Reset call
    if (reset) {
      count = 1;
      return;
    } // Calculate next timeout


    var timeout = Math.pow(2, count - 1);
    count += 1;
    return timeout * step;
  };
}
/* eslint-disable max-params */

/**
 *
 * @param roomName
 * @param xmpp
 * @param emitter
 * @param options
 */


function Moderator(roomName, xmpp, emitter, options) {
  this.roomName = roomName;
  this.xmppService = xmpp;
  this.getNextTimeout = createExpBackoffTimer(1000);
  this.getNextErrorTimeout = createExpBackoffTimer(1000); // External authentication stuff

  this.externalAuthEnabled = false;
  this.options = options; // Sip gateway can be enabled by configuring Jigasi host in config.js or
  // it will be enabled automatically if focus detects the component through
  // service discovery.

  this.sipGatewayEnabled = this.options.connection.hosts && this.options.connection.hosts.call_control !== undefined;
  this.eventEmitter = emitter;
  this.connection = this.xmppService.connection; // FIXME: Message listener that talks to POPUP window

  /**
   *
   * @param event
   */

  function listener(event) {
    if (event.data && event.data.sessionId) {
      if (event.origin !== window.location.origin) {
        logger.warn("Ignoring sessionId from different origin: ".concat(event.origin));
        return;
      }

      _Settings["default"].sessionId = event.data.sessionId; // After popup is closed we will authenticate
    }
  } // Register


  if (window.addEventListener) {
    window.addEventListener('message', listener, false);
  } else {
    window.attachEvent('onmessage', listener);
  }
}
/* eslint-enable max-params */


Moderator.prototype.isExternalAuthEnabled = function () {
  return this.externalAuthEnabled;
};

Moderator.prototype.isSipGatewayEnabled = function () {
  return this.sipGatewayEnabled;
};

Moderator.prototype.onMucMemberLeft = function (jid) {
  logger.info("Someone left is it focus ? ".concat(jid));

  var resource = _strophe.Strophe.getResourceFromJid(jid);

  if (resource === 'focus') {
    logger.info('Focus has left the room - leaving conference');
    this.eventEmitter.emit(XMPPEvents.FOCUS_LEFT);
  }
};

Moderator.prototype.setFocusUserJid = function (focusJid) {
  if (!this.focusUserJid) {
    this.focusUserJid = focusJid;
    logger.info("Focus jid set to:  ".concat(this.focusUserJid));
  }
};

Moderator.prototype.getFocusUserJid = function () {
  return this.focusUserJid;
};

Moderator.prototype.getFocusComponent = function () {
  // Get focus component address
  var focusComponent = this.options.connection.hosts.focus; // If not specified use default:  'focus.domain'

  if (!focusComponent) {
    focusComponent = "focus.".concat(this.options.connection.hosts.domain);
  }

  return focusComponent;
};

Moderator.prototype.createConferenceIq = function () {
  // Generate create conference IQ
  var elem = (0, _strophe.$iq)({
    to: this.getFocusComponent(),
    type: 'set'
  }); // Session Id used for authentication

  var sessionId = _Settings["default"].sessionId;
  var machineUID = _Settings["default"].machineId;
  var config = this.options.conference;
  logger.info("Session ID: ".concat(sessionId, " machine UID: ").concat(machineUID));
  elem.c('conference', {
    xmlns: 'http://jitsi.org/protocol/focus',
    room: this.roomName,
    'machine-uid': machineUID
  });

  if (sessionId) {
    elem.attrs({
      'session-id': sessionId
    });
  }

  if (this.options.connection.enforcedBridge !== undefined) {
    elem.c('property', {
      name: 'enforcedBridge',
      value: this.options.connection.enforcedBridge
    }).up();
  } // Tell the focus we have Jigasi configured


  if (this.options.connection.hosts !== undefined && this.options.connection.hosts.call_control !== undefined) {
    elem.c('property', {
      name: 'call_control',
      value: this.options.connection.hosts.call_control
    }).up();
  }

  if (config.channelLastN !== undefined) {
    elem.c('property', {
      name: 'channelLastN',
      value: config.channelLastN
    }).up();
  }

  elem.c('property', {
    name: 'disableRtx',
    value: Boolean(config.disableRtx)
  }).up();

  if (config.enableTcc !== undefined) {
    elem.c('property', {
      name: 'enableTcc',
      value: Boolean(config.enableTcc)
    }).up();
  }

  if (config.enableRemb !== undefined) {
    elem.c('property', {
      name: 'enableRemb',
      value: Boolean(config.enableRemb)
    }).up();
  }

  if (config.minParticipants !== undefined) {
    elem.c('property', {
      name: 'minParticipants',
      value: config.minParticipants
    }).up();
  }

  elem.c('property', {
    name: 'enableLipSync',
    value: this.options.connection.enableLipSync !== false
  }).up();

  if (config.audioPacketDelay !== undefined) {
    elem.c('property', {
      name: 'audioPacketDelay',
      value: config.audioPacketDelay
    }).up();
  }

  if (config.startBitrate) {
    elem.c('property', {
      name: 'startBitrate',
      value: config.startBitrate
    }).up();
  }

  if (config.minBitrate) {
    elem.c('property', {
      name: 'minBitrate',
      value: config.minBitrate
    }).up();
  }

  if (config.testing && config.testing.octo && typeof config.testing.octo.probability === 'number') {
    if (Math.random() < config.testing.octo.probability) {
      elem.c('property', {
        name: 'octo',
        value: true
      }).up();
    }
  }

  var openSctp;

  switch (this.options.conference.openBridgeChannel) {
    case 'datachannel':
    case true:
    case undefined:
      openSctp = true;
      break;

    case 'websocket':
      openSctp = false;
      break;
  }

  if (openSctp && !_browser["default"].supportsDataChannels()) {
    openSctp = false;
  }

  elem.c('property', {
    name: 'openSctp',
    value: openSctp
  }).up();

  if (this.options.conference.startAudioMuted !== undefined) {
    elem.c('property', {
      name: 'startAudioMuted',
      value: this.options.conference.startAudioMuted
    }).up();
  }

  if (this.options.conference.startVideoMuted !== undefined) {
    elem.c('property', {
      name: 'startVideoMuted',
      value: this.options.conference.startVideoMuted
    }).up();
  }

  if (this.options.conference.stereo !== undefined) {
    elem.c('property', {
      name: 'stereo',
      value: this.options.conference.stereo
    }).up();
  }

  if (this.options.conference.useRoomAsSharedDocumentName !== undefined) {
    elem.c('property', {
      name: 'useRoomAsSharedDocumentName',
      value: this.options.conference.useRoomAsSharedDocumentName
    }).up();
  }

  elem.up();
  return elem;
};

Moderator.prototype.parseSessionId = function (resultIq) {
  // eslint-disable-next-line newline-per-chained-call
  var sessionId = $(resultIq).find('conference').attr('session-id');

  if (sessionId) {
    logger.info("Received sessionId:  ".concat(sessionId));
    _Settings["default"].sessionId = sessionId;
  }
};

Moderator.prototype.parseConfigOptions = function (resultIq) {
  // eslint-disable-next-line newline-per-chained-call
  this.setFocusUserJid($(resultIq).find('conference').attr('focusjid'));
  var authenticationEnabled = $(resultIq).find('>conference>property' + '[name=\'authentication\'][value=\'true\']').length > 0;
  logger.info("Authentication enabled: ".concat(authenticationEnabled));
  this.externalAuthEnabled = $(resultIq).find('>conference>property' + '[name=\'externalAuth\'][value=\'true\']').length > 0;
  logger.info("External authentication enabled: ".concat(this.externalAuthEnabled));

  if (!this.externalAuthEnabled) {
    // We expect to receive sessionId in 'internal' authentication mode
    this.parseSessionId(resultIq);
  } // eslint-disable-next-line newline-per-chained-call


  var authIdentity = $(resultIq).find('>conference').attr('identity');
  this.eventEmitter.emit(AuthenticationEvents.IDENTITY_UPDATED, authenticationEnabled, authIdentity); // Check if focus has auto-detected Jigasi component(this will be also
  // included if we have passed our host from the config)

  if ($(resultIq).find('>conference>property' + '[name=\'sipGatewayEnabled\'][value=\'true\']').length) {
    this.sipGatewayEnabled = true;
  }

  logger.info("Sip gateway enabled:  ".concat(this.sipGatewayEnabled));
}; // FIXME We need to show the fact that we're waiting for the focus to the user
// (or that the focus is not available)

/**
 * Allocates the conference focus.
 *
 * @param {Function} callback - the function to be called back upon the
 * successful allocation of the conference focus
 * @returns {Promise} - Resolved when Jicofo allows to join the room. It's never
 * rejected and it'll keep on pinging Jicofo forever.
 */


Moderator.prototype.allocateConferenceFocus = function () {
  var _this = this;

  return new Promise(function (resolve) {
    // Try to use focus user JID from the config
    _this.setFocusUserJid(_this.options.connection.focusUserJid); // Send create conference IQ


    _this.connection.sendIQ(_this.createConferenceIq(), function (result) {
      return _this._allocateConferenceFocusSuccess(result, resolve);
    }, function (error) {
      return _this._allocateConferenceFocusError(error, resolve);
    }); // XXX We're pressed for time here because we're beginning a complex
    // and/or lengthy conference-establishment process which supposedly
    // involves multiple RTTs. We don't have the time to wait for Strophe to
    // decide to send our IQ.


    _this.connection.flush();
  });
};
/**
 * Invoked by {@link #allocateConferenceFocus} upon its request receiving an
 * error result.
 *
 * @param error - the error result of the request that
 * {@link #allocateConferenceFocus} sent
 * @param {Function} callback - the function to be called back upon the
 * successful allocation of the conference focus
 */


Moderator.prototype._allocateConferenceFocusError = function (error, callback) {
  var _this2 = this;

  // If the session is invalid, remove and try again without session ID to get
  // a new one
  var invalidSession = $(error).find('>error>session-invalid').length || $(error).find('>error>not-acceptable').length;

  if (invalidSession) {
    logger.info('Session expired! - removing');
    _Settings["default"].sessionId = undefined;
  }

  if ($(error).find('>error>graceful-shutdown').length) {
    this.eventEmitter.emit(XMPPEvents.GRACEFUL_SHUTDOWN);
    return;
  } // Check for error returned by the reservation system


  var reservationErr = $(error).find('>error>reservation-error');

  if (reservationErr.length) {
    // Trigger error event
    var errorCode = reservationErr.attr('error-code');
    var errorTextNode = $(error).find('>error>text');
    var errorMsg;

    if (errorTextNode) {
      errorMsg = errorTextNode.text();
    }

    this.eventEmitter.emit(XMPPEvents.RESERVATION_ERROR, errorCode, errorMsg);
    return;
  } // Not authorized to create new room


  if ($(error).find('>error>not-authorized').length) {
    logger.warn('Unauthorized to start the conference', error);

    var toDomain = _strophe.Strophe.getDomainFromJid(error.getAttribute('to'));

    if (toDomain !== this.options.connection.hosts.anonymousdomain) {
      // FIXME "is external" should come either from the focus or
      // config.js
      this.externalAuthEnabled = true;
    }

    this.eventEmitter.emit(XMPPEvents.AUTHENTICATION_REQUIRED);
    return;
  }

  var waitMs = this.getNextErrorTimeout();
  var errmsg = "Focus error, retry after ".concat(waitMs);
  GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));
  logger.error(errmsg, error); // Show message

  var focusComponent = this.getFocusComponent();
  var retrySec = waitMs / 1000; // FIXME: message is duplicated ? Do not show in case of session invalid
  // which means just a retry

  if (!invalidSession) {
    this.eventEmitter.emit(XMPPEvents.FOCUS_DISCONNECTED, focusComponent, retrySec);
  } // Reset response timeout


  this.getNextTimeout(true);
  window.setTimeout(function () {
    return _this2.allocateConferenceFocus().then(callback);
  }, waitMs);
};
/**
 * Invoked by {@link #allocateConferenceFocus} upon its request receiving a
 * success (i.e. non-error) result.
 *
 * @param result - the success (i.e. non-error) result of the request that
 * {@link #allocateConferenceFocus} sent
 * @param {Function} callback - the function to be called back upon the
 * successful allocation of the conference focus
 */


Moderator.prototype._allocateConferenceFocusSuccess = function (result, callback) {
  var _this3 = this;

  // Setup config options
  this.parseConfigOptions(result); // Reset the error timeout (because we haven't failed here).

  this.getNextErrorTimeout(true); // eslint-disable-next-line newline-per-chained-call

  if ($(result).find('conference').attr('ready') === 'true') {
    // Reset the non-error timeout (because we've succeeded here).
    this.getNextTimeout(true); // Exec callback

    callback();
  } else {
    var waitMs = this.getNextTimeout();
    logger.info("Waiting for the focus... ".concat(waitMs));
    window.setTimeout(function () {
      return _this3.allocateConferenceFocus().then(callback);
    }, waitMs);
  }
};

Moderator.prototype.authenticate = function () {
  var _this4 = this;

  return new Promise(function (resolve, reject) {
    _this4.connection.sendIQ(_this4.createConferenceIq(), function (result) {
      _this4.parseSessionId(result);

      resolve();
    }, function (errorIq) {
      return reject({
        error: $(errorIq).find('iq>error :first').prop('tagName'),
        message: $(errorIq).find('iq>error>text').text()
      });
    });
  });
};

Moderator.prototype.getLoginUrl = function (urlCallback, failureCallback) {
  this._getLoginUrl(
  /* popup */
  false, urlCallback, failureCallback);
};
/**
 *
 * @param {boolean} popup false for {@link Moderator#getLoginUrl} or true for
 * {@link Moderator#getPopupLoginUrl}
 * @param urlCb
 * @param failureCb
 */


Moderator.prototype._getLoginUrl = function (popup, urlCb, failureCb) {
  var iq = (0, _strophe.$iq)({
    to: this.getFocusComponent(),
    type: 'get'
  });
  var attrs = {
    xmlns: 'http://jitsi.org/protocol/focus',
    room: this.roomName,
    'machine-uid': _Settings["default"].machineId
  };
  var str = 'auth url'; // for logger

  if (popup) {
    attrs.popup = true;
    str = "POPUP ".concat(str);
  }

  iq.c('login-url', attrs);
  /**
   * Implements a failure callback which reports an error message and an error
   * through (1) GlobalOnErrorHandler, (2) logger, and (3) failureCb.
   *
   * @param {string} errmsg the error messsage to report
   * @param {*} error the error to report (in addition to errmsg)
   */

  function reportError(errmsg, err) {
    GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));
    logger.error(errmsg, err);
    failureCb(err);
  }

  this.connection.sendIQ(iq, function (result) {
    // eslint-disable-next-line newline-per-chained-call
    var url = $(result).find('login-url').attr('url');
    url = decodeURIComponent(url);

    if (url) {
      logger.info("Got ".concat(str, ": ").concat(url));
      urlCb(url);
    } else {
      reportError("Failed to get ".concat(str, " from the focus"), result);
    }
  }, reportError.bind(undefined, "Get ".concat(str, " error")));
};

Moderator.prototype.getPopupLoginUrl = function (urlCallback, failureCallback) {
  this._getLoginUrl(
  /* popup */
  true, urlCallback, failureCallback);
};

Moderator.prototype.logout = function (callback) {
  var iq = (0, _strophe.$iq)({
    to: this.getFocusComponent(),
    type: 'set'
  });
  var sessionId = _Settings["default"].sessionId;

  if (!sessionId) {
    callback();
    return;
  }

  iq.c('logout', {
    xmlns: 'http://jitsi.org/protocol/focus',
    'session-id': sessionId
  });
  this.connection.sendIQ(iq, function (result) {
    // eslint-disable-next-line newline-per-chained-call
    var logoutUrl = $(result).find('logout').attr('logout-url');

    if (logoutUrl) {
      logoutUrl = decodeURIComponent(logoutUrl);
    }

    logger.info("Log out OK, url: ".concat(logoutUrl), result);
    _Settings["default"].sessionId = undefined;
    callback(logoutUrl);
  }, function (error) {
    var errmsg = 'Logout error';
    GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));
    logger.error(errmsg, error);
  });
};
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jitsiMeetLogger = require("jitsi-meet-logger");

var _SdpTransformUtil = require("./SdpTransformUtil");

var _SDPUtil = _interopRequireDefault(require("./SDPUtil"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var logger = (0, _jitsiMeetLogger.getLogger)(__filename);
/**
 * Begin helper functions
 */

/**
 * Updates or inserts the appropriate rtx information for primarySsrc with
 *  the given rtxSsrc.  If no rtx ssrc for primarySsrc currently exists, it will
 *  add the appropriate ssrc and ssrc group lines.  If primarySsrc already has
 *  an rtx ssrc, the appropriate ssrc and group lines will be updated
 * @param {MLineWrap} mLine
 * @param {object} primarySsrcInfo the info (ssrc, msid & cname) for the
 *  primary ssrc
 * @param {number} rtxSsrc the rtx ssrc to associate with the primary ssrc
 */

function updateAssociatedRtxStream(mLine, primarySsrcInfo, rtxSsrc) {
  logger.debug("Updating mline to associate ".concat(rtxSsrc) + "rtx ssrc with primary stream, ".concat(primarySsrcInfo.id));
  var primarySsrc = primarySsrcInfo.id;
  var primarySsrcMsid = primarySsrcInfo.msid;
  var primarySsrcCname = primarySsrcInfo.cname;
  var previousRtxSSRC = mLine.getRtxSSRC(primarySsrc);

  if (previousRtxSSRC === rtxSsrc) {
    logger.debug("".concat(rtxSsrc, " was already associated with ").concat(primarySsrc));
    return;
  }

  if (previousRtxSSRC) {
    logger.debug("".concat(primarySsrc, " was previously associated with rtx") + "".concat(previousRtxSSRC, ", removing all references to it")); // Stream already had an rtx ssrc that is different than the one given,
    //  remove all trace of the old one

    mLine.removeSSRC(previousRtxSSRC);
    logger.debug("groups before filtering for ".concat(previousRtxSSRC));
    logger.debug(mLine.dumpSSRCGroups());
    mLine.removeGroupsWithSSRC(previousRtxSSRC);
  }

  mLine.addSSRCAttribute({
    id: rtxSsrc,
    attribute: 'cname',
    value: primarySsrcCname
  });
  mLine.addSSRCAttribute({
    id: rtxSsrc,
    attribute: 'msid',
    value: primarySsrcMsid
  });
  mLine.addSSRCGroup({
    semantics: 'FID',
    ssrcs: "".concat(primarySsrc, " ").concat(rtxSsrc)
  });
}
/**
 * End helper functions
 */

/**
 * Adds any missing RTX streams for video streams
 *  and makes sure that they remain consistent
 */


var RtxModifier =
/*#__PURE__*/
function () {
  /**
   * Constructor
   */
  function RtxModifier() {
    _classCallCheck(this, RtxModifier);

    /**
     * Map of video ssrc to corresponding RTX
     *  ssrc
     */
    this.correspondingRtxSsrcs = new Map();
  }
  /**
   * Clear the cached map of primary video ssrcs to
   *  their corresponding rtx ssrcs so that they will
   *  not be used for the next call to modifyRtxSsrcs
   */


  _createClass(RtxModifier, [{
    key: "clearSsrcCache",
    value: function clearSsrcCache() {
      this.correspondingRtxSsrcs.clear();
    }
    /**
     * Explicitly set the primary video ssrc -> rtx ssrc
     *  mapping to be used in modifyRtxSsrcs
     * @param {Map} ssrcMapping a mapping of primary video
     *  ssrcs to their corresponding rtx ssrcs
     */

  }, {
    key: "setSsrcCache",
    value: function setSsrcCache(ssrcMapping) {
      logger.debug('Setting ssrc cache to ', ssrcMapping);
      this.correspondingRtxSsrcs = ssrcMapping;
    }
    /**
     * Adds RTX ssrcs for any video ssrcs that don't
     *  already have them.  If the video ssrc has been
     *  seen before, and already had an RTX ssrc generated,
     *  the same RTX ssrc will be used again.
     * @param {string} sdpStr sdp in raw string format
     */

  }, {
    key: "modifyRtxSsrcs",
    value: function modifyRtxSsrcs(sdpStr) {
      var sdpTransformer = new _SdpTransformUtil.SdpTransformWrap(sdpStr);
      var videoMLine = sdpTransformer.selectMedia('video');

      if (!videoMLine) {
        logger.debug("No 'video' media found in the sdp: ".concat(sdpStr));
        return sdpStr;
      }

      return this.modifyRtxSsrcs2(videoMLine) ? sdpTransformer.toRawSDP() : sdpStr;
    }
    /**
     * Does the same thing as {@link modifyRtxSsrcs}, but takes the
     *  {@link MLineWrap} instance wrapping video media as an argument.
     * @param {MLineWrap} videoMLine
     * @return {boolean} <tt>true</tt> if the SDP wrapped by
     *  {@link SdpTransformWrap} has been modified or <tt>false</tt> otherwise.
     */

  }, {
    key: "modifyRtxSsrcs2",
    value: function modifyRtxSsrcs2(videoMLine) {
      if (videoMLine.direction === 'recvonly') {
        logger.debug('RtxModifier doing nothing, video m line is recvonly');
        return false;
      }

      if (videoMLine.getSSRCCount() < 1) {
        logger.debug('RtxModifier doing nothing, no video ssrcs present');
        return false;
      }

      logger.debug('Current ssrc mapping: ', this.correspondingRtxSsrcs);
      var primaryVideoSsrcs = videoMLine.getPrimaryVideoSSRCs();
      logger.debug('Parsed primary video ssrcs ', primaryVideoSsrcs, ' making sure all have rtx streams');
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = primaryVideoSsrcs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var ssrc = _step.value;
          var msid = videoMLine.getSSRCAttrValue(ssrc, 'msid');
          var cname = videoMLine.getSSRCAttrValue(ssrc, 'cname');
          var correspondingRtxSsrc = this.correspondingRtxSsrcs.get(ssrc);

          if (correspondingRtxSsrc) {
            logger.debug('Already have an associated rtx ssrc for' + "video ssrc ".concat(ssrc, ": ").concat(correspondingRtxSsrc));
          } else {
            logger.debug("No previously associated rtx ssrc for video ssrc ".concat(ssrc)); // If there's one in the sdp already for it, we'll just set
            //  that as the corresponding one

            var previousAssociatedRtxStream = videoMLine.getRtxSSRC(ssrc);

            if (previousAssociatedRtxStream) {
              logger.debug("Rtx stream ".concat(previousAssociatedRtxStream, " ") + 'already existed in the sdp as an rtx stream for ' + "".concat(ssrc));
              correspondingRtxSsrc = previousAssociatedRtxStream;
            } else {
              correspondingRtxSsrc = _SDPUtil["default"].generateSsrc();
              logger.debug("Generated rtx ssrc ".concat(correspondingRtxSsrc, " ") + "for ssrc ".concat(ssrc));
            }

            logger.debug("Caching rtx ssrc ".concat(correspondingRtxSsrc, " ") + "for video ssrc ".concat(ssrc));
            this.correspondingRtxSsrcs.set(ssrc, correspondingRtxSsrc);
          }

          updateAssociatedRtxStream(videoMLine, {
            id: ssrc,
            cname: cname,
            msid: msid
          }, correspondingRtxSsrc);
        } // FIXME we're not looking into much details whether the SDP has been
        // modified or not once the precondition requirements are met.

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return true;
    }
    /**
     * Strip all rtx streams from the given sdp
     * @param {string} sdpStr sdp in raw string format
     * @returns {string} sdp string with all rtx streams stripped
     */

  }, {
    key: "stripRtx",
    value: function stripRtx(sdpStr) {
      var sdpTransformer = new _SdpTransformUtil.SdpTransformWrap(sdpStr);
      var videoMLine = sdpTransformer.selectMedia('video');

      if (!videoMLine) {
        logger.debug("No 'video' media found in the sdp: ".concat(sdpStr));
        return sdpStr;
      }

      if (videoMLine.direction === 'recvonly') {
        logger.debug('RtxModifier doing nothing, video m line is recvonly');
        return sdpStr;
      }

      if (videoMLine.getSSRCCount() < 1) {
        logger.debug('RtxModifier doing nothing, no video ssrcs present');
        return sdpStr;
      }

      if (!videoMLine.containsAnySSRCGroups()) {
        logger.debug('RtxModifier doing nothing, ' + 'no video ssrcGroups present');
        return sdpStr;
      }

      var fidGroups = videoMLine.findGroups('FID'); // Remove the fid groups from the mline

      videoMLine.removeGroupsBySemantics('FID'); // Get the rtx ssrcs and remove them from the mline

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = fidGroups[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var fidGroup = _step2.value;
          var rtxSsrc = (0, _SdpTransformUtil.parseSecondarySSRC)(fidGroup);
          videoMLine.removeSSRC(rtxSsrc);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return sdpTransformer.toRawSDP();
    }
  }]);

  return RtxModifier;
}();

exports["default"] = RtxModifier;
"use strict";

var _RtxModifier = _interopRequireDefault(require("./RtxModifier.js"));

var SampleSdpStrings = _interopRequireWildcard(require("./SampleSdpStrings.js"));

var transform = _interopRequireWildcard(require("sdp-transform"));

var _SDPUtil = _interopRequireDefault(require("./SDPUtil"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/* eslint-disable max-len*/

/* eslint-disable no-invalid-this */

/**
 * Returns the number of video ssrcs in the given sdp
 * @param {object} parsedSdp the sdp as parsed by transform.parse
 * @returns {number} the number of video ssrcs in the given sdp
 */
function numVideoSsrcs(parsedSdp) {
  var videoMLine = parsedSdp.media.find(function (m) {
    return m.type === 'video';
  });
  return videoMLine.ssrcs.map(function (ssrcInfo) {
    return ssrcInfo.id;
  }).filter(function (ssrc, index, array) {
    return array.indexOf(ssrc) === index;
  }).length;
}
/**
 * Return the (single) primary video ssrc in the given sdp
 * @param {object} parsedSdp the sdp as parsed by transform.parse
 * @returns {number} the primary video ssrc in the given sdp
 */


function getPrimaryVideoSsrc(parsedSdp) {
  var videoMLine = parsedSdp.media.find(function (m) {
    return m.type === 'video';
  });
  return parseInt(_SDPUtil["default"].parsePrimaryVideoSsrc(videoMLine), 10);
}
/**
 * Get the primary video ssrc(s) in the given sdp.
 * Only handles parsing 2 scenarios right now:
 * 1) Single video ssrc
 * 2) Multiple video ssrcs in a single simulcast group
 * @param {object} parsedSdp the sdp as parsed by transform.parse
 * @returns {list<number>} the primary video ssrcs in the given sdp
 */


function getPrimaryVideoSsrcs(parsedSdp) {
  var videoMLine = parsedSdp.media.find(function (m) {
    return m.type === 'video';
  });

  if (numVideoSsrcs(parsedSdp) === 1) {
    return [videoMLine.ssrcs[0].id];
  }

  var simGroups = getVideoGroups(parsedSdp, 'SIM');

  if (simGroups.length > 1) {
    return;
  }

  var simGroup = simGroups[0];
  return _SDPUtil["default"].parseGroupSsrcs(simGroup);
}
/**
 * Get the video groups that match the passed semantics from the
 *  given sdp
 * @param {object} parsedSDp the sdp as parsed by transform.parse
 * @param {string} groupSemantics the semantics string of the groups
 *  the caller is interested in
 * @returns {list<object>} a list of the groups from the given sdp
 *  that matched the passed semantics
 */


function getVideoGroups(parsedSdp, groupSemantics) {
  var videoMLine = parsedSdp.media.find(function (m) {
    return m.type === 'video';
  });
  videoMLine.ssrcGroups = videoMLine.ssrcGroups || [];
  return videoMLine.ssrcGroups.filter(function (g) {
    return g.semantics === groupSemantics;
  });
}

describe('RtxModifier', function () {
  beforeEach(function () {
    this.rtxModifier = new _RtxModifier["default"]();
    this.transform = transform;
    this.SDPUtil = _SDPUtil["default"];
  });
  describe('modifyRtxSsrcs', function () {
    describe('when given an sdp with a single video ssrc', function () {
      beforeEach(function () {
        this.singleVideoSdp = SampleSdpStrings.plainVideoSdp;
        this.primaryVideoSsrc = getPrimaryVideoSsrc(this.singleVideoSdp);
      });
      it('should add a single rtx ssrc', function () {
        // Call rtxModifier.modifyRtxSsrcs with an sdp that contains a single video
        //  ssrc.  The returned sdp should have an rtx ssrc and an fid group.
        var newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(this.singleVideoSdp));
        var newSdp = transform.parse(newSdpStr);
        var newPrimaryVideoSsrc = getPrimaryVideoSsrc(newSdp);
        expect(newPrimaryVideoSsrc).toEqual(this.primaryVideoSsrc); // Should now have an rtx ssrc as well

        expect(numVideoSsrcs(newSdp)).toEqual(2); // Should now have an FID group

        var fidGroups = getVideoGroups(newSdp, 'FID');
        expect(fidGroups.length).toEqual(1);
        var fidGroup = fidGroups[0];

        var fidGroupPrimarySsrc = _SDPUtil["default"].parseGroupSsrcs(fidGroup)[0];

        expect(fidGroupPrimarySsrc).toEqual(this.primaryVideoSsrc);
      });
      it('should re-use the same rtx ssrc for a primary ssrc it\'s seen before', function () {
        // Have rtxModifier generate an rtx ssrc via modifyRtxSsrcs.  Then call it again
        //  with the same primary ssrc in the sdp (but no rtx ssrc).  It should use
        //  the same rtx ssrc as before.
        var newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(this.singleVideoSdp));
        var newSdp = transform.parse(newSdpStr);
        var fidGroup = getVideoGroups(newSdp, 'FID')[0];

        var fidGroupRtxSsrc = _SDPUtil["default"].parseGroupSsrcs(fidGroup)[1]; // Now pass the original sdp through again


        newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(this.singleVideoSdp));
        newSdp = transform.parse(newSdpStr);
        fidGroup = getVideoGroups(newSdp, 'FID')[0];

        var newFidGroupRtxSsrc = _SDPUtil["default"].parseGroupSsrcs(fidGroup)[1];

        expect(newFidGroupRtxSsrc).toEqual(fidGroupRtxSsrc);
      });
      it('should NOT re-use the same rtx ssrc for a primary ssrc it\'s seen before if the cache has been cleared', function () {
        // Call modifyRtxSsrcs to generate an rtx ssrc
        // Clear the rtxModifier cache
        // Call modifyRtxSsrcs to generate an rtx ssrc again with the same primary ssrc
        // --> We should get a different rtx ssrc
        var newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(this.singleVideoSdp));
        var newSdp = transform.parse(newSdpStr);
        var fidGroup = getVideoGroups(newSdp, 'FID')[0];

        var fidGroupRtxSsrc = _SDPUtil["default"].parseGroupSsrcs(fidGroup)[1];

        this.rtxModifier.clearSsrcCache(); // Now pass the original sdp through again

        newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(this.singleVideoSdp));
        newSdp = transform.parse(newSdpStr);
        fidGroup = getVideoGroups(newSdp, 'FID')[0];

        var newFidGroupRtxSsrc = _SDPUtil["default"].parseGroupSsrcs(fidGroup)[1];

        expect(newFidGroupRtxSsrc).not.toEqual(fidGroupRtxSsrc);
      });
      it('should use the rtx ssrc from the cache when the cache has been manually set', function () {
        // Manually set an rtx ssrc mapping in the cache
        // Call modifyRtxSsrcs
        // -->The rtx ssrc used should be the one we set
        var forcedRtxSsrc = 123456;
        var ssrcCache = new Map();
        ssrcCache.set(this.primaryVideoSsrc, forcedRtxSsrc);
        this.rtxModifier.setSsrcCache(ssrcCache);
        var newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(this.singleVideoSdp));
        var newSdp = transform.parse(newSdpStr);
        var fidGroup = getVideoGroups(newSdp, 'FID')[0];

        var fidGroupRtxSsrc = _SDPUtil["default"].parseGroupSsrcs(fidGroup)[1];

        expect(fidGroupRtxSsrc).toEqual(forcedRtxSsrc);
      });
    });
    describe('when given an sdp with multiple video ssrcs', function () {
      beforeEach(function () {
        this.multipleVideoSdp = SampleSdpStrings.simulcastSdp;
        this.primaryVideoSsrcs = getPrimaryVideoSsrcs(this.multipleVideoSdp);
      });
      it('should add rtx ssrcs for all of them', function () {
        var _this = this;

        // Call rtxModifier.modifyRtxSsrcs with an sdp that contains multiple video
        //  ssrcs.  The returned sdp should have an rtx ssrc and an fid group for all of them.
        var newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(this.multipleVideoSdp));
        var newSdp = transform.parse(newSdpStr);
        var newPrimaryVideoSsrcs = getPrimaryVideoSsrcs(newSdp);
        expect(newPrimaryVideoSsrcs).toEqual(this.primaryVideoSsrcs); // Should now have rtx ssrcs as well

        expect(numVideoSsrcs(newSdp)).toEqual(this.primaryVideoSsrcs.length * 2); // Should now have FID groups

        var fidGroups = getVideoGroups(newSdp, 'FID');
        expect(fidGroups.length).toEqual(this.primaryVideoSsrcs.length);
        fidGroups.forEach(function (fidGroup) {
          var fidGroupPrimarySsrc = _SDPUtil["default"].parseGroupSsrcs(fidGroup)[0];

          expect(_this.primaryVideoSsrcs.indexOf(fidGroupPrimarySsrc)).not.toEqual(-1);
        });
      });
      it('should re-use the same rtx ssrcs for any primary ssrc it\'s seen before', function () {
        // Have rtxModifier generate an rtx ssrc via modifyRtxSsrcs.  Then call it again
        //  with the same primary ssrc in the sdp (but no rtx ssrc).  It should use
        //  the same rtx ssrc as before.
        var newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(this.multipleVideoSdp));
        var newSdp = transform.parse(newSdpStr);
        var rtxMapping = new Map();
        var fidGroups = getVideoGroups(newSdp, 'FID'); // Save the first mapping that is made

        fidGroups.forEach(function (fidGroup) {
          var fidSsrcs = _SDPUtil["default"].parseGroupSsrcs(fidGroup);

          var fidGroupPrimarySsrc = fidSsrcs[0];
          var fidGroupRtxSsrc = fidSsrcs[1];
          rtxMapping.set(fidGroupPrimarySsrc, fidGroupRtxSsrc);
        }); // Now pass the original sdp through again and make sure we get the same mapping

        newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(this.multipleVideoSdp));
        newSdp = transform.parse(newSdpStr);
        fidGroups = getVideoGroups(newSdp, 'FID');
        fidGroups.forEach(function (fidGroup) {
          var fidSsrcs = _SDPUtil["default"].parseGroupSsrcs(fidGroup);

          var fidGroupPrimarySsrc = fidSsrcs[0];
          var fidGroupRtxSsrc = fidSsrcs[1];
          expect(rtxMapping.has(fidGroupPrimarySsrc)).toBe(true);
          expect(rtxMapping.get(fidGroupPrimarySsrc)).toEqual(fidGroupRtxSsrc);
        });
      });
      it('should NOT re-use the same rtx ssrcs for any primary ssrc it\'s seen before if the cache has been cleared', function () {
        // Call modifyRtxSsrcs to generate an rtx ssrc
        // Clear the rtxModifier cache
        // Call modifyRtxSsrcs to generate rtx ssrcs again with the same primary ssrcs
        // --> We should get different rtx ssrcs
        var newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(this.multipleVideoSdp));
        var newSdp = transform.parse(newSdpStr);
        var rtxMapping = new Map();
        var fidGroups = getVideoGroups(newSdp, 'FID'); // Save the first mapping that is made

        fidGroups.forEach(function (fidGroup) {
          var fidSsrcs = _SDPUtil["default"].parseGroupSsrcs(fidGroup);

          var fidGroupPrimarySsrc = fidSsrcs[0];
          var fidGroupRtxSsrc = fidSsrcs[1];
          rtxMapping.set(fidGroupPrimarySsrc, fidGroupRtxSsrc);
        });
        this.rtxModifier.clearSsrcCache(); // Now pass the original sdp through again and make sure we get the same mapping

        newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(this.multipleVideoSdp));
        newSdp = transform.parse(newSdpStr);
        fidGroups = getVideoGroups(newSdp, 'FID');
        fidGroups.forEach(function (fidGroup) {
          var fidSsrcs = _SDPUtil["default"].parseGroupSsrcs(fidGroup);

          var fidGroupPrimarySsrc = fidSsrcs[0];
          var fidGroupRtxSsrc = fidSsrcs[1];
          expect(rtxMapping.has(fidGroupPrimarySsrc)).toBe(true);
          expect(rtxMapping.get(fidGroupPrimarySsrc)).not.toEqual(fidGroupRtxSsrc);
        });
      });
      it('should use the rtx ssrcs from the cache when the cache has been manually set', function () {
        // Manually set an rtx ssrc mapping in the cache
        // Call modifyRtxSsrcs
        // -->The rtx ssrc used should be the one we set
        var rtxMapping = new Map();
        this.primaryVideoSsrcs.forEach(function (ssrc) {
          rtxMapping.set(ssrc, _SDPUtil["default"].generateSsrc());
        });
        this.rtxModifier.setSsrcCache(rtxMapping);
        var newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(this.multipleVideoSdp));
        var newSdp = transform.parse(newSdpStr);
        var fidGroups = getVideoGroups(newSdp, 'FID');
        fidGroups.forEach(function (fidGroup) {
          var fidSsrcs = _SDPUtil["default"].parseGroupSsrcs(fidGroup);

          var fidGroupPrimarySsrc = fidSsrcs[0];
          var fidGroupRtxSsrc = fidSsrcs[1];
          expect(rtxMapping.has(fidGroupPrimarySsrc)).toBe(true);
          expect(rtxMapping.get(fidGroupPrimarySsrc)).toEqual(fidGroupRtxSsrc);
        });
      });
    });
    describe('when given an sdp with a flexfec stream', function () {
      it('should not add rtx for the flexfec ssrc', function () {
        var flexFecSdp = SampleSdpStrings.flexFecSdp;
        var newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(flexFecSdp));
        var newSdp = transform.parse(newSdpStr);
        var fidGroups = getVideoGroups(newSdp, 'FID');
        expect(fidGroups.length).toEqual(1);
      });
    });
    describe('(corner cases)', function () {
      it('should handle a recvonly video mline', function () {
        var sdp = SampleSdpStrings.plainVideoSdp;
        var videoMLine = sdp.media.find(function (m) {
          return m.type === 'video';
        });
        videoMLine.direction = 'recvonly';
        var newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(sdp));
        expect(newSdpStr).toEqual(this.transform.write(sdp));
      });
      it('should handle a video mline with no video ssrcs', function () {
        var sdp = SampleSdpStrings.plainVideoSdp;
        var videoMLine = sdp.media.find(function (m) {
          return m.type === 'video';
        });
        videoMLine.ssrcs = [];
        var newSdpStr = this.rtxModifier.modifyRtxSsrcs(this.transform.write(sdp));
        expect(newSdpStr).toEqual(this.transform.write(sdp));
      });
    });
  });
  describe('stripRtx', function () {
    beforeEach(function () {}); // eslint-disable-line no-empty-function

    it('should strip all rtx streams from an sdp with rtx', function () {
      var sdpStr = transform.write(SampleSdpStrings.rtxVideoSdp);
      var newSdpStr = this.rtxModifier.stripRtx(sdpStr);
      var newSdp = transform.parse(newSdpStr);
      var fidGroups = getVideoGroups(newSdp, 'FID');
      expect(fidGroups.length).toEqual(0);
      expect(numVideoSsrcs(newSdp)).toEqual(1);
    });
    it('should do nothing to an sdp with no rtx', function () {
      var sdpStr = transform.write(SampleSdpStrings.plainVideoSdp);
      var newSdpStr = this.rtxModifier.stripRtx(sdpStr);
      expect(newSdpStr).toEqual(sdpStr);
    });
  });
});
/* eslint-enable no-invalid-this */

/* eslint-enable max-len*/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flexFecSdp = exports.multiCodecVideoSdp = exports.rtxVideoSdp = exports.plainVideoSdp = exports.simulcastRtxSdp = exports.simulcastSdp = void 0;

var transform = _interopRequireWildcard(require("sdp-transform"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable max-len*/
// A generic sdp session block
var baseSessionSdp = '' + 'v=0\r\n' + 'o=- 814997227879783433 5 IN IP4 127.0.0.1\r\n' + 's=-\r\n' + 't=0 0\r\n' + 'a=msid-semantic: WMS 0836cc8e-a7bb-47e9-affb-0599414bc56d\r\n' + 'a=group:BUNDLE audio video data\r\n'; // A basic sdp audio mline with a single stream

var baseAudioMLineSdp = '' + 'm=audio 54405 RTP/SAVPF 111 103 104 126\r\n' + 'c=IN IP4 172.29.32.39\r\n' + 'a=rtpmap:111 opus/48000/2\r\n' + 'a=rtpmap:103 ISAC/16000\r\n' + 'a=rtpmap:104 ISAC/32000\r\n' + 'a=rtpmap:126 telephone-event/8000\r\n' + 'a=fmtp:111 minptime=10;useinbandfec=1\r\n' + 'a=rtcp:9 IN IP4 0.0.0.0\r\n' + 'a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level\r\n' + 'a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\r\n' + 'a=setup:passive\r\n' + 'a=mid:audio\r\n' + 'a=sendrecv\r\n' + 'a=ice-ufrag:adPg\r\n' + 'a=ice-pwd:Xsr05Mq8S7CR44DAnusZE26F\r\n' + 'a=fingerprint:sha-256 6A:39:DE:11:24:AD:2E:4E:63:D6:69:D3:85:05:53:C7:3C:38:A4:B7:91:74:C0:91:44:FC:94:63:7F:01:AB:A9\r\n' + 'a=candidate:1581043602 1 udp 2122260223 172.29.32.39 54405 typ host generation 0\r\n' + 'a=ssrc:124723944 cname:peDGrDD6WsxUOki/\r\n' + 'a=ssrc:124723944 msid:dcbb0236-cea5-402e-9e9a-595c65ffcc2a 40abf2d3-a415-4c68-8c17-2a038e8bebcf\r\n' + 'a=ssrc:124723944 mslabel:dcbb0236-cea5-402e-9e9a-595c65ffcc2a\r\n' + 'a=ssrc:124723944 label:40abf2d3-a415-4c68-8c17-2a038e8bebcf\r\n' + 'a=rtcp-mux\r\n'; // A basic sdp application mline

var baseDataMLineSdp = '' + 'm=application 9 DTLS/SCTP 5000\r\n' + 'c=IN IP4 0.0.0.0\r\n' + 'b=AS:30\r\n' + 'a=setup:passive\r\n' + 'a=mid:data\r\n' + 'a=ice-ufrag:adPg\r\n' + 'a=ice-pwd:Xsr05Mq8S7CR44DAnusZE26F\r\n' + 'a=fingerprint:sha-256 6A:39:DE:11:24:AD:2E:4E:63:D6:69:D3:85:05:53:C7:3C:38:A4:B7:91:74:C0:91:44:FC:94:63:7F:01:AB:A9\r\n' + 'a=sctpmap:5000 webrtc-datachannel 1024\r\n'; // A basic sdp video mline with a single stream

var plainVideoMLineSdp = '' + 'm=video 9 RTP/SAVPF 100\r\n' + 'c=IN IP4 0.0.0.0\r\n' + 'a=rtpmap:100 VP8/90000\r\n' + 'a=rtcp:9 IN IP4 0.0.0.0\r\n' + 'a=rtcp-fb:100 ccm fir\r\n' + 'a=rtcp-fb:100 nack\r\n' + 'a=rtcp-fb:100 nack pli\r\n' + 'a=rtcp-fb:100 goog-remb\r\n' + 'a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\r\n' + 'a=setup:passive\r\n' + 'a=mid:video\r\n' + 'a=sendrecv\r\n' + 'a=ice-ufrag:adPg\r\n' + 'a=ice-pwd:Xsr05Mq8S7CR44DAnusZE26F\r\n' + 'a=fingerprint:sha-256 6A:39:DE:11:24:AD:2E:4E:63:D6:69:D3:85:05:53:C7:3C:38:A4:B7:91:74:C0:91:44:FC:94:63:7F:01:AB:A9\r\n' + 'a=ssrc:1757014965 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:1757014965 cname:peDGrDD6WsxUOki/\r\n' + 'a=rtcp-mux\r\n'; // A basic sdp video mline with a single stream and multiple codecs

var multiCodecVideoMLine = '' + 'm=video 9 RTP/SAVPF 100 126 97\r\n' + 'c=IN IP4 0.0.0.0\r\n' + 'a=rtpmap:100 VP8/90000\r\n' + 'a=rtpmap:126 H264/90000\r\n' + 'a=rtpmap:97 H264/90000\r\n' + 'a=rtcp:9 IN IP4 0.0.0.0\r\n' + 'a=rtcp-fb:100 ccm fir\r\n' + 'a=rtcp-fb:100 nack\r\n' + 'a=rtcp-fb:100 nack pli\r\n' + 'a=rtcp-fb:100 goog-remb\r\n' + 'a=fmtp:126 profile-level-id=42e01f;level-asymmetry-allowed=1;packetization-mode=1\r\n' + 'a=fmtp:97 profile-level-id=42e01f;level-asymmetry-allowed=1\r\n' + 'a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\r\n' + 'a=setup:passive\r\n' + 'a=mid:video\r\n' + 'a=sendrecv\r\n' + 'a=ice-ufrag:adPg\r\n' + 'a=ice-pwd:Xsr05Mq8S7CR44DAnusZE26F\r\n' + 'a=fingerprint:sha-256 6A:39:DE:11:24:AD:2E:4E:63:D6:69:D3:85:05:53:C7:3C:38:A4:B7:91:74:C0:91:44:FC:94:63:7F:01:AB:A9\r\n' + 'a=ssrc:1757014965 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:1757014965 cname:peDGrDD6WsxUOki/\r\n' + 'a=rtcp-mux\r\n'; // An sdp video mline with 3 simulcast streams

var simulcastVideoMLineSdp = '' + 'm=video 9 RTP/SAVPF 100\r\n' + 'c=IN IP4 0.0.0.0\r\n' + 'a=rtpmap:100 VP8/90000\r\n' + 'a=rtcp:9 IN IP4 0.0.0.0\r\n' + 'a=rtcp-fb:100 ccm fir\r\n' + 'a=rtcp-fb:100 nack\r\n' + 'a=rtcp-fb:100 nack pli\r\n' + 'a=rtcp-fb:100 goog-remb\r\n' + 'a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\r\n' + 'a=setup:passive\r\n' + 'a=mid:video\r\n' + 'a=sendrecv\r\n' + 'a=ice-ufrag:adPg\r\n' + 'a=ice-pwd:Xsr05Mq8S7CR44DAnusZE26F\r\n' + 'a=fingerprint:sha-256 6A:39:DE:11:24:AD:2E:4E:63:D6:69:D3:85:05:53:C7:3C:38:A4:B7:91:74:C0:91:44:FC:94:63:7F:01:AB:A9\r\n' + 'a=ssrc:1757014965 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:1757014965 cname:peDGrDD6WsxUOki/\r\n' + 'a=ssrc:1479742055 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:1479742055 cname:peDGrDD6WsxUOki/\r\n' + 'a=ssrc:1089111804 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:1089111804 cname:peDGrDD6WsxUOki/\r\n' + 'a=ssrc-group:SIM 1757014965 1479742055 1089111804\r\n' + 'a=rtcp-mux\r\n'; // An sdp video mline with a single video stream and a
//  corresponding rtx stream

var rtxVideoMLineSdp = '' + 'm=video 9 RTP/SAVPF 100 96\r\n' + 'c=IN IP4 0.0.0.0\r\n' + 'a=rtpmap:100 VP8/90000\r\n' + 'a=fmtp:96 apt=100\r\n' + 'a=rtcp:9 IN IP4 0.0.0.0\r\n' + 'a=rtcp-fb:100 ccm fir\r\n' + 'a=rtcp-fb:100 nack\r\n' + 'a=rtcp-fb:100 nack pli\r\n' + 'a=rtcp-fb:100 goog-remb\r\n' + 'a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\r\n' + 'a=setup:passive\r\n' + 'a=mid:video\r\n' + 'a=sendrecv\r\n' + 'a=ice-ufrag:adPg\r\n' + 'a=ice-pwd:Xsr05Mq8S7CR44DAnusZE26F\r\n' + 'a=fingerprint:sha-256 6A:39:DE:11:24:AD:2E:4E:63:D6:69:D3:85:05:53:C7:3C:38:A4:B7:91:74:C0:91:44:FC:94:63:7F:01:AB:A9\r\n' + 'a=ssrc:1757014965 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:1757014965 cname:peDGrDD6WsxUOki/\r\n' + 'a=ssrc:984899560 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:984899560 cname:peDGrDD6WsxUOki/\r\n' + 'a=ssrc-group:FID 1757014965 984899560\r\n' + 'a=rtcp-mux\r\n'; // An sdp video mline with 3 simulcast streams and 3 rtx streams

var simulcastRtxVideoMLineSdp = '' + 'm=video 9 RTP/SAVPF 100 96\r\n' + 'c=IN IP4 0.0.0.0\r\n' + 'a=rtpmap:100 VP8/90000\r\n' + 'a=fmtp:96 apt=100\r\n' + 'a=rtcp:9 IN IP4 0.0.0.0\r\n' + 'a=rtcp-fb:100 ccm fir\r\n' + 'a=rtcp-fb:100 nack\r\n' + 'a=rtcp-fb:100 nack pli\r\n' + 'a=rtcp-fb:100 goog-remb\r\n' + 'a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\r\n' + 'a=setup:passive\r\n' + 'a=mid:video\r\n' + 'a=sendrecv\r\n' + 'a=ice-ufrag:adPg\r\n' + 'a=ice-pwd:Xsr05Mq8S7CR44DAnusZE26F\r\n' + 'a=fingerprint:sha-256 6A:39:DE:11:24:AD:2E:4E:63:D6:69:D3:85:05:53:C7:3C:38:A4:B7:91:74:C0:91:44:FC:94:63:7F:01:AB:A9\r\n' + 'a=ssrc:1757014965 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:1757014965 cname:peDGrDD6WsxUOki/\r\n' + 'a=ssrc:1479742055 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:1479742055 cname:peDGrDD6WsxUOki/\r\n' + 'a=ssrc:1089111804 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:1089111804 cname:peDGrDD6WsxUOki/\r\n' + 'a=ssrc:855213044 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:855213044 cname:peDGrDD6WsxUOki/\r\n' + 'a=ssrc:984899560 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:984899560 cname:peDGrDD6WsxUOki/\r\n' + 'a=ssrc:2963867077 msid:0836cc8e-a7bb-47e9-affb-0599414bc56d bdbd2c0a-7959-4578-8db5-9a6a1aec4ecf\r\n' + 'a=ssrc:2963867077 cname:peDGrDD6WsxUOki/\r\n' + 'a=ssrc-group:FID 1757014965 984899560\r\n' + 'a=ssrc-group:FID 1479742055 855213044\r\n' + 'a=ssrc-group:FID 1089111804 2963867077\r\n' + 'a=ssrc-group:SIM 1757014965 1479742055 1089111804\r\n' + 'a=rtcp-mux\r\n'; // An sdp video mline with 1 video ssrc, 1 video rtx ssrc and one flexfec ssrc

var flexFecVideoMLineSdp = '' + 'm=video 9 RTP/SAVPF 100 107 101 96 99 97 109\r\n' + 'c=IN IP4 0.0.0.0\r\n' + 'a=rtcp:9 IN IP4 0.0.0.0\r\n' + 'a=ice-ufrag:aLBh\r\n' + 'a=ice-pwd:7IeqrWG5ryCW2X47Lso8XYdK\r\n' + 'a=ice-options:trickle\r\n' + 'a=fingerprint:sha-256 78:3C:F9:96:85:FB:20:25:F8:2F:AB:37:8B:8B:17:29:EF:54:7B:7C:17:2E:90:02:8A:A1:8F:A7:F9:C5:F2:90\r\n' + 'a=setup:active\r\n' + 'a=mid:video\r\n' + 'a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\r\n' + 'a=sendrecv\r\n' + 'a=rtcp-mux\r\n' + 'a=rtpmap:100 VP8/90000\r\n' + 'a=rtcp-fb:100 goog-remb\r\n' + 'a=rtcp-fb:100 ccm fir\r\n' + 'a=rtcp-fb:100 nack\r\n' + 'a=rtcp-fb:100 nack pli\r\n' + 'a=rtpmap:107 h264/90000\r\n' + 'a=rtcp-fb:107 goog-remb\r\n' + 'a=rtcp-fb:107 ccm fir\r\n' + 'a=rtcp-fb:107 nack\r\n' + 'a=rtcp-fb:107 nack pli\r\n' + 'a=fmtp:107 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\r\n' + 'a=rtpmap:101 VP9/90000\r\n' + 'a=rtcp-fb:101 goog-remb\r\n' + 'a=rtcp-fb:101 ccm fir\r\n' + 'a=rtcp-fb:101 nack\r\n' + 'a=rtcp-fb:101 nack pli\r\n' + 'a=rtpmap:96 rtx/90000\r\n' + 'a=fmtp:96 apt=100\r\n' + 'a=rtpmap:99 rtx/90000\r\n' + 'a=fmtp:99 apt=107\r\n' + 'a=rtpmap:97 rtx/90000\r\n' + 'a=fmtp:97 apt=101\r\n' + 'a=rtpmap:109 flexfec-03/90000\r\n' + 'a=fmtp:109 repair-window=10000000\r\n' + 'a=ssrc-group:FID 2864950112 2236303754\r\n' + 'a=ssrc-group:FEC-FR 2864950112 116623191\r\n' + 'a=ssrc:2864950112 cname:mT86hcsCZwQBPh6R\r\n' + 'a=ssrc:2864950112 msid:a2548ae2-32e8-4b09-89bc-b11f3e49ac5a b3e3d760-6b1b-48bd-8519-9d6261311d28\r\n' + 'a=ssrc:2864950112 mslabel:a2548ae2-32e8-4b09-89bc-b11f3e49ac5a\r\n' + 'a=ssrc:2864950112 label:b3e3d760-6b1b-48bd-8519-9d6261311d28\r\n' + 'a=ssrc:2236303754 cname:mT86hcsCZwQBPh6R\r\n' + 'a=ssrc:2236303754 msid:a2548ae2-32e8-4b09-89bc-b11f3e49ac5a b3e3d760-6b1b-48bd-8519-9d6261311d28\r\n' + 'a=ssrc:2236303754 mslabel:a2548ae2-32e8-4b09-89bc-b11f3e49ac5a\r\n' + 'a=ssrc:2236303754 label:b3e3d760-6b1b-48bd-8519-9d6261311d28\r\n' + 'a=ssrc:116623191 cname:mT86hcsCZwQBPh6R\r\n' + 'a=ssrc:116623191 msid:a2548ae2-32e8-4b09-89bc-b11f3e49ac5a b3e3d760-6b1b-48bd-8519-9d6261311d28\r\n' + 'a=ssrc:116623191 mslabel:a2548ae2-32e8-4b09-89bc-b11f3e49ac5a\r\n' + 'a=ssrc:116623191 label:b3e3d760-6b1b-48bd-8519-9d6261311d28\r\n' + 'm=application 9 DTLS/SCTP 5000\r\n' + 'c=IN IP4 0.0.0.0\r\n' + 'b=AS:30\r\n' + 'a=ice-ufrag:aLBh\r\n' + 'a=ice-pwd:7IeqrWG5ryCW2X47Lso8XYdK\r\n' + 'a=ice-options:trickle\r\n' + 'a=fingerprint:sha-256 78:3C:F9:96:85:FB:20:25:F8:2F:AB:37:8B:8B:17:29:EF:54:7B:7C:17:2E:90:02:8A:A1:8F:A7:F9:C5:F2:90\r\n' + 'a=setup:active\r\n' + 'a=mid:data\r\n' + 'a=sctpmap:5000 webrtc-datachannel 1024\r\n'; // A full sdp string representing a client doing simulcast

var simulcastSdpStr = baseSessionSdp + baseAudioMLineSdp + simulcastVideoMLineSdp + baseDataMLineSdp; // A full sdp string representing a client doing simulcast and rtx

var simulcastRtxSdpStr = baseSessionSdp + baseAudioMLineSdp + simulcastRtxVideoMLineSdp + baseDataMLineSdp; // A full sdp string representing a client doing a single video stream

var plainVideoSdpStr = baseSessionSdp + baseAudioMLineSdp + plainVideoMLineSdp + baseDataMLineSdp; // A full sdp string representing a client doing a single video stream with rtx

var rtxVideoSdpStr = baseSessionSdp + baseAudioMLineSdp + rtxVideoMLineSdp + baseDataMLineSdp; // A full sdp string representing a client doing a single video stream with multiple codec options

var multiCodecVideoSdpStr = baseSessionSdp + baseAudioMLineSdp + multiCodecVideoMLine + baseDataMLineSdp; // A full sdp string representing a client doing a single video stream with flexfec

var flexFecSdpStr = baseSessionSdp + baseAudioMLineSdp + flexFecVideoMLineSdp + baseDataMLineSdp;
var simulcastSdp = transform.parse(simulcastSdpStr);
exports.simulcastSdp = simulcastSdp;
var simulcastRtxSdp = transform.parse(simulcastRtxSdpStr);
exports.simulcastRtxSdp = simulcastRtxSdp;
var plainVideoSdp = transform.parse(plainVideoSdpStr);
exports.plainVideoSdp = plainVideoSdp;
var rtxVideoSdp = transform.parse(rtxVideoSdpStr);
exports.rtxVideoSdp = rtxVideoSdp;
var multiCodecVideoSdp = transform.parse(multiCodecVideoSdpStr);
exports.multiCodecVideoSdp = multiCodecVideoSdp;
var flexFecSdp = transform.parse(flexFecSdpStr);
/* eslint-enable max-len*/

exports.flexFecSdp = flexFecSdp;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = SDP;

var _SDPUtil = _interopRequireDefault(require("./SDPUtil"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 *
 * @param sdp
 */
function SDP(sdp) {
  var media = sdp.split('\r\nm=');

  for (var i = 1, length = media.length; i < length; i++) {
    var mediaI = "m=".concat(media[i]);

    if (i !== length - 1) {
      mediaI += '\r\n';
    }

    media[i] = mediaI;
  }

  var session = "".concat(media.shift(), "\r\n");
  this.media = media;
  this.raw = session + media.join('');
  this.session = session;
}
/**
 * A flag will make {@link transportToJingle} and {@link jingle2media} replace
 * ICE candidates IPs with invalid value of '1.1.1.1' which will cause ICE
 * failure. The flag is used in the automated testing.
 * @type {boolean}
 */


SDP.prototype.failICE = false;
/**
 * Whether or not to remove TCP ice candidates when translating from/to jingle.
 * @type {boolean}
 */

SDP.prototype.removeTcpCandidates = false;
/**
 * Whether or not to remove UDP ice candidates when translating from/to jingle.
 * @type {boolean}
 */

SDP.prototype.removeUdpCandidates = false;
/**
 * Returns map of MediaChannel mapped per channel idx.
 */

SDP.prototype.getMediaSsrcMap = function () {
  var self = this;
  var mediaSSRCs = {};
  var tmp;

  var _loop = function _loop(mediaindex) {
    tmp = _SDPUtil["default"].findLines(self.media[mediaindex], 'a=ssrc:');

    var mid = _SDPUtil["default"].parseMID(_SDPUtil["default"].findLine(self.media[mediaindex], 'a=mid:'));

    var media = {
      mediaindex: mediaindex,
      mid: mid,
      ssrcs: {},
      ssrcGroups: []
    };
    mediaSSRCs[mediaindex] = media;
    tmp.forEach(function (line) {
      var linessrc = line.substring(7).split(' ')[0]; // allocate new ChannelSsrc

      if (!media.ssrcs[linessrc]) {
        media.ssrcs[linessrc] = {
          ssrc: linessrc,
          lines: []
        };
      }

      media.ssrcs[linessrc].lines.push(line);
    });
    tmp = _SDPUtil["default"].findLines(self.media[mediaindex], 'a=ssrc-group:');
    tmp.forEach(function (line) {
      var idx = line.indexOf(' ');
      var semantics = line.substr(0, idx).substr(13);
      var ssrcs = line.substr(14 + semantics.length).split(' ');

      if (ssrcs.length) {
        media.ssrcGroups.push({
          semantics: semantics,
          ssrcs: ssrcs
        });
      }
    });
  };

  for (var mediaindex = 0; mediaindex < self.media.length; mediaindex++) {
    _loop(mediaindex);
  }

  return mediaSSRCs;
};
/**
 * Returns <tt>true</tt> if this SDP contains given SSRC.
 * @param ssrc the ssrc to check.
 * @returns {boolean} <tt>true</tt> if this SDP contains given SSRC.
 */


SDP.prototype.containsSSRC = function (ssrc) {
  // FIXME this code is really strange - improve it if you can
  var medias = this.getMediaSsrcMap();
  var result = false;
  Object.keys(medias).forEach(function (mediaindex) {
    if (result) {
      return;
    }

    if (medias[mediaindex].ssrcs[ssrc]) {
      result = true;
    }
  });
  return result;
}; // remove iSAC and CN from SDP


SDP.prototype.mangle = function () {
  var i, j, lines, mline, newdesc, rtpmap;

  for (i = 0; i < this.media.length; i++) {
    lines = this.media[i].split('\r\n');
    lines.pop(); // remove empty last element

    mline = _SDPUtil["default"].parseMLine(lines.shift());

    if (mline.media !== 'audio') {
      continue; // eslint-disable-line no-continue
    }

    newdesc = '';
    mline.fmt.length = 0;

    for (j = 0; j < lines.length; j++) {
      if (lines[j].substr(0, 9) === 'a=rtpmap:') {
        rtpmap = _SDPUtil["default"].parseRTPMap(lines[j]);

        if (rtpmap.name === 'CN' || rtpmap.name === 'ISAC') {
          continue; // eslint-disable-line no-continue
        }

        mline.fmt.push(rtpmap.id);
      }

      newdesc += "".concat(lines[j], "\r\n");
    }

    this.media[i] = "".concat(_SDPUtil["default"].buildMLine(mline), "\r\n").concat(newdesc);
  }

  this.raw = this.session + this.media.join('');
}; // remove lines matching prefix from session section


SDP.prototype.removeSessionLines = function (prefix) {
  var self = this;

  var lines = _SDPUtil["default"].findLines(this.session, prefix);

  lines.forEach(function (line) {
    self.session = self.session.replace("".concat(line, "\r\n"), '');
  });
  this.raw = this.session + this.media.join('');
  return lines;
}; // remove lines matching prefix from a media section specified by mediaindex
// TODO: non-numeric mediaindex could match mid


SDP.prototype.removeMediaLines = function (mediaindex, prefix) {
  var self = this;

  var lines = _SDPUtil["default"].findLines(this.media[mediaindex], prefix);

  lines.forEach(function (line) {
    self.media[mediaindex] = self.media[mediaindex].replace("".concat(line, "\r\n"), '');
  });
  this.raw = this.session + this.media.join('');
  return lines;
}; // add content's to a jingle element


SDP.prototype.toJingle = function (elem, thecreator) {
  var i, j, k, lines, mline, rtpmap, ssrc, tmp; // new bundle plan

  lines = _SDPUtil["default"].findLines(this.session, 'a=group:');

  if (lines.length) {
    for (i = 0; i < lines.length; i++) {
      tmp = lines[i].split(' ');
      var semantics = tmp.shift().substr(8);
      elem.c('group', {
        xmlns: 'urn:xmpp:jingle:apps:grouping:0',
        semantics: semantics
      });

      for (j = 0; j < tmp.length; j++) {
        elem.c('content', {
          name: tmp[j]
        }).up();
      }

      elem.up();
    }
  }

  for (i = 0; i < this.media.length; i++) {
    mline = _SDPUtil["default"].parseMLine(this.media[i].split('\r\n')[0]);

    if (!(mline.media === 'audio' || mline.media === 'video' || mline.media === 'application')) {
      continue; // eslint-disable-line no-continue
    }

    var assrcline = _SDPUtil["default"].findLine(this.media[i], 'a=ssrc:');

    if (assrcline) {
      ssrc = assrcline.substring(7).split(' ')[0]; // take the first
    } else {
      ssrc = false;
    }

    elem.c('content', {
      creator: thecreator,
      name: mline.media
    });

    var amidline = _SDPUtil["default"].findLine(this.media[i], 'a=mid:');

    if (amidline) {
      // prefer identifier from a=mid if present
      var mid = _SDPUtil["default"].parseMID(amidline);

      elem.attrs({
        name: mid
      });
    }

    if (_SDPUtil["default"].findLine(this.media[i], 'a=rtpmap:').length) {
      elem.c('description', {
        xmlns: 'urn:xmpp:jingle:apps:rtp:1',
        media: mline.media
      });

      if (ssrc) {
        elem.attrs({
          ssrc: ssrc
        });
      }

      for (j = 0; j < mline.fmt.length; j++) {
        rtpmap = _SDPUtil["default"].findLine(this.media[i], "a=rtpmap:".concat(mline.fmt[j]));
        elem.c('payload-type', _SDPUtil["default"].parseRTPMap(rtpmap)); // put any 'a=fmtp:' + mline.fmt[j] lines into <param name=foo
        // value=bar/>

        var afmtpline = _SDPUtil["default"].findLine(this.media[i], "a=fmtp:".concat(mline.fmt[j]));

        if (afmtpline) {
          tmp = _SDPUtil["default"].parseFmtp(afmtpline); // eslint-disable-next-line max-depth

          for (k = 0; k < tmp.length; k++) {
            elem.c('parameter', tmp[k]).up();
          }
        } // XEP-0293 -- map a=rtcp-fb


        this.rtcpFbToJingle(i, elem, mline.fmt[j]);
        elem.up();
      }

      var crypto = _SDPUtil["default"].findLines(this.media[i], 'a=crypto:', this.session);

      if (crypto.length) {
        elem.c('encryption', {
          required: 1
        });
        crypto.forEach(function (line) {
          return elem.c('crypto', _SDPUtil["default"].parseCrypto(line)).up();
        });
        elem.up(); // end of encryption
      }

      if (ssrc) {
        var ssrcMap = _SDPUtil["default"].parseSSRC(this.media[i]);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = ssrcMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _slicedToArray(_step.value, 2),
                availableSsrc = _step$value[0],
                ssrcParameters = _step$value[1];

            elem.c('source', {
              ssrc: availableSsrc,
              xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'
            });
            ssrcParameters.forEach(function (ssrcSdpLine) {
              // get everything after first space
              var idx = ssrcSdpLine.indexOf(' ');
              var kv = ssrcSdpLine.substr(idx + 1);
              elem.c('parameter');

              if (kv.indexOf(':') === -1) {
                elem.attrs({
                  name: kv
                });
              } else {
                var name = kv.split(':', 2)[0];
                elem.attrs({
                  name: name
                });
                var v = kv.split(':', 2)[1];
                v = _SDPUtil["default"].filterSpecialChars(v);
                elem.attrs({
                  value: v
                });
              }

              elem.up();
            });
            elem.up();
          } // XEP-0339 handle ssrc-group attributes

        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var ssrcGroupLines = _SDPUtil["default"].findLines(this.media[i], 'a=ssrc-group:');

        ssrcGroupLines.forEach(function (line) {
          var idx = line.indexOf(' ');
          var semantics = line.substr(0, idx).substr(13);
          var ssrcs = line.substr(14 + semantics.length).split(' ');

          if (ssrcs.length) {
            elem.c('ssrc-group', {
              semantics: semantics,
              xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'
            });
            ssrcs.forEach(function (s) {
              return elem.c('source', {
                ssrc: s
              }).up();
            });
            elem.up();
          }
        });
      }

      var ridLines = _SDPUtil["default"].findLines(this.media[i], 'a=rid');

      if (ridLines.length) {
        // Map a line which looks like "a=rid:2 send" to just
        // the rid ("2")
        var rids = ridLines.map(function (ridLine) {
          return ridLine.split(':')[1];
        }).map(function (ridInfo) {
          return ridInfo.split(' ')[0];
        });
        rids.forEach(function (rid) {
          elem.c('source', {
            rid: rid,
            xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'
          });
          elem.up();
        });

        var unifiedSimulcast = _SDPUtil["default"].findLine(this.media[i], 'a=simulcast');

        if (unifiedSimulcast) {
          elem.c('rid-group', {
            semantics: 'SIM',
            xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'
          });
          rids.forEach(function (rid) {
            elem.c('source', {
              rid: rid
            }).up();
          });
          elem.up();
        }
      }

      if (_SDPUtil["default"].findLine(this.media[i], 'a=rtcp-mux')) {
        elem.c('rtcp-mux').up();
      } // XEP-0293 -- map a=rtcp-fb:*


      this.rtcpFbToJingle(i, elem, '*'); // XEP-0294

      lines = _SDPUtil["default"].findLines(this.media[i], 'a=extmap:');

      if (lines.length) {
        for (j = 0; j < lines.length; j++) {
          tmp = _SDPUtil["default"].parseExtmap(lines[j]);
          elem.c('rtp-hdrext', {
            xmlns: 'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0',
            uri: tmp.uri,
            id: tmp.value
          }); // eslint-disable-next-line max-depth

          if (tmp.hasOwnProperty('direction')) {
            // eslint-disable-next-line max-depth
            switch (tmp.direction) {
              case 'sendonly':
                elem.attrs({
                  senders: 'responder'
                });
                break;

              case 'recvonly':
                elem.attrs({
                  senders: 'initiator'
                });
                break;

              case 'sendrecv':
                elem.attrs({
                  senders: 'both'
                });
                break;

              case 'inactive':
                elem.attrs({
                  senders: 'none'
                });
                break;
            }
          } // TODO: handle params


          elem.up();
        }
      }

      elem.up(); // end of description
    } // map ice-ufrag/pwd, dtls fingerprint, candidates


    this.transportToJingle(i, elem);
    var m = this.media[i];

    if (_SDPUtil["default"].findLine(m, 'a=sendrecv', this.session)) {
      elem.attrs({
        senders: 'both'
      });
    } else if (_SDPUtil["default"].findLine(m, 'a=sendonly', this.session)) {
      elem.attrs({
        senders: 'initiator'
      });
    } else if (_SDPUtil["default"].findLine(m, 'a=recvonly', this.session)) {
      elem.attrs({
        senders: 'responder'
      });
    } else if (_SDPUtil["default"].findLine(m, 'a=inactive', this.session)) {
      elem.attrs({
        senders: 'none'
      });
    }

    if (mline.port === '0') {
      // estos hack to reject an m-line
      elem.attrs({
        senders: 'rejected'
      });
    }

    elem.up(); // end of content
  }

  elem.up();
  return elem;
};

SDP.prototype.transportToJingle = function (mediaindex, elem) {
  var tmp;
  var self = this;
  elem.c('transport'); // XEP-0343 DTLS/SCTP

  var sctpmap = _SDPUtil["default"].findLine(this.media[mediaindex], 'a=sctpmap:', self.session);

  if (sctpmap) {
    var sctpAttrs = _SDPUtil["default"].parseSCTPMap(sctpmap);

    elem.c('sctpmap', {
      xmlns: 'urn:xmpp:jingle:transports:dtls-sctp:1',
      number: sctpAttrs[0],

      /* SCTP port */
      protocol: sctpAttrs[1]
      /* protocol */

    }); // Optional stream count attribute

    if (sctpAttrs.length > 2) {
      elem.attrs({
        streams: sctpAttrs[2]
      });
    }

    elem.up();
  } // XEP-0320


  var fingerprints = _SDPUtil["default"].findLines(this.media[mediaindex], 'a=fingerprint:', this.session);

  fingerprints.forEach(function (line) {
    tmp = _SDPUtil["default"].parseFingerprint(line);
    tmp.xmlns = 'urn:xmpp:jingle:apps:dtls:0';
    elem.c('fingerprint').t(tmp.fingerprint);
    delete tmp.fingerprint; // eslint-disable-next-line no-param-reassign

    line = _SDPUtil["default"].findLine(self.media[mediaindex], 'a=setup:', self.session);

    if (line) {
      tmp.setup = line.substr(8);
    }

    elem.attrs(tmp);
    elem.up(); // end of fingerprint
  });
  tmp = _SDPUtil["default"].iceparams(this.media[mediaindex], this.session);

  if (tmp) {
    tmp.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';
    elem.attrs(tmp); // XEP-0176

    var lines = _SDPUtil["default"].findLines(this.media[mediaindex], 'a=candidate:', this.session);

    if (lines.length) {
      // add any a=candidate lines
      lines.forEach(function (line) {
        var candidate = _SDPUtil["default"].candidateToJingle(line);

        if (self.failICE) {
          candidate.ip = '1.1.1.1';
        }

        var protocol = candidate && typeof candidate.protocol === 'string' ? candidate.protocol.toLowerCase() : '';

        if (self.removeTcpCandidates && (protocol === 'tcp' || protocol === 'ssltcp') || self.removeUdpCandidates && protocol === 'udp') {
          return;
        }

        elem.c('candidate', candidate).up();
      });
    }
  }

  elem.up(); // end of transport
}; // XEP-0293


SDP.prototype.rtcpFbToJingle = function (mediaindex, elem, payloadtype) {
  var lines = _SDPUtil["default"].findLines(this.media[mediaindex], "a=rtcp-fb:".concat(payloadtype));

  lines.forEach(function (line) {
    var tmp = _SDPUtil["default"].parseRTCPFB(line);

    if (tmp.type === 'trr-int') {
      elem.c('rtcp-fb-trr-int', {
        xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0',
        value: tmp.params[0]
      });
      elem.up();
    } else {
      elem.c('rtcp-fb', {
        xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0',
        type: tmp.type
      });

      if (tmp.params.length > 0) {
        elem.attrs({
          'subtype': tmp.params[0]
        });
      }

      elem.up();
    }
  });
};

SDP.prototype.rtcpFbFromJingle = function (elem, payloadtype) {
  // XEP-0293
  var media = '';
  var tmp = elem.find('>rtcp-fb-trr-int[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');

  if (tmp.length) {
    media += 'a=rtcp-fb:* trr-int ';

    if (tmp.attr('value')) {
      media += tmp.attr('value');
    } else {
      media += '0';
    }

    media += '\r\n';
  }

  tmp = elem.find('>rtcp-fb[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
  tmp.each(function () {
    /* eslint-disable no-invalid-this */
    media += "a=rtcp-fb:".concat(payloadtype, " ").concat($(this).attr('type'));

    if ($(this).attr('subtype')) {
      media += " ".concat($(this).attr('subtype'));
    }

    media += '\r\n';
    /* eslint-enable no-invalid-this */
  });
  return media;
}; // construct an SDP from a jingle stanza


SDP.prototype.fromJingle = function (jingle) {
  var self = this;
  this.raw = 'v=0\r\n' + 'o=- 1923518516 2 IN IP4 0.0.0.0\r\n' // FIXME
  + 's=-\r\n' + 't=0 0\r\n'; // http://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-04
  // #section-8

  var groups = $(jingle).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]');

  if (groups.length) {
    groups.each(function (idx, group) {
      var contents = $(group).find('>content').map(function (_, content) {
        return content.getAttribute('name');
      }).get();

      if (contents.length > 0) {
        self.raw += "a=group:".concat(group.getAttribute('semantics') || group.getAttribute('type'), " ").concat(contents.join(' '), "\r\n");
      }
    });
  }

  this.session = this.raw;
  jingle.find('>content').each(function () {
    // eslint-disable-next-line no-invalid-this
    var m = self.jingle2media($(this));
    self.media.push(m);
  }); // reconstruct msid-semantic -- apparently not necessary

  /*
   var msid = SDPUtil.parseSSRC(this.raw);
   if (msid.hasOwnProperty('mslabel')) {
   this.session += "a=msid-semantic: WMS " + msid.mslabel + "\r\n";
   }
   */

  this.raw = this.session + this.media.join('');
}; // translate a jingle content element into an an SDP media part


SDP.prototype.jingle2media = function (content) {
  var desc = content.find('description');
  var media = '';
  var self = this;
  var sctp = content.find('>transport>sctpmap[xmlns="urn:xmpp:jingle:transports:dtls-sctp:1"]');
  var tmp = {
    media: desc.attr('media')
  };
  tmp.port = '1';

  if (content.attr('senders') === 'rejected') {
    // estos hack to reject an m-line.
    tmp.port = '0';
  }

  if (content.find('>transport>fingerprint').length || desc.find('encryption').length) {
    tmp.proto = sctp.length ? 'DTLS/SCTP' : 'RTP/SAVPF';
  } else {
    tmp.proto = 'RTP/AVPF';
  }

  if (sctp.length) {
    media += "m=application ".concat(tmp.port, " DTLS/SCTP ").concat(sctp.attr('number'), "\r\n");
    media += "a=sctpmap:".concat(sctp.attr('number'), " ").concat(sctp.attr('protocol'));
    var streamCount = sctp.attr('streams');

    if (streamCount) {
      media += " ".concat(streamCount, "\r\n");
    } else {
      media += '\r\n';
    }
  } else {
    tmp.fmt = desc.find('payload-type').map(function () {
      // eslint-disable-next-line no-invalid-this
      return this.getAttribute('id');
    }).get();
    media += "".concat(_SDPUtil["default"].buildMLine(tmp), "\r\n");
  }

  media += 'c=IN IP4 0.0.0.0\r\n';

  if (!sctp.length) {
    media += 'a=rtcp:1 IN IP4 0.0.0.0\r\n';
  }

  tmp = content.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]');

  if (tmp.length) {
    if (tmp.attr('ufrag')) {
      media += "".concat(_SDPUtil["default"].buildICEUfrag(tmp.attr('ufrag')), "\r\n");
    }

    if (tmp.attr('pwd')) {
      media += "".concat(_SDPUtil["default"].buildICEPwd(tmp.attr('pwd')), "\r\n");
    }

    tmp.find('>fingerprint').each(function () {
      /* eslint-disable no-invalid-this */
      // FIXME: check namespace at some point
      media += "a=fingerprint:".concat(this.getAttribute('hash'));
      media += " ".concat($(this).text());
      media += '\r\n';

      if (this.getAttribute('setup')) {
        media += "a=setup:".concat(this.getAttribute('setup'), "\r\n");
      }
      /* eslint-enable no-invalid-this */

    });
  }

  switch (content.attr('senders')) {
    case 'initiator':
      media += 'a=sendonly\r\n';
      break;

    case 'responder':
      media += 'a=recvonly\r\n';
      break;

    case 'none':
      media += 'a=inactive\r\n';
      break;

    case 'both':
      media += 'a=sendrecv\r\n';
      break;
  }

  media += "a=mid:".concat(content.attr('name'), "\r\n"); // <description><rtcp-mux/></description>
  // see http://code.google.com/p/libjingle/issues/detail?id=309 -- no spec
  // though
  // and http://mail.jabber.org/pipermail/jingle/2011-December/001761.html

  if (desc.find('rtcp-mux').length) {
    media += 'a=rtcp-mux\r\n';
  }

  if (desc.find('encryption').length) {
    desc.find('encryption>crypto').each(function () {
      /* eslint-disable no-invalid-this */
      media += "a=crypto:".concat(this.getAttribute('tag'));
      media += " ".concat(this.getAttribute('crypto-suite'));
      media += " ".concat(this.getAttribute('key-params'));

      if (this.getAttribute('session-params')) {
        media += " ".concat(this.getAttribute('session-params'));
      }

      media += '\r\n';
      /* eslint-enable no-invalid-this */
    });
  }

  desc.find('payload-type').each(function () {
    /* eslint-disable no-invalid-this */
    media += "".concat(_SDPUtil["default"].buildRTPMap(this), "\r\n");

    if ($(this).find('>parameter').length) {
      media += "a=fmtp:".concat(this.getAttribute('id'), " ");
      media += $(this).find('parameter').map(function () {
        var name = this.getAttribute('name');
        return (name ? "".concat(name, "=") : '') + this.getAttribute('value');
      }).get().join('; ');
      media += '\r\n';
    } // xep-0293


    media += self.rtcpFbFromJingle($(this), this.getAttribute('id'));
    /* eslint-enable no-invalid-this */
  }); // xep-0293

  media += self.rtcpFbFromJingle(desc, '*'); // xep-0294

  tmp = desc.find('>rtp-hdrext[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]');
  tmp.each(function () {
    /* eslint-disable no-invalid-this */
    media += "a=extmap:".concat(this.getAttribute('id'), " ").concat(this.getAttribute('uri'), "\r\n");
    /* eslint-enable no-invalid-this */
  });
  content.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]' + '>candidate').each(function () {
    /* eslint-disable no-invalid-this */
    var protocol = this.getAttribute('protocol');
    protocol = typeof protocol === 'string' ? protocol.toLowerCase() : '';

    if (self.removeTcpCandidates && (protocol === 'tcp' || protocol === 'ssltcp') || self.removeUdpCandidates && protocol === 'udp') {
      return;
    } else if (self.failICE) {
      this.setAttribute('ip', '1.1.1.1');
    }

    media += _SDPUtil["default"].candidateFromJingle(this);
    /* eslint-enable no-invalid-this */
  }); // XEP-0339 handle ssrc-group attributes

  content.find('description>ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(function () {
    /* eslint-disable no-invalid-this */
    var semantics = this.getAttribute('semantics');
    var ssrcs = $(this).find('>source').map(function () {
      return this.getAttribute('ssrc');
    }).get();

    if (ssrcs.length) {
      media += "a=ssrc-group:".concat(semantics, " ").concat(ssrcs.join(' '), "\r\n");
    }
    /* eslint-enable no-invalid-this */

  });
  tmp = content.find('description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]');
  tmp.each(function () {
    /* eslint-disable no-invalid-this */
    var ssrc = this.getAttribute('ssrc'); // eslint-disable-next-line newline-per-chained-call

    $(this).find('>parameter').each(function () {
      var name = this.getAttribute('name');
      var value = this.getAttribute('value');
      value = _SDPUtil["default"].filterSpecialChars(value);
      media += "a=ssrc:".concat(ssrc, " ").concat(name);

      if (value && value.length) {
        media += ":".concat(value);
      }

      media += '\r\n';
    });
    /* eslint-enable no-invalid-this */
  });
  return media;
};
"use strict";

var _strophe = require("strophe.js");

var _SDP = _interopRequireDefault(require("./SDP"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

describe('SDP', function () {
  describe('toJingle', function () {
    /* eslint-disable max-len*/
    var testSdp = ['v=0\r\n', 'o=thisisadapterortc 2719486166053431 0 IN IP4 127.0.0.1\r\n', 's=-\r\n', 't=0 0\r\n', 'a=group:BUNDLE audio video\r\n', 'm=audio 9 UDP/TLS/RTP/SAVPF 111 126\r\n', 'c=IN IP4 0.0.0.0\r\n', 'a=rtpmap:111 opus/48000/2\r\n', 'a=rtpmap:126 telephone-event/8000\r\n', 'a=fmtp:111 minptime=10;useinbandfec=1\r\n', 'a=rtcp:9 IN IP4 0.0.0.0\r\n', 'a=setup:active\r\n', 'a=mid:audio\r\n', 'a=msid:26D16D51-503A-420B-8274-3DD1174E498F 8205D1FC-50B4-407C-87D5-9C45F1B779F0\r\n', 'a=sendrecv\r\n', 'a=ice-ufrag:tOQd\r\n', 'a=ice-pwd:3sAozs7hw6+2O6DBp2pt9fvY\r\n', 'a=fingerprint:sha-256 A9:00:CC:F9:81:33:EA:E9:E3:B4:01:E9:9E:18:B3:9B:F8:49:25:A0:5D:12:20:70:D5:6F:34:5A:2A:39:19:0A\r\n', 'a=ssrc:2002 msid:26D16D51-503A-420B-8274-3DD1174E498F 8205D1FC-50B4-407C-87D5-9C45F1B779F0\r\n', 'a=ssrc:2002 cname:juejgy8a01\r\n', 'a=rtcp-mux\r\n', 'm=video 9 UDP/TLS/RTP/SAVPF 107 100 99 96\r\n', 'c=IN IP4 0.0.0.0\r\n', 'a=rtpmap:107 h264/90000\r\n', 'a=rtpmap:100 VP8/90000\r\n', 'a=rtpmap:99 rtx/90000\r\n', 'a=rtpmap:96 rtx/90000\r\n', 'a=fmtp:107 x-google-start-bitrate=800\r\n', 'a=fmtp:100 x-google-start-bitrate=800\r\n', 'a=fmtp:99 apt=107\r\n', 'a=fmtp:96 apt=100\r\n', 'a=rtcp:9 IN IP4 0.0.0.0\r\n', 'a=rtcp-fb:107 nack\r\n', 'a=rtcp-fb:107 nack pli\r\n', 'a=rtcp-fb:107 goog-remb\r\n', 'a=rtcp-fb:100 nack\r\n', 'a=rtcp-fb:100 nack pli\r\n', 'a=rtcp-fb:100 goog-remb\r\n', 'a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\r\n', 'a=setup:active\r\n', 'a=mid:video\r\n', 'a=msid:7C0035E5-2DA1-4AEA-804A-9E75BF9B3768 225E9CDA-0384-4C92-92DD-E74C1153EC68\r\n', 'a=sendrecv\r\n', 'a=ice-ufrag:tOQd\r\n', 'a=ice-pwd:3sAozs7hw6+2O6DBp2pt9fvY\r\n', 'a=fingerprint:sha-256 A9:00:CC:F9:81:33:EA:E9:E3:B4:01:E9:9E:18:B3:9B:F8:49:25:A0:5D:12:20:70:D5:6F:34:5A:2A:39:19:0A\r\n', 'a=ssrc:4004 msid:7C0035E5-2DA1-4AEA-804A-9E75BF9B3768 225E9CDA-0384-4C92-92DD-E74C1153EC68\r\n', 'a=ssrc:4005 msid:7C0035E5-2DA1-4AEA-804A-9E75BF9B3768 225E9CDA-0384-4C92-92DD-E74C1153EC68\r\n', 'a=ssrc:4004 cname:juejgy8a01\r\n', 'a=ssrc:4005 cname:juejgy8a01\r\n', 'a=ssrc-group:FID 4004 4005\r\n', 'a=rtcp-mux\r\n'].join('');
    /* eslint-enable max-len*/

    it('correctly groups ssrcs lines that are not in order', function () {
      var sdp = new _SDP["default"](testSdp);
      var accept = (0, _strophe.$iq)({
        to: 'peerjid',
        type: 'set'
      }).c('jingle', {
        xmlns: 'urn:xmpp:jingle:1',
        action: 'session-accept',
        initiator: false,
        responder: true,
        sid: 'temp-sid'
      });
      sdp.toJingle(accept, false);
      var nodeTree = accept.nodeTree;
      var descriptions = Array.from(nodeTree.getElementsByTagName('description'));
      var videoDescriptions = descriptions.filter(function (description) {
        return description.getAttribute('media') === 'video';
      });
      var count = videoDescriptions.reduce(function (iterator, description) {
        var childNodes = Array.from(description.childNodes);
        var childNodesSources = childNodes.filter(function (child) {
          return child.nodeName === 'source';
        });
        return iterator + childNodesSources.length;
      }, 0);
      expect(count).toBe(2);
    });
  });
});
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jitsiMeetLogger = require("jitsi-meet-logger");

var _SdpTransformUtil = require("./SdpTransformUtil");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var logger = (0, _jitsiMeetLogger.getLogger)(__filename);
/**
 * Handles the work of keeping video ssrcs consistent across multiple
 * o/a cycles, making it such that all stream operations can be
 * kept local and do not need to be signaled.
 * NOTE: This only keeps the 'primary' video ssrc consistent: meaning
 * the primary video stream
 */

var SdpConsistency =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @param {string} logPrefix the log prefix appended to every logged
   * message, currently used to distinguish for which
   * <tt>TraceablePeerConnection</tt> the instance works.
   */
  function SdpConsistency(logPrefix) {
    _classCallCheck(this, SdpConsistency);

    this.clearVideoSsrcCache();
    this.logPrefix = logPrefix;
  }
  /**
   * Clear the cached video primary and primary rtx ssrcs so that
   *  they will not be used for the next call to
   *  makeVideoPrimarySsrcsConsistent
   */


  _createClass(SdpConsistency, [{
    key: "clearVideoSsrcCache",
    value: function clearVideoSsrcCache() {
      this.cachedPrimarySsrc = null;
      this.injectRecvOnly = false;
    }
    /**
     * Explicitly set the primary ssrc to be used in
     *  makeVideoPrimarySsrcsConsistent
     * @param {number} primarySsrc the primarySsrc to be used
     *  in future calls to makeVideoPrimarySsrcsConsistent
     * @throws Error if <tt>primarySsrc</tt> is not a number
     */

  }, {
    key: "setPrimarySsrc",
    value: function setPrimarySsrc(primarySsrc) {
      if (typeof primarySsrc !== 'number') {
        throw new Error('Primary SSRC must be a number!');
      }

      this.cachedPrimarySsrc = primarySsrc;
    }
    /**
     * Checks whether or not there is a primary video SSRC cached already.
     * @return {boolean}
     */

  }, {
    key: "hasPrimarySsrcCached",
    value: function hasPrimarySsrcCached() {
      return Boolean(this.cachedPrimarySsrc);
    }
    /**
     * Given an sdp string, either:
     *  1) record the primary video and primary rtx ssrcs to be
     *   used in future calls to makeVideoPrimarySsrcsConsistent or
     *  2) change the primary and primary rtx ssrcs in the given sdp
     *   to match the ones previously cached
     * @param {string} sdpStr the sdp string to (potentially)
     *  change to make the video ssrcs consistent
     * @returns {string} a (potentially) modified sdp string
     *  with ssrcs consistent with this class' cache
     */

  }, {
    key: "makeVideoPrimarySsrcsConsistent",
    value: function makeVideoPrimarySsrcsConsistent(sdpStr) {
      var sdpTransformer = new _SdpTransformUtil.SdpTransformWrap(sdpStr);
      var videoMLine = sdpTransformer.selectMedia('video');

      if (!videoMLine) {
        logger.debug("".concat(this.logPrefix, " no 'video' media found in the sdp: ") + "".concat(sdpStr));
        return sdpStr;
      }

      if (videoMLine.direction === 'recvonly') {
        // If the mline is recvonly, we'll add the primary
        //  ssrc as a recvonly ssrc
        if (this.cachedPrimarySsrc && this.injectRecvOnly) {
          videoMLine.addSSRCAttribute({
            id: this.cachedPrimarySsrc,
            attribute: 'cname',
            value: "recvonly-".concat(this.cachedPrimarySsrc)
          });
        } else {
          logger.info("".concat(this.logPrefix, " no SSRC found for the recvonly video") + 'stream!');
        }
      } else {
        var newPrimarySsrc = videoMLine.getPrimaryVideoSsrc();

        if (!newPrimarySsrc) {
          logger.info("".concat(this.logPrefix, " sdp-consistency couldn't") + ' parse new primary ssrc');
          return sdpStr;
        }

        if (this.cachedPrimarySsrc) {
          logger.info("".concat(this.logPrefix, " sdp-consistency replacing new ssrc") + "".concat(newPrimarySsrc, " with cached ") + "".concat(this.cachedPrimarySsrc));
          videoMLine.replaceSSRC(newPrimarySsrc, this.cachedPrimarySsrc);
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = videoMLine.ssrcGroups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var group = _step.value;

              if (group.semantics === 'FID') {
                var primarySsrc = (0, _SdpTransformUtil.parsePrimarySSRC)(group);
                var rtxSsrc = (0, _SdpTransformUtil.parseSecondarySSRC)(group); // eslint-disable-next-line max-depth

                if (primarySsrc === newPrimarySsrc) {
                  group.ssrcs = "".concat(this.cachedPrimarySsrc, " ").concat(rtxSsrc);
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        } else {
          this.cachedPrimarySsrc = newPrimarySsrc;
          logger.info("".concat(this.logPrefix, " sdp-consistency caching primary ssrc") + "".concat(this.cachedPrimarySsrc));
        }

        this.injectRecvOnly = true;
      }

      return sdpTransformer.toRawSDP();
    }
  }]);

  return SdpConsistency;
}();

exports["default"] = SdpConsistency;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = SDPDiffer;

var _SDPUtil = _interopRequireDefault(require("./SDPUtil"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// this could be useful in Array.prototype.

/**
 *
 * @param array1
 * @param array2
 */
function arrayEquals(array1, array2) {
  // if the other array is a falsy value, return
  if (!array2) {
    return false;
  } // compare lengths - can save a lot of time


  if (array1.length !== array2.length) {
    return false;
  }

  for (var i = 0, l = array1.length; i < l; i++) {
    // Check if we have nested arrays
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      // recurse into the nested arrays
      if (!array1[i].equals(array2[i])) {
        return false;
      }
    } else if (array1[i] !== array2[i]) {
      // Warning - two different object instances will never be
      // equal: {x:20} != {x:20}
      return false;
    }
  }

  return true;
}
/**
 *
 * @param mySDP
 * @param otherSDP
 */


function SDPDiffer(mySDP, otherSDP) {
  this.mySDP = mySDP;
  this.otherSDP = otherSDP;

  if (!mySDP) {
    throw new Error('"mySDP" is undefined!');
  } else if (!otherSDP) {
    throw new Error('"otherSDP" is undefined!');
  }
}
/**
 * Returns map of MediaChannel that contains media contained in
 * 'mySDP', but not contained in 'otherSdp'. Mapped by channel idx.
 */


SDPDiffer.prototype.getNewMedia = function () {
  var myMedias = this.mySDP.getMediaSsrcMap();
  var othersMedias = this.otherSDP.getMediaSsrcMap();
  var newMedia = {};
  Object.keys(othersMedias).forEach(function (othersMediaIdx) {
    var myMedia = myMedias[othersMediaIdx];
    var othersMedia = othersMedias[othersMediaIdx];

    if (!myMedia && othersMedia) {
      // Add whole channel
      newMedia[othersMediaIdx] = othersMedia;
      return;
    } // Look for new ssrcs across the channel


    Object.keys(othersMedia.ssrcs).forEach(function (ssrc) {
      if (Object.keys(myMedia.ssrcs).indexOf(ssrc) === -1) {
        // Allocate channel if we've found ssrc that doesn't exist in
        // our channel
        if (!newMedia[othersMediaIdx]) {
          newMedia[othersMediaIdx] = {
            mediaindex: othersMedia.mediaindex,
            mid: othersMedia.mid,
            ssrcs: {},
            ssrcGroups: []
          };
        }

        newMedia[othersMediaIdx].ssrcs[ssrc] = othersMedia.ssrcs[ssrc];
      } else if (othersMedia.ssrcs[ssrc].lines && myMedia.ssrcs[ssrc].lines) {
        // we want to detect just changes in adding/removing msid
        var myContainMsid = myMedia.ssrcs[ssrc].lines.find(function (line) {
          return line.indexOf('msid') !== -1;
        }) !== undefined;
        var newContainMsid = othersMedia.ssrcs[ssrc].lines.find(function (line) {
          return line.indexOf('msid') !== -1;
        }) !== undefined;

        if (myContainMsid !== newContainMsid) {
          if (!newMedia[othersMediaIdx]) {
            newMedia[othersMediaIdx] = {
              mediaindex: othersMedia.mediaindex,
              mid: othersMedia.mid,
              ssrcs: {},
              ssrcGroups: []
            };
          }

          newMedia[othersMediaIdx].ssrcs[ssrc] = othersMedia.ssrcs[ssrc];
        }
      }
    }); // Look for new ssrc groups across the channels

    othersMedia.ssrcGroups.forEach(function (otherSsrcGroup) {
      // try to match the other ssrc-group with an ssrc-group of ours
      var matched = false;

      for (var i = 0; i < myMedia.ssrcGroups.length; i++) {
        var mySsrcGroup = myMedia.ssrcGroups[i];

        if (otherSsrcGroup.semantics === mySsrcGroup.semantics && arrayEquals(otherSsrcGroup.ssrcs, mySsrcGroup.ssrcs)) {
          matched = true;
          break;
        }
      }

      if (!matched) {
        // Allocate channel if we've found an ssrc-group that doesn't
        // exist in our channel
        if (!newMedia[othersMediaIdx]) {
          newMedia[othersMediaIdx] = {
            mediaindex: othersMedia.mediaindex,
            mid: othersMedia.mid,
            ssrcs: {},
            ssrcGroups: []
          };
        }

        newMedia[othersMediaIdx].ssrcGroups.push(otherSsrcGroup);
      }
    });
  });
  return newMedia;
};
/**
 * TODO: document!
 */


SDPDiffer.prototype.toJingle = function (modify) {
  var sdpMediaSsrcs = this.getNewMedia();
  var modified = false;
  Object.keys(sdpMediaSsrcs).forEach(function (mediaindex) {
    modified = true;
    var media = sdpMediaSsrcs[mediaindex];
    modify.c('content', {
      name: media.mid
    });
    modify.c('description', {
      xmlns: 'urn:xmpp:jingle:apps:rtp:1',
      media: media.mid
    }); // FIXME: not completely sure this operates on blocks and / or handles
    // different ssrcs correctly
    // generate sources from lines

    Object.keys(media.ssrcs).forEach(function (ssrcNum) {
      var mediaSsrc = media.ssrcs[ssrcNum];
      modify.c('source', {
        xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'
      });
      modify.attrs({
        ssrc: mediaSsrc.ssrc
      }); // iterate over ssrc lines

      mediaSsrc.lines.forEach(function (line) {
        var idx = line.indexOf(' ');
        var kv = line.substr(idx + 1);
        modify.c('parameter');

        if (kv.indexOf(':') === -1) {
          modify.attrs({
            name: kv
          });
        } else {
          var nv = kv.split(':', 2);
          var name = nv[0];

          var value = _SDPUtil["default"].filterSpecialChars(nv[1]);

          modify.attrs({
            name: name
          });
          modify.attrs({
            value: value
          });
        }

        modify.up(); // end of parameter
      });
      modify.up(); // end of source
    }); // generate source groups from lines

    media.ssrcGroups.forEach(function (ssrcGroup) {
      if (ssrcGroup.ssrcs.length) {
        modify.c('ssrc-group', {
          semantics: ssrcGroup.semantics,
          xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'
        });
        ssrcGroup.ssrcs.forEach(function (ssrc) {
          modify.c('source', {
            ssrc: ssrc
          }).up(); // end of source
        });
        modify.up(); // end of ssrc-group
      }
    });
    modify.up(); // end of description

    modify.up(); // end of content
  });
  return modified;
};
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePrimarySSRC = parsePrimarySSRC;
exports.parseSecondarySSRC = parseSecondarySSRC;
exports.SdpTransformWrap = void 0;

var transform = _interopRequireWildcard(require("sdp-transform"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Parses the primary SSRC of given SSRC group.
 * @param {object} group the SSRC group object as defined by the 'sdp-transform'
 * @return {Number} the primary SSRC number
 */
function parsePrimarySSRC(group) {
  return parseInt(group.ssrcs.split(' ')[0], 10);
}
/**
 * Parses the secondary SSRC of given SSRC group.
 * @param {object} group the SSRC group object as defined by the 'sdp-transform'
 * @return {Number} the secondary SSRC number
 */


function parseSecondarySSRC(group) {
  return parseInt(group.ssrcs.split(' ')[1], 10);
}
/**
 * Tells how many distinct SSRCs are contained in given media line.
 * @param {Object} mLine the media line object as defined by 'sdp-transform' lib
 * @return {number}
 */


function _getSSRCCount(mLine) {
  if (!mLine.ssrcs) {
    return 0;
  }

  return mLine.ssrcs.map(function (ssrcInfo) {
    return ssrcInfo.id;
  }).filter(function (ssrc, index, array) {
    return array.indexOf(ssrc) === index;
  }).length;
}
/**
 * A wrapper around 'sdp-transform' media description object which provides
 * utility methods for common SDP/SSRC related operations.
 */


var MLineWrap =
/*#__PURE__*/
function () {
  /**
   * Creates new <tt>MLineWrap</t>>
   * @param {Object} mLine the media line object as defined by 'sdp-transform'
   * lib.
   */
  function MLineWrap(mLine) {
    _classCallCheck(this, MLineWrap);

    if (!mLine) {
      throw new Error('mLine is undefined');
    }

    this.mLine = mLine;
  }
  /**
   * Getter for the mLine's "ssrcs" array. If the array was undefined an empty
   * one will be preassigned.
   *
   * @return {Array<Object>} an array of 'sdp-transform' SSRC attributes
   * objects.
   */


  _createClass(MLineWrap, [{
    key: "getSSRCAttrValue",

    /**
     * Obtains value from SSRC attribute.
     * @param {number} ssrcNumber the SSRC number for which attribute is to be
     * found
     * @param {string} attrName the name of the SSRC attribute to be found.
     * @return {string|undefined} the value of SSRC attribute or
     * <tt>undefined</tt> if no such attribute exists.
     */
    value: function getSSRCAttrValue(ssrcNumber, attrName) {
      var attribute = this.ssrcs.find(function (ssrcObj) {
        return ssrcObj.id === ssrcNumber && ssrcObj.attribute === attrName;
      });
      return attribute && attribute.value;
    }
    /**
     * Removes all attributes for given SSRC number.
     * @param {number} ssrcNum the SSRC number for which all attributes will be
     * removed.
     */

  }, {
    key: "removeSSRC",
    value: function removeSSRC(ssrcNum) {
      if (!this.mLine.ssrcs || !this.mLine.ssrcs.length) {
        return;
      }

      this.mLine.ssrcs = this.mLine.ssrcs.filter(function (ssrcObj) {
        return ssrcObj.id !== ssrcNum;
      });
    }
    /**
     * Adds SSRC attribute
     * @param {object} ssrcObj the SSRC attribute object as defined in
     * the 'sdp-transform' lib.
     */

  }, {
    key: "addSSRCAttribute",
    value: function addSSRCAttribute(ssrcObj) {
      this.ssrcs.push(ssrcObj);
    }
    /**
     * Finds a SSRC group matching both semantics and SSRCs in order.
     * @param {string} semantics the name of the semantics
     * @param {string} [ssrcs] group SSRCs as a string (like it's defined in
     * SSRC group object of the 'sdp-transform' lib) e.g. "1232546 342344 25434"
     * @return {object|undefined} the SSRC group object or <tt>undefined</tt> if
     * not found.
     */

  }, {
    key: "findGroup",
    value: function findGroup(semantics, ssrcs) {
      return this.ssrcGroups.find(function (group) {
        return group.semantics === semantics && (!ssrcs || ssrcs === group.ssrcs);
      });
    }
    /**
     * Finds all groups matching given semantic's name.
     * @param {string} semantics the name of the semantics
     * @return {Array.<object>} an array of SSRC group objects as defined by
     * the 'sdp-transform' lib.
     */

  }, {
    key: "findGroups",
    value: function findGroups(semantics) {
      return this.ssrcGroups.filter(function (group) {
        return group.semantics === semantics;
      });
    }
    /**
     * Finds all groups matching given semantic's name and group's primary SSRC.
     * @param {string} semantics the name of the semantics
     * @param {number} primarySSRC the primary SSRC number to be matched
     * @return {Object} SSRC group object as defined by the 'sdp-transform' lib.
     */

  }, {
    key: "findGroupByPrimarySSRC",
    value: function findGroupByPrimarySSRC(semantics, primarySSRC) {
      return this.ssrcGroups.find(function (group) {
        return group.semantics === semantics && parsePrimarySSRC(group) === primarySSRC;
      });
    }
    /**
     * @param {string|null} msid the media stream id or <tt>null</tt> to match
     * the first SSRC object with any 'msid' value.
     * @return {Object|undefined} the SSRC object as defined by 'sdp-transform'
     * lib.
     */

  }, {
    key: "findSSRCByMSID",
    value: function findSSRCByMSID(msid) {
      return this.ssrcs.find(function (ssrcObj) {
        return ssrcObj.attribute === 'msid' && (msid === null || ssrcObj.value === msid);
      });
    }
    /**
     * Gets the SSRC count for the underlying media description.
     * @return {number}
     */

  }, {
    key: "getSSRCCount",
    value: function getSSRCCount() {
      return _getSSRCCount(this.mLine);
    }
    /**
     * Checks whether the underlying media description contains any SSRC groups.
     * @return {boolean} <tt>true</tt> if there are any SSRC groups or
     * <tt>false</tt> otherwise.
     */

  }, {
    key: "containsAnySSRCGroups",
    value: function containsAnySSRCGroups() {
      return this.mLine.ssrcGroups !== undefined;
    }
    /**
     * Finds the primary video SSRC.
     * @returns {number|undefined} the primary video ssrc
     * @throws Error if the underlying media description is not a video
     */

  }, {
    key: "getPrimaryVideoSsrc",
    value: function getPrimaryVideoSsrc() {
      var mediaType = this.mLine.type;

      if (mediaType !== 'video') {
        throw new Error("getPrimarySsrc doesn't work with '".concat(mediaType, "'"));
      }

      var numSsrcs = _getSSRCCount(this.mLine);

      if (numSsrcs === 1) {
        // Not using "ssrcs" getter on purpose here
        return this.mLine.ssrcs[0].id;
      } // Look for a SIM, FID, or FEC-FR group


      if (this.mLine.ssrcGroups) {
        var simGroup = this.findGroup('SIM');

        if (simGroup) {
          return parsePrimarySSRC(simGroup);
        }

        var fidGroup = this.findGroup('FID');

        if (fidGroup) {
          return parsePrimarySSRC(fidGroup);
        }

        var fecGroup = this.findGroup('FEC-FR');

        if (fecGroup) {
          return parsePrimarySSRC(fecGroup);
        }
      }
    }
    /**
     * Obtains RTX SSRC from the underlying video description (the
     * secondary SSRC of the first "FID" group found)
     * @param {number} primarySsrc the video ssrc for which to find the
     * corresponding rtx ssrc
     * @returns {number|undefined} the rtx ssrc (or undefined if there isn't
     * one)
     */

  }, {
    key: "getRtxSSRC",
    value: function getRtxSSRC(primarySsrc) {
      var fidGroup = this.findGroupByPrimarySSRC('FID', primarySsrc);
      return fidGroup && parseSecondarySSRC(fidGroup);
    }
    /**
     * Obtains all SSRCs contained in the underlying media description.
     * @return {Array.<number>} an array with all SSRC as numbers.
     */

  }, {
    key: "getSSRCs",
    value: function getSSRCs() {
      return this.ssrcs.map(function (ssrcInfo) {
        return ssrcInfo.id;
      }).filter(function (ssrc, index, array) {
        return array.indexOf(ssrc) === index;
      });
    }
    /**
     * Obtains primary video SSRCs.
     * @return {Array.<number>} an array of all primary video SSRCs as numbers.
     * @throws Error if the wrapped media description is not a video.
     */

  }, {
    key: "getPrimaryVideoSSRCs",
    value: function getPrimaryVideoSSRCs() {
      var mediaType = this.mLine.type;

      if (mediaType !== 'video') {
        throw new Error("getPrimaryVideoSSRCs doesn't work with ".concat(mediaType));
      }

      var videoSSRCs = this.getSSRCs();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.ssrcGroups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var ssrcGroupInfo = _step.value;

          // Right now, FID and FEC-FR groups are the only ones we parse to
          // disqualify streams.  If/when others arise we'll
          // need to add support for them here
          if (ssrcGroupInfo.semantics === 'FID' || ssrcGroupInfo.semantics === 'FEC-FR') {
            // secondary streams should be filtered out
            var secondarySsrc = parseSecondarySSRC(ssrcGroupInfo);
            videoSSRCs.splice(videoSSRCs.indexOf(secondarySsrc), 1);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return videoSSRCs;
    }
    /**
     * Dumps all SSRC groups of this media description to JSON.
     */

  }, {
    key: "dumpSSRCGroups",
    value: function dumpSSRCGroups() {
      return JSON.stringify(this.mLine.ssrcGroups);
    }
    /**
     * Removes all SSRC groups which contain given SSRC number at any position.
     * @param {number} ssrc the SSRC for which all matching groups are to be
     * removed.
     */

  }, {
    key: "removeGroupsWithSSRC",
    value: function removeGroupsWithSSRC(ssrc) {
      if (!this.mLine.ssrcGroups) {
        return;
      }

      this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter(function (groupInfo) {
        return groupInfo.ssrcs.indexOf("".concat(ssrc)) === -1;
      });
    }
    /**
     * Removes groups that match given semantics.
     * @param {string} semantics e.g. "SIM" or "FID"
     */

  }, {
    key: "removeGroupsBySemantics",
    value: function removeGroupsBySemantics(semantics) {
      if (!this.mLine.ssrcGroups) {
        return;
      }

      this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter(function (groupInfo) {
        return groupInfo.semantics !== semantics;
      });
    }
    /**
     * Replaces SSRC (does not affect SSRC groups, but only attributes).
     * @param {number} oldSSRC the old SSRC number
     * @param {number} newSSRC the new SSRC number
     */

  }, {
    key: "replaceSSRC",
    value: function replaceSSRC(oldSSRC, newSSRC) {
      if (this.mLine.ssrcs) {
        this.mLine.ssrcs.forEach(function (ssrcInfo) {
          if (ssrcInfo.id === oldSSRC) {
            ssrcInfo.id = newSSRC;
          }
        });
      }
    }
    /**
     * Adds given SSRC group to this media description.
     * @param {object} group the SSRC group object as defined by
     * the 'sdp-transform' lib.
     */

  }, {
    key: "addSSRCGroup",
    value: function addSSRCGroup(group) {
      this.ssrcGroups.push(group);
    }
  }, {
    key: "ssrcs",
    get: function get() {
      if (!this.mLine.ssrcs) {
        this.mLine.ssrcs = [];
      }

      return this.mLine.ssrcs;
    }
    /**
     * Setter for the mLine's "ssrcs" array.
     *
     * @param {Array<Object>} ssrcs an array of 'sdp-transform' SSRC attributes
     * objects.
     */
    ,
    set: function set(ssrcs) {
      this.mLine.ssrcs = ssrcs;
    }
    /**
     * Returns the direction of the underlying media description.
     * @return {string} the media direction name as defined in the SDP.
     */

  }, {
    key: "direction",
    get: function get() {
      return this.mLine.direction;
    }
    /**
     * Modifies the direction of the underlying media description.
     * @param {string} direction the new direction to be set
     */
    ,
    set: function set(direction) {
      this.mLine.direction = direction;
    }
    /**
     * Exposes the SSRC group array of the underlying media description object.
     * @return {Array.<Object>}
     */

  }, {
    key: "ssrcGroups",
    get: function get() {
      if (!this.mLine.ssrcGroups) {
        this.mLine.ssrcGroups = [];
      }

      return this.mLine.ssrcGroups;
    }
    /**
     * Modifies the SSRC groups array of the underlying media description
     * object.
     * @param {Array.<Object>} ssrcGroups
     */
    ,
    set: function set(ssrcGroups) {
      this.mLine.ssrcGroups = ssrcGroups;
    }
  }]);

  return MLineWrap;
}();
/**
 * Utility class for SDP manipulation using the 'sdp-transform' library.
 *
 * Typical use usage scenario:
 *
 * const transformer = new SdpTransformWrap(rawSdp);
 * const videoMLine = transformer.selectMedia('video);
 * if (videoMLine) {
 *     videoMLiner.addSSRCAttribute({
 *         id: 2342343,
 *         attribute: "cname",
 *         value: "someCname"
 *     });
 *     rawSdp = transformer.toRawSdp();
 * }
 */


var SdpTransformWrap =
/*#__PURE__*/
function () {
  /**
   * Creates new instance and parses the raw SDP into objects using
   * 'sdp-transform' lib.
   * @param {string} rawSDP the SDP in raw text format.
   */
  function SdpTransformWrap(rawSDP) {
    _classCallCheck(this, SdpTransformWrap);

    this.parsedSDP = transform.parse(rawSDP);
  }
  /**
   * Selects the first media SDP of given name.
   * @param {string} mediaType the name of the media e.g. 'audio', 'video',
   * 'data'.
   * @return {MLineWrap|null} return {@link MLineWrap} instance for the media
   * line or <tt>null</tt> if not found. The object returned references
   * the underlying SDP state held by this <tt>SdpTransformWrap</tt> instance
   * (it's not a copy).
   */


  _createClass(SdpTransformWrap, [{
    key: "selectMedia",
    value: function selectMedia(mediaType) {
      var selectedMLine = this.parsedSDP.media.find(function (mLine) {
        return mLine.type === mediaType;
      });
      return selectedMLine ? new MLineWrap(selectedMLine) : null;
    }
    /**
     * Converts the currently stored SDP state in this instance to raw text SDP
     * format.
     * @return {string}
     */

  }, {
    key: "toRawSDP",
    value: function toRawSDP() {
      return transform.write(this.parsedSDP);
    }
  }]);

  return SdpTransformWrap;
}();

exports.SdpTransformWrap = SdpTransformWrap;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jitsiMeetLogger = require("jitsi-meet-logger");

var _RandomUtil = _interopRequireDefault(require("../util/RandomUtil"));

var _browser = _interopRequireDefault(require("../browser"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var logger = (0, _jitsiMeetLogger.getLogger)(__filename);
var SDPUtil = {
  filterSpecialChars: function filterSpecialChars(text) {
    // XXX Neither one of the falsy values (e.g. null, undefined, false,
    // "", etc.) "contain" special chars.
    // eslint-disable-next-line no-useless-escape
    return text ? text.replace(/[\\\/\{,\}\+]/g, '') : text;
  },
  iceparams: function iceparams(mediadesc, sessiondesc) {
    var data = null;
    var pwd, ufrag;

    if ((ufrag = SDPUtil.findLine(mediadesc, 'a=ice-ufrag:', sessiondesc)) && (pwd = SDPUtil.findLine(mediadesc, 'a=ice-pwd:', sessiondesc))) {
      data = {
        ufrag: SDPUtil.parseICEUfrag(ufrag),
        pwd: SDPUtil.parseICEPwd(pwd)
      };
    }

    return data;
  },
  parseICEUfrag: function parseICEUfrag(line) {
    return line.substring(12);
  },
  buildICEUfrag: function buildICEUfrag(frag) {
    return "a=ice-ufrag:".concat(frag);
  },
  parseICEPwd: function parseICEPwd(line) {
    return line.substring(10);
  },
  buildICEPwd: function buildICEPwd(pwd) {
    return "a=ice-pwd:".concat(pwd);
  },
  parseMID: function parseMID(line) {
    return line.substring(6);
  },
  parseMLine: function parseMLine(line) {
    var data = {};
    var parts = line.substring(2).split(' ');
    data.media = parts.shift();
    data.port = parts.shift();
    data.proto = parts.shift();

    if (parts[parts.length - 1] === '') {
      // trailing whitespace
      parts.pop();
    }

    data.fmt = parts;
    return data;
  },
  buildMLine: function buildMLine(mline) {
    return "m=".concat(mline.media, " ").concat(mline.port, " ").concat(mline.proto, " ").concat(mline.fmt.join(' '));
  },
  parseRTPMap: function parseRTPMap(line) {
    var data = {};
    var parts = line.substring(9).split(' ');
    data.id = parts.shift();
    parts = parts[0].split('/');
    data.name = parts.shift();
    data.clockrate = parts.shift();
    data.channels = parts.length ? parts.shift() : '1';
    return data;
  },

  /**
   * Parses SDP line "a=sctpmap:..." and extracts SCTP port from it.
   * @param line eg. "a=sctpmap:5000 webrtc-datachannel"
   * @returns [SCTP port number, protocol, streams]
   */
  parseSCTPMap: function parseSCTPMap(line) {
    var parts = line.substring(10).split(' ');
    var sctpPort = parts[0];
    var protocol = parts[1]; // Stream count is optional

    var streamCount = parts.length > 2 ? parts[2] : null;
    return [sctpPort, protocol, streamCount]; // SCTP port
  },
  buildRTPMap: function buildRTPMap(el) {
    var line = "a=rtpmap:".concat(el.getAttribute('id'), " ").concat(el.getAttribute('name'), "/").concat(el.getAttribute('clockrate'));

    if (el.getAttribute('channels') && el.getAttribute('channels') !== '1') {
      line += "/".concat(el.getAttribute('channels'));
    }

    return line;
  },
  parseCrypto: function parseCrypto(line) {
    var data = {};
    var parts = line.substring(9).split(' ');
    data.tag = parts.shift();
    data['crypto-suite'] = parts.shift();
    data['key-params'] = parts.shift();

    if (parts.length) {
      data['session-params'] = parts.join(' ');
    }

    return data;
  },
  parseFingerprint: function parseFingerprint(line) {
    // RFC 4572
    var data = {};
    var parts = line.substring(14).split(' ');
    data.hash = parts.shift();
    data.fingerprint = parts.shift(); // TODO assert that fingerprint satisfies 2UHEX *(":" 2UHEX) ?

    return data;
  },
  parseFmtp: function parseFmtp(line) {
    var data = [];
    var parts = line.split(' ');
    parts.shift();
    parts = parts.join(' ').split(';');

    for (var i = 0; i < parts.length; i++) {
      var key = parts[i].split('=')[0];

      while (key.length && key[0] === ' ') {
        key = key.substring(1);
      }

      var value = parts[i].split('=')[1];

      if (key && value) {
        data.push({
          name: key,
          value: value
        });
      } else if (key) {
        // rfc 4733 (DTMF) style stuff
        data.push({
          name: '',
          value: key
        });
      }
    }

    return data;
  },
  parseICECandidate: function parseICECandidate(line) {
    var candidate = {};
    var elems = line.split(' ');
    candidate.foundation = elems[0].substring(12);
    candidate.component = elems[1];
    candidate.protocol = elems[2].toLowerCase();
    candidate.priority = elems[3];
    candidate.ip = elems[4];
    candidate.port = elems[5]; // elems[6] => "typ"

    candidate.type = elems[7];
    candidate.generation = 0; // default value, may be overwritten below

    for (var i = 8; i < elems.length; i += 2) {
      switch (elems[i]) {
        case 'raddr':
          candidate['rel-addr'] = elems[i + 1];
          break;

        case 'rport':
          candidate['rel-port'] = elems[i + 1];
          break;

        case 'generation':
          candidate.generation = elems[i + 1];
          break;

        case 'tcptype':
          candidate.tcptype = elems[i + 1];
          break;

        default:
          // TODO
          logger.log("parseICECandidate not translating \"".concat(elems[i], "\" = \"").concat(elems[i + 1], "\""));
      }
    }

    candidate.network = '1'; // not applicable to SDP -- FIXME: should be unique, not just random
    // eslint-disable-next-line newline-per-chained-call

    candidate.id = Math.random().toString(36).substr(2, 10);
    return candidate;
  },
  buildICECandidate: function buildICECandidate(cand) {
    var line = ["a=candidate:".concat(cand.foundation), cand.component, cand.protocol, cand.priority, cand.ip, cand.port, 'typ', cand.type].join(' ');
    line += ' ';

    switch (cand.type) {
      case 'srflx':
      case 'prflx':
      case 'relay':
        if (cand.hasOwnAttribute('rel-addr') && cand.hasOwnAttribute('rel-port')) {
          line += 'raddr';
          line += ' ';
          line += cand['rel-addr'];
          line += ' ';
          line += 'rport';
          line += ' ';
          line += cand['rel-port'];
          line += ' ';
        }

        break;
    }

    if (cand.hasOwnAttribute('tcptype')) {
      line += 'tcptype';
      line += ' ';
      line += cand.tcptype;
      line += ' ';
    }

    line += 'generation';
    line += ' ';
    line += cand.hasOwnAttribute('generation') ? cand.generation : '0';
    return line;
  },
  parseSSRC: function parseSSRC(desc) {
    // proprietary mapping of a=ssrc lines
    // TODO: see "Jingle RTP Source Description" by Juberti and P. Thatcher
    // on google docs and parse according to that
    var data = new Map();
    var lines = desc.split('\r\n');

    for (var i = 0; i < lines.length; i++) {
      if (lines[i].substring(0, 7) === 'a=ssrc:') {
        // FIXME: Use regex to smartly find the ssrc.
        var ssrc = lines[i].split('a=ssrc:')[1].split(' ')[0];

        if (!data.get(ssrc)) {
          data.set(ssrc, []);
        }

        data.get(ssrc).push(lines[i]);
      }
    }

    return data;
  },
  parseRTCPFB: function parseRTCPFB(line) {
    var parts = line.substr(10).split(' ');
    var data = {};
    data.pt = parts.shift();
    data.type = parts.shift();
    data.params = parts;
    return data;
  },
  parseExtmap: function parseExtmap(line) {
    var parts = line.substr(9).split(' ');
    var data = {};
    data.value = parts.shift();

    if (data.value.indexOf('/') === -1) {
      data.direction = 'both';
    } else {
      data.direction = data.value.substr(data.value.indexOf('/') + 1);
      data.value = data.value.substr(0, data.value.indexOf('/'));
    }

    data.uri = parts.shift();
    data.params = parts;
    return data;
  },
  findLine: function findLine(haystack, needle, sessionpart) {
    var lines = haystack.split('\r\n');

    for (var i = 0; i < lines.length; i++) {
      if (lines[i].substring(0, needle.length) === needle) {
        return lines[i];
      }
    }

    if (!sessionpart) {
      return false;
    } // search session part


    lines = sessionpart.split('\r\n');

    for (var j = 0; j < lines.length; j++) {
      if (lines[j].substring(0, needle.length) === needle) {
        return lines[j];
      }
    }

    return false;
  },
  findLines: function findLines(haystack, needle, sessionpart) {
    var lines = haystack.split('\r\n');
    var needles = [];

    for (var i = 0; i < lines.length; i++) {
      if (lines[i].substring(0, needle.length) === needle) {
        needles.push(lines[i]);
      }
    }

    if (needles.length || !sessionpart) {
      return needles;
    } // search session part


    lines = sessionpart.split('\r\n');

    for (var j = 0; j < lines.length; j++) {
      if (lines[j].substring(0, needle.length) === needle) {
        needles.push(lines[j]);
      }
    }

    return needles;
  },
  candidateToJingle: function candidateToJingle(line) {
    // a=candidate:2979166662 1 udp 2113937151 192.168.2.100 57698 typ host
    // generation 0
    //      <candidate component=... foundation=... generation=... id=...
    // ip=... network=... port=... priority=... protocol=... type=.../>
    if (line.indexOf('candidate:') === 0) {
      // eslint-disable-next-line no-param-reassign
      line = "a=".concat(line);
    } else if (line.substring(0, 12) !== 'a=candidate:') {
      logger.log('parseCandidate called with a line that is not a candidate' + ' line');
      logger.log(line);
      return null;
    }

    if (line.substring(line.length - 2) === '\r\n') {
      // chomp it
      // eslint-disable-next-line no-param-reassign
      line = line.substring(0, line.length - 2);
    }

    var candidate = {};
    var elems = line.split(' ');

    if (elems[6] !== 'typ') {
      logger.log('did not find typ in the right place');
      logger.log(line);
      return null;
    }

    candidate.foundation = elems[0].substring(12);
    candidate.component = elems[1];
    candidate.protocol = elems[2].toLowerCase();
    candidate.priority = elems[3];
    candidate.ip = elems[4];
    candidate.port = elems[5]; // elems[6] => "typ"

    candidate.type = elems[7];
    candidate.generation = '0'; // default, may be overwritten below

    for (var i = 8; i < elems.length; i += 2) {
      switch (elems[i]) {
        case 'raddr':
          candidate['rel-addr'] = elems[i + 1];
          break;

        case 'rport':
          candidate['rel-port'] = elems[i + 1];
          break;

        case 'generation':
          candidate.generation = elems[i + 1];
          break;

        case 'tcptype':
          candidate.tcptype = elems[i + 1];
          break;

        default:
          // TODO
          logger.log("not translating \"".concat(elems[i], "\" = \"").concat(elems[i + 1], "\""));
      }
    }

    candidate.network = '1'; // not applicable to SDP -- FIXME: should be unique, not just random
    // eslint-disable-next-line newline-per-chained-call

    candidate.id = Math.random().toString(36).substr(2, 10);
    return candidate;
  },
  candidateFromJingle: function candidateFromJingle(cand) {
    var line = 'a=candidate:';
    line += cand.getAttribute('foundation');
    line += ' ';
    line += cand.getAttribute('component');
    line += ' ';
    var protocol = cand.getAttribute('protocol'); // use tcp candidates for FF

    if (_browser["default"].isFirefox() && protocol.toLowerCase() === 'ssltcp') {
      protocol = 'tcp';
    }

    line += protocol; // .toUpperCase(); // chrome M23 doesn't like this

    line += ' ';
    line += cand.getAttribute('priority');
    line += ' ';
    line += cand.getAttribute('ip');
    line += ' ';
    line += cand.getAttribute('port');
    line += ' ';
    line += 'typ';
    line += " ".concat(cand.getAttribute('type'));
    line += ' ';

    switch (cand.getAttribute('type')) {
      case 'srflx':
      case 'prflx':
      case 'relay':
        if (cand.getAttribute('rel-addr') && cand.getAttribute('rel-port')) {
          line += 'raddr';
          line += ' ';
          line += cand.getAttribute('rel-addr');
          line += ' ';
          line += 'rport';
          line += ' ';
          line += cand.getAttribute('rel-port');
          line += ' ';
        }

        break;
    }

    if (protocol.toLowerCase() === 'tcp') {
      line += 'tcptype';
      line += ' ';
      line += cand.getAttribute('tcptype');
      line += ' ';
    }

    line += 'generation';
    line += ' ';
    line += cand.getAttribute('generation') || '0';
    return "".concat(line, "\r\n");
  },

  /**
   * Parse the 'most' primary video ssrc from the given m line
   * @param {object} mLine object as parsed from transform.parse
   * @return {number} the primary video ssrc from the given m line
   */
  parsePrimaryVideoSsrc: function parsePrimaryVideoSsrc(videoMLine) {
    var numSsrcs = videoMLine.ssrcs.map(function (ssrcInfo) {
      return ssrcInfo.id;
    }).filter(function (ssrc, index, array) {
      return array.indexOf(ssrc) === index;
    }).length;
    var numGroups = videoMLine.ssrcGroups && videoMLine.ssrcGroups.length || 0;

    if (numSsrcs > 1 && numGroups === 0) {
      // Ambiguous, can't figure out the primary
      return;
    }

    var primarySsrc = null;

    if (numSsrcs === 1) {
      primarySsrc = videoMLine.ssrcs[0].id;
    } else if (numSsrcs === 2) {
      // Can figure it out if there's an FID group
      var fidGroup = videoMLine.ssrcGroups.find(function (group) {
        return group.semantics === 'FID';
      });

      if (fidGroup) {
        primarySsrc = fidGroup.ssrcs.split(' ')[0];
      }
    } else if (numSsrcs >= 3) {
      // Can figure it out if there's a sim group
      var simGroup = videoMLine.ssrcGroups.find(function (group) {
        return group.semantics === 'SIM';
      });

      if (simGroup) {
        primarySsrc = simGroup.ssrcs.split(' ')[0];
      }
    }

    return primarySsrc;
  },

  /**
   * Generate an ssrc
   * @returns {number} an ssrc
   */
  generateSsrc: function generateSsrc() {
    return _RandomUtil["default"].randomInt(1, 0xffffffff);
  },

  /**
   * Get an attribute for the given ssrc with the given attributeName
   *  from the given mline
   * @param {object} mLine an mLine object as parsed from transform.parse
   * @param {number} ssrc the ssrc for which an attribtue is desired
   * @param {string} attributeName the name of the desired attribute
   * @returns {string} the value corresponding to the given ssrc
   *  and attributeName
   */
  getSsrcAttribute: function getSsrcAttribute(mLine, ssrc, attributeName) {
    for (var i = 0; i < mLine.ssrcs.length; ++i) {
      var ssrcLine = mLine.ssrcs[i];

      if (ssrcLine.id === ssrc && ssrcLine.attribute === attributeName) {
        return ssrcLine.value;
      }
    }
  },

  /**
   * Parses the ssrcs from the group sdp line and
   *  returns them as a list of numbers
   * @param {object} the ssrcGroup object as parsed from
   *  sdp-transform
   * @returns {list<number>} a list of the ssrcs in the group
   *  parsed as numbers
   */
  parseGroupSsrcs: function parseGroupSsrcs(ssrcGroup) {
    return ssrcGroup.ssrcs.split(' ').map(function (ssrcStr) {
      return parseInt(ssrcStr, 10);
    });
  },

  /**
   * Get the mline of the given type from the given sdp
   * @param {object} sdp sdp as parsed from transform.parse
   * @param {string} type the type of the desired mline (e.g. "video")
   * @returns {object} a media object
   */
  getMedia: function getMedia(sdp, type) {
    return sdp.media.find(function (m) {
      return m.type === type;
    });
  },

  /**
   * Extracts the ICE username fragment from an SDP string.
   * @param {string} sdp the SDP in raw text format
   */
  getUfrag: function getUfrag(sdp) {
    var ufragLines = sdp.split('\n').filter(function (line) {
      return line.startsWith('a=ice-ufrag:');
    });

    if (ufragLines.length > 0) {
      return ufragLines[0].substr('a=ice-ufrag:'.length);
    }
  },

  /**
   * Sets the given codecName as the preferred codec by
   *  moving it to the beginning of the payload types
   *  list (modifies the given mline in place).  If there
   *  are multiple options within the same codec (multiple h264
   *  profiles, for instance), this will prefer the first one
   *  that is found.
   * @param {object} videoMLine the video mline object from
   *  an sdp as parsed by transform.parse
   * @param {string} codecName the name of the preferred codec
   */
  preferVideoCodec: function preferVideoCodec(videoMLine, codecName) {
    var payloadType = null;

    if (!videoMLine || !codecName) {
      return;
    }

    for (var i = 0; i < videoMLine.rtp.length; ++i) {
      var rtp = videoMLine.rtp[i];

      if (rtp.codec && rtp.codec.toLowerCase() === codecName.toLowerCase()) {
        payloadType = rtp.payload;
        break;
      }
    }

    if (payloadType) {
      // Call toString() on payloads to get around an issue within
      // SDPTransform that sets payloads as a number, instead of a string,
      // when there is only one payload.
      var payloadTypes = videoMLine.payloads.toString().split(' ').map(function (p) {
        return parseInt(p, 10);
      });
      var payloadIndex = payloadTypes.indexOf(payloadType);
      payloadTypes.splice(payloadIndex, 1);
      payloadTypes.unshift(payloadType);
      videoMLine.payloads = payloadTypes.join(' ');
    }
  },

  /**
   * Strips the given codec from the given mline. All related RTX payload
   * types are also stripped. If the resulting mline would have no codecs,
   * it's disabled.
   *
   * @param {object} videoMLine the video mline object from an sdp as parsed
   * by transform.parse.
   * @param {string} codecName the name of the codec which will be stripped.
   */
  stripVideoCodec: function stripVideoCodec(videoMLine, codecName) {
    if (!videoMLine || !codecName) {
      return;
    }

    var removePts = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = videoMLine.rtp[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var rtp = _step.value;

        if (rtp.codec && rtp.codec.toLowerCase() === codecName.toLowerCase()) {
          removePts.push(rtp.payload);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (removePts.length > 0) {
      // We also need to remove the payload types that are related to RTX
      // for the codecs we want to disable.
      var rtxApts = removePts.map(function (item) {
        return "apt=".concat(item);
      });
      var rtxPts = videoMLine.fmtp.filter(function (item) {
        return rtxApts.indexOf(item.config) !== -1;
      });
      removePts.push.apply(removePts, _toConsumableArray(rtxPts.map(function (item) {
        return item.payload;
      }))); // Call toString() on payloads to get around an issue within
      // SDPTransform that sets payloads as a number, instead of a string,
      // when there is only one payload.

      var allPts = videoMLine.payloads.toString().split(' ').map(Number);
      var keepPts = allPts.filter(function (pt) {
        return removePts.indexOf(pt) === -1;
      });

      if (keepPts.length === 0) {
        // There are no other video codecs, disable the stream.
        videoMLine.port = 0;
        videoMLine.direction = 'inactive';
        videoMLine.payloads = '*';
      } else {
        videoMLine.payloads = keepPts.join(' ');
      }

      videoMLine.rtp = videoMLine.rtp.filter(function (item) {
        return keepPts.indexOf(item.payload) !== -1;
      });
      videoMLine.fmtp = videoMLine.fmtp.filter(function (item) {
        return keepPts.indexOf(item.payload) !== -1;
      });

      if (videoMLine.rtcpFb) {
        videoMLine.rtcpFb = videoMLine.rtcpFb.filter(function (item) {
          return keepPts.indexOf(item.payload) !== -1;
        });
      }
    }
  }
};
var _default = SDPUtil;
exports["default"] = _default;
"use strict";

var _SDPUtil = _interopRequireDefault(require("./SDPUtil"));

var SampleSdpStrings = _interopRequireWildcard(require("./SampleSdpStrings.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

describe('SDPUtil', function () {
  it('should parse an ice ufrag correctly', function () {
    var line = 'a=ice-ufrag:3jlcc1b3j1rqt6';

    var parsed = _SDPUtil["default"].parseICEUfrag(line);

    expect(parsed).toEqual('3jlcc1b3j1rqt6');
  });
  describe('preferVideoCodec', function () {
    it('should move a preferred codec to the front', function () {
      var sdp = SampleSdpStrings.multiCodecVideoSdp;
      var videoMLine = sdp.media.find(function (m) {
        return m.type === 'video';
      });

      _SDPUtil["default"].preferVideoCodec(videoMLine, 'H264');

      var newPayloadTypesOrder = videoMLine.payloads.split(' ').map(function (ptStr) {
        return parseInt(ptStr, 10);
      });
      expect(newPayloadTypesOrder[0]).toEqual(126);
    });
  });
  describe('stripVideoCodec', function () {
    it('should remove a codec', function () {
      var sdp = SampleSdpStrings.multiCodecVideoSdp;
      var videoMLine = sdp.media.find(function (m) {
        return m.type === 'video';
      });

      _SDPUtil["default"].stripVideoCodec(videoMLine, 'H264');

      var newPayloadTypes = videoMLine.payloads.split(' ').map(Number);
      expect(newPayloadTypes.length).toEqual(1);
      expect(newPayloadTypes[0]).toEqual(100);
    });
  });
});
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jitsiMeetLogger = require("jitsi-meet-logger");

var MediaType = _interopRequireWildcard(require("../../service/RTC/MediaType"));

var SignalingEvents = _interopRequireWildcard(require("../../service/RTC/SignalingEvents"));

var _SignalingLayer2 = _interopRequireDefault(require("../../service/RTC/SignalingLayer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var logger = (0, _jitsiMeetLogger.getLogger)(__filename);
/**
 * Default XMPP implementation of the {@link SignalingLayer} interface. Obtains
 * the data from the MUC presence.
 */

var SignalingLayerImpl =
/*#__PURE__*/
function (_SignalingLayer) {
  _inherits(SignalingLayerImpl, _SignalingLayer);

  /**
   * Creates new instance.
   */
  function SignalingLayerImpl() {
    var _this;

    _classCallCheck(this, SignalingLayerImpl);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SignalingLayerImpl).call(this));
    /**
     * A map that stores SSRCs of remote streams. And is used only locally
     * We store the mapping when jingle is received, and later is used
     * onaddstream webrtc event where we have only the ssrc
     * FIXME: This map got filled and never cleaned and can grow during long
     * conference
     * @type {Map<number, string>} maps SSRC number to jid
     */

    _this.ssrcOwners = new Map();
    /**
     *
     * @type {ChatRoom|null}
     */

    _this.chatRoom = null;
    return _this;
  }
  /**
   * Sets the <tt>ChatRoom</tt> instance used and binds presence listeners.
   * @param {ChatRoom} room
   */


  _createClass(SignalingLayerImpl, [{
    key: "setChatRoom",
    value: function setChatRoom(room) {
      var _this2 = this;

      var oldChatRoom = this.chatRoom;
      this.chatRoom = room;

      if (oldChatRoom) {
        oldChatRoom.removePresenceListener('audiomuted', this._audioMuteHandler);
        oldChatRoom.removePresenceListener('videomuted', this._videoMuteHandler);
        oldChatRoom.removePresenceListener('videoType', this._videoTypeHandler);
      }

      if (room) {
        // SignalingEvents
        this._audioMuteHandler = function (node, from) {
          _this2.eventEmitter.emit(SignalingEvents.PEER_MUTED_CHANGED, from, MediaType.AUDIO, node.value === 'true');
        };

        room.addPresenceListener('audiomuted', this._audioMuteHandler);

        this._videoMuteHandler = function (node, from) {
          _this2.eventEmitter.emit(SignalingEvents.PEER_MUTED_CHANGED, from, MediaType.VIDEO, node.value === 'true');
        };

        room.addPresenceListener('videomuted', this._videoMuteHandler);

        this._videoTypeHandler = function (node, from) {
          _this2.eventEmitter.emit(SignalingEvents.PEER_VIDEO_TYPE_CHANGED, from, node.value);
        };

        room.addPresenceListener('videoType', this._videoTypeHandler);
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "getPeerMediaInfo",
    value: function getPeerMediaInfo(owner, mediaType) {
      if (this.chatRoom) {
        return this.chatRoom.getMediaPresenceInfo(owner, mediaType);
      }

      logger.error('Requested peer media info, before room was set');
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "getSSRCOwner",
    value: function getSSRCOwner(ssrc) {
      return this.ssrcOwners.get(ssrc);
    }
    /**
     * Set an SSRC owner.
     * @param {number} ssrc an SSRC to be owned
     * @param {string} endpointId owner's ID (MUC nickname)
     * @throws TypeError if <tt>ssrc</tt> is not a number
     */

  }, {
    key: "setSSRCOwner",
    value: function setSSRCOwner(ssrc, endpointId) {
      if (typeof ssrc !== 'number') {
        throw new TypeError("SSRC(".concat(ssrc, ") must be a number"));
      }

      this.ssrcOwners.set(ssrc, endpointId);
    }
  }]);

  return SignalingLayerImpl;
}(_SignalingLayer2["default"]);

exports["default"] = SignalingLayerImpl;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

var _jitsiMeetLogger = require("jitsi-meet-logger");

var _strophe = require("strophe.js");

var _ChatRoom = _interopRequireDefault(require("./ChatRoom"));

var _ConnectionPlugin = require("./ConnectionPlugin");

var _XMPPEvents = _interopRequireDefault(require("../../service/xmpp/XMPPEvents"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var logger = (0, _jitsiMeetLogger.getLogger)(__filename);
/**
 * MUC connection plugin.
 */

var MucConnectionPlugin =
/*#__PURE__*/
function (_ConnectionPluginList) {
  _inherits(MucConnectionPlugin, _ConnectionPluginList);

  /**
   *
   * @param xmpp
   */
  function MucConnectionPlugin(xmpp) {
    var _this;

    _classCallCheck(this, MucConnectionPlugin);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MucConnectionPlugin).call(this));
    _this.xmpp = xmpp;
    _this.rooms = {};
    return _this;
  }
  /**
   *
   * @param connection
   */


  _createClass(MucConnectionPlugin, [{
    key: "init",
    value: function init(connection) {
      _get(_getPrototypeOf(MucConnectionPlugin.prototype), "init", this).call(this, connection); // add handlers (just once)


      this.connection.addHandler(this.onPresence.bind(this), null, 'presence', null, null, null, null);
      this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, 'presence', 'unavailable', null);
      this.connection.addHandler(this.onPresenceError.bind(this), null, 'presence', 'error', null);
      this.connection.addHandler(this.onMessage.bind(this), null, 'message', null, null);
      this.connection.addHandler(this.onMute.bind(this), 'http://jitsi.org/jitmeet/audio', 'iq', 'set', null, null);
    }
    /**
     *
     * @param jid
     * @param password
     * @param options
     */

  }, {
    key: "createRoom",
    value: function createRoom(jid, password, options) {
      var roomJid = _strophe.Strophe.getBareJidFromJid(jid);

      if (this.rooms[roomJid]) {
        var errmsg = 'You are already in the room!';
        logger.warn(errmsg);
        return this.rooms[roomJid];
      }

      this.rooms[roomJid] = new _ChatRoom["default"](this.connection, jid, password, this.xmpp, options);
      this.eventEmitter.emit(_XMPPEvents["default"].EMUC_ROOM_ADDED, this.rooms[roomJid]);
      return this.rooms[roomJid];
    }
    /**
     *
     * @param jid
     */

  }, {
    key: "doLeave",
    value: function doLeave(jid) {
      this.eventEmitter.emit(_XMPPEvents["default"].EMUC_ROOM_REMOVED, this.rooms[jid]);
      delete this.rooms[jid];
    }
    /**
     *
     * @param pres
     */

  }, {
    key: "onPresence",
    value: function onPresence(pres) {
      var from = pres.getAttribute('from'); // What is this for? A workaround for something?

      if (pres.getAttribute('type')) {
        return true;
      }

      var room = this.rooms[_strophe.Strophe.getBareJidFromJid(from)];

      if (!room) {
        return true;
      } // Parse status.


      if ($(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]' + '>status[code="201"]').length) {
        room.createNonAnonymousRoom();
      }

      room.onPresence(pres);
      return true;
    }
    /**
     *
     * @param pres
     */

  }, {
    key: "onPresenceUnavailable",
    value: function onPresenceUnavailable(pres) {
      var from = pres.getAttribute('from');

      var room = this.rooms[_strophe.Strophe.getBareJidFromJid(from)];

      if (!room) {
        return true;
      }

      room.onPresenceUnavailable(pres, from);
      return true;
    }
    /**
     *
     * @param pres
     */

  }, {
    key: "onPresenceError",
    value: function onPresenceError(pres) {
      var from = pres.getAttribute('from');

      var room = this.rooms[_strophe.Strophe.getBareJidFromJid(from)];

      if (!room) {
        return true;
      }

      room.onPresenceError(pres, from);
      return true;
    }
    /**
     *
     * @param msg
     */

  }, {
    key: "onMessage",
    value: function onMessage(msg) {
      // FIXME: this is a hack. but jingle on muc makes nickchanges hard
      var from = msg.getAttribute('from');

      var room = this.rooms[_strophe.Strophe.getBareJidFromJid(from)];

      if (!room) {
        return true;
      }

      room.onMessage(msg, from);
      return true;
    }
    /**
     * TODO: Document
     * @param iq
     */

  }, {
    key: "onMute",
    value: function onMute(iq) {
      var from = iq.getAttribute('from');

      var room = this.rooms[_strophe.Strophe.getBareJidFromJid(from)]; // XXX What are the semantics of the return value? Why is it sometimes
      // undefined and sometimes a boolean?


      if (!room) {
        return true;
      }

      room.onMute(iq);
      return true;
    }
  }]);

  return MucConnectionPlugin;
}(_ConnectionPlugin.ConnectionPluginListenable);
/**
 *
 * @param XMPP
 */


function _default(XMPP) {
  _strophe.Strophe.addConnectionPlugin('emuc', new MucConnectionPlugin(XMPP));
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = initJingle;

var _AnalyticsEvents = require("../../service/statistics/AnalyticsEvents");

var _jitsiMeetLogger = require("jitsi-meet-logger");

var _strophe = require("strophe.js");

var _XMPPEvents = _interopRequireDefault(require("../../service/xmpp/XMPPEvents"));

var _GlobalOnErrorHandler = _interopRequireDefault(require("../util/GlobalOnErrorHandler"));

var _RandomUtil = _interopRequireDefault(require("../util/RandomUtil"));

var _statistics = _interopRequireDefault(require("../statistics/statistics"));

var _JingleSessionPC = _interopRequireDefault(require("./JingleSessionPC"));

var _ConnectionPlugin2 = _interopRequireDefault(require("./ConnectionPlugin"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var logger = (0, _jitsiMeetLogger.getLogger)(__filename); // XXX Strophe is build around the idea of chaining function calls so allow long
// function call chains.

/* eslint-disable newline-per-chained-call */

/**
 *
 */

var JingleConnectionPlugin =
/*#__PURE__*/
function (_ConnectionPlugin) {
  _inherits(JingleConnectionPlugin, _ConnectionPlugin);

  /**
   * Creates new <tt>JingleConnectionPlugin</tt>
   * @param {XMPP} xmpp
   * @param {EventEmitter} eventEmitter
   * @param {Object} iceConfig an object that holds the iceConfig to be passed
   * to the p2p and the jvb <tt>PeerConnection</tt>.
   */
  function JingleConnectionPlugin(xmpp, eventEmitter, iceConfig) {
    var _this;

    _classCallCheck(this, JingleConnectionPlugin);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(JingleConnectionPlugin).call(this));
    _this.xmpp = xmpp;
    _this.eventEmitter = eventEmitter;
    _this.sessions = {};
    _this.jvbIceConfig = iceConfig.jvb;
    _this.p2pIceConfig = iceConfig.p2p;
    _this.mediaConstraints = {
      offerToReceiveAudio: true,
      offerToReceiveVideo: true
    };
    return _this;
  }
  /**
   *
   * @param connection
   */


  _createClass(JingleConnectionPlugin, [{
    key: "init",
    value: function init(connection) {
      _get(_getPrototypeOf(JingleConnectionPlugin.prototype), "init", this).call(this, connection);

      this.connection.addHandler(this.onJingle.bind(this), 'urn:xmpp:jingle:1', 'iq', 'set', null, null);
    }
    /**
     *
     * @param iq
     */

  }, {
    key: "onJingle",
    value: function onJingle(iq) {
      var sid = $(iq).find('jingle').attr('sid');
      var action = $(iq).find('jingle').attr('action');
      var fromJid = iq.getAttribute('from'); // send ack first

      var ack = (0, _strophe.$iq)({
        type: 'result',
        to: fromJid,
        id: iq.getAttribute('id')
      });
      logger.log("on jingle ".concat(action, " from ").concat(fromJid), iq);
      var sess = this.sessions[sid];

      if (action !== 'session-initiate') {
        if (!sess) {
          ack.attrs({
            type: 'error'
          });
          ack.c('error', {
            type: 'cancel'
          }).c('item-not-found', {
            xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'
          }).up().c('unknown-session', {
            xmlns: 'urn:xmpp:jingle:errors:1'
          });
          logger.warn('invalid session id', iq);
          this.connection.send(ack);
          return true;
        } // local jid is not checked


        if (fromJid !== sess.remoteJid) {
          logger.warn('jid mismatch for session id', sid, sess.remoteJid, iq);
          ack.attrs({
            type: 'error'
          });
          ack.c('error', {
            type: 'cancel'
          }).c('item-not-found', {
            xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'
          }).up().c('unknown-session', {
            xmlns: 'urn:xmpp:jingle:errors:1'
          });
          this.connection.send(ack);
          return true;
        }
      } else if (sess !== undefined) {
        // Existing session with same session id. This might be out-of-order
        // if the sess.remoteJid is the same as from.
        ack.attrs({
          type: 'error'
        });
        ack.c('error', {
          type: 'cancel'
        }).c('service-unavailable', {
          xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'
        }).up();
        logger.warn('duplicate session id', sid, iq);
        this.connection.send(ack);
        return true;
      }

      var now = window.performance.now(); // FIXME that should work most of the time, but we'd have to
      // think how secure it is to assume that user with "focus"
      // nickname is Jicofo.

      var isP2P = _strophe.Strophe.getResourceFromJid(fromJid) !== 'focus'; // see http://xmpp.org/extensions/xep-0166.html#concepts-session

      switch (action) {
        case 'session-initiate':
          {
            logger.log('(TIME) received session-initiate:\t', now);
            var startMuted = $(iq).find('jingle>startmuted');

            if (startMuted && startMuted.length > 0) {
              var audioMuted = startMuted.attr('audio');
              var videoMuted = startMuted.attr('video');
              this.eventEmitter.emit(_XMPPEvents["default"].START_MUTED_FROM_FOCUS, audioMuted === 'true', videoMuted === 'true');
            }

            logger.info("Marking session from ".concat(fromJid, " as ").concat(isP2P ? '' : '*not*', " P2P"));
            sess = new _JingleSessionPC["default"]($(iq).find('jingle').attr('sid'), $(iq).attr('to'), fromJid, this.connection, this.mediaConstraints, isP2P ? this.p2pIceConfig : this.jvbIceConfig, isP2P,
            /* initiator */
            false);
            this.sessions[sess.sid] = sess;
            this.eventEmitter.emit(_XMPPEvents["default"].CALL_INCOMING, sess, $(iq).find('>jingle'), now);
            break;
          }

        case 'session-accept':
          {
            this.eventEmitter.emit(_XMPPEvents["default"].CALL_ACCEPTED, sess, $(iq).find('>jingle'));
            break;
          }

        case 'content-modify':
          {
            sess.modifyContents($(iq).find('>jingle'));
            break;
          }

        case 'transport-info':
          {
            this.eventEmitter.emit(_XMPPEvents["default"].TRANSPORT_INFO, sess, $(iq).find('>jingle'));
            break;
          }

        case 'session-terminate':
          {
            logger.log('terminating...', sess.sid);
            var reasonCondition = null;
            var reasonText = null;

            if ($(iq).find('>jingle>reason').length) {
              reasonCondition = $(iq).find('>jingle>reason>:first')[0].tagName;
              reasonText = $(iq).find('>jingle>reason>text').text();
            }

            this.terminate(sess.sid, reasonCondition, reasonText);
            this.eventEmitter.emit(_XMPPEvents["default"].CALL_ENDED, sess, reasonCondition, reasonText);
            break;
          }

        case 'transport-replace':
          logger.info('(TIME) Start transport replace', now);

          _statistics["default"].sendAnalytics((0, _AnalyticsEvents.createJingleEvent)(_AnalyticsEvents.ACTION_JINGLE_TR_RECEIVED, {
            p2p: isP2P,
            value: now
          }));

          sess.replaceTransport($(iq).find('>jingle'), function () {
            var successTime = window.performance.now();
            logger.info('(TIME) Transport replace success!', successTime);

            _statistics["default"].sendAnalytics((0, _AnalyticsEvents.createJingleEvent)(_AnalyticsEvents.ACTION_JINGLE_TR_SUCCESS, {
              p2p: isP2P,
              value: successTime
            }));
          }, function (error) {
            _GlobalOnErrorHandler["default"].callErrorHandler(error);

            logger.error('Transport replace failed', error);
            sess.sendTransportReject();
          });
          break;

        case 'addsource': // FIXME: proprietary, un-jingleish

        case 'source-add':
          // FIXME: proprietary
          sess.addRemoteStream($(iq).find('>jingle>content'));
          break;

        case 'removesource': // FIXME: proprietary, un-jingleish

        case 'source-remove':
          // FIXME: proprietary
          sess.removeRemoteStream($(iq).find('>jingle>content'));
          break;

        default:
          logger.warn('jingle action not implemented', action);
          ack.attrs({
            type: 'error'
          });
          ack.c('error', {
            type: 'cancel'
          }).c('bad-request', {
            xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'
          }).up();
          break;
      }

      this.connection.send(ack);
      return true;
    }
    /**
     * Creates new <tt>JingleSessionPC</tt> meant to be used in a direct P2P
     * connection, configured as 'initiator'.
     * @param {string} me our JID
     * @param {string} peer remote participant's JID
     * @return {JingleSessionPC}
     */

  }, {
    key: "newP2PJingleSession",
    value: function newP2PJingleSession(me, peer) {
      var sess = new _JingleSessionPC["default"](_RandomUtil["default"].randomHexString(12), me, peer, this.connection, this.mediaConstraints, this.p2pIceConfig,
      /* P2P */
      true,
      /* initiator */
      true);
      this.sessions[sess.sid] = sess;
      return sess;
    }
    /**
     *
     * @param sid
     * @param reasonCondition
     * @param reasonText
     */

  }, {
    key: "terminate",
    value: function terminate(sid, reasonCondition, reasonText) {
      if (this.sessions.hasOwnProperty(sid)) {
        if (this.sessions[sid].state !== 'ended') {
          this.sessions[sid].onTerminated(reasonCondition, reasonText);
        }

        delete this.sessions[sid];
      }
    }
    /**
     *
     */

  }, {
    key: "getStunAndTurnCredentials",
    value: function getStunAndTurnCredentials() {
      var _this2 = this;

      // get stun and turn configuration from server via xep-0215
      // uses time-limited credentials as described in
      // http://tools.ietf.org/html/draft-uberti-behave-turn-rest-00
      //
      // See https://modules.prosody.im/mod_turncredentials.html
      // for a prosody module which implements this.
      //
      // Currently, this doesn't work with updateIce and therefore credentials
      // with a long validity have to be fetched before creating the
      // peerconnection.
      // TODO: implement refresh via updateIce as described in
      //      https://code.google.com/p/webrtc/issues/detail?id=1650
      this.connection.sendIQ((0, _strophe.$iq)({
        type: 'get',
        to: this.connection.domain
      }).c('services', {
        xmlns: 'urn:xmpp:extdisco:1'
      }), function (res) {
        var iceservers = [];
        $(res).find('>services>service').each(function (idx, el) {
          // eslint-disable-next-line no-param-reassign
          el = $(el);
          var dict = {};
          var type = el.attr('type');

          switch (type) {
            case 'stun':
              dict.url = "stun:".concat(el.attr('host'));

              if (el.attr('port')) {
                dict.url += ":".concat(el.attr('port'));
              }

              iceservers.push(dict);
              break;

            case 'turn':
            case 'turns':
              {
                dict.url = "".concat(type, ":");
                var username = el.attr('username'); // https://code.google.com/p/webrtc/issues/detail
                // ?id=1508

                if (username) {
                  var match = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);

                  if (match && parseInt(match[2], 10) < 28) {
                    dict.url += "".concat(username, "@");
                  } else {
                    // only works in M28
                    dict.username = username;
                  }
                }

                dict.url += el.attr('host');
                var port = el.attr('port');

                if (port) {
                  dict.url += ":".concat(el.attr('port'));
                }

                var transport = el.attr('transport');

                if (transport && transport !== 'udp') {
                  dict.url += "?transport=".concat(transport);
                }

                dict.credential = el.attr('password') || dict.credential;
                iceservers.push(dict);
                break;
              }
          }
        });
        var options = _this2.xmpp.options;

        if (options.useStunTurn) {
          // we want to filter and leave only tcp/turns candidates
          // which make sense for the jvb connections
          _this2.jvbIceConfig.iceServers = iceservers.filter(function (s) {
            return s.url.startsWith('turns');
          });
        }

        if (options.p2p && options.p2p.useStunTurn) {
          _this2.p2pIceConfig.iceServers = iceservers;
        }
      }, function (err) {
        logger.warn('getting turn credentials failed', err);
        logger.warn('is mod_turncredentials or similar installed?');
      }); // implement push?
    }
    /**
     * Returns the data saved in 'updateLog' in a format to be logged.
     */

  }, {
    key: "getLog",
    value: function getLog() {
      var _this3 = this;

      var data = {};
      Object.keys(this.sessions).forEach(function (sid) {
        var session = _this3.sessions[sid];
        var pc = session.peerconnection;

        if (pc && pc.updateLog) {
          // FIXME: should probably be a .dump call
          data["jingle_".concat(sid)] = {
            updateLog: pc.updateLog,
            stats: pc.stats,
            url: window.location.href
          };
        }
      });
      return data;
    }
  }]);

  return JingleConnectionPlugin;
}(_ConnectionPlugin2["default"]);
/* eslint-enable newline-per-chained-call */

/**
 *
 * @param XMPP
 * @param eventEmitter
 * @param iceConfig
 */


function initJingle(XMPP, eventEmitter, iceConfig) {
  _strophe.Strophe.addConnectionPlugin('jingle', new JingleConnectionPlugin(XMPP, eventEmitter, iceConfig));
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

var _strophe = require("strophe.js");

var _ConnectionPlugin2 = _interopRequireDefault(require("./ConnectionPlugin"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 *  Logs raw stanzas and makes them available for download as JSON
 */
var StropheLogger =
/*#__PURE__*/
function (_ConnectionPlugin) {
  _inherits(StropheLogger, _ConnectionPlugin);

  /**
   *
   */
  function StropheLogger() {
    var _this;

    _classCallCheck(this, StropheLogger);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(StropheLogger).call(this));
    _this.log = [];
    return _this;
  }
  /**
   *
   * @param connection
   */


  _createClass(StropheLogger, [{
    key: "init",
    value: function init(connection) {
      _get(_getPrototypeOf(StropheLogger.prototype), "init", this).call(this, connection);

      this.connection.rawInput = this.logIncoming.bind(this);
      this.connection.rawOutput = this.logOutgoing.bind(this);
    }
    /**
     *
     * @param stanza
     */

  }, {
    key: "logIncoming",
    value: function logIncoming(stanza) {
      this.log.push([new Date().getTime(), 'incoming', stanza]);
    }
    /**
     *
     * @param stanza
     */

  }, {
    key: "logOutgoing",
    value: function logOutgoing(stanza) {
      this.log.push([new Date().getTime(), 'outgoing', stanza]);
    }
  }]);

  return StropheLogger;
}(_ConnectionPlugin2["default"]);
/**
 *
 */


function _default() {
  _strophe.Strophe.addConnectionPlugin('logger', new StropheLogger());
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

var _jitsiMeetLogger = require("jitsi-meet-logger");

var _strophe = require("strophe.js");

var _GlobalOnErrorHandler = _interopRequireDefault(require("../util/GlobalOnErrorHandler"));

var _ConnectionPlugin2 = _interopRequireDefault(require("./ConnectionPlugin"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var logger = (0, _jitsiMeetLogger.getLogger)(__filename);
/**
 * Ping every 10 sec
 */

var PING_INTERVAL = 10000;
/**
 * Ping timeout error after 15 sec of waiting.
 */

var PING_TIMEOUT = 15000;
/**
 * Will close the connection after 3 consecutive ping errors.
 */

var PING_THRESHOLD = 3;
/**
 * The number of timestamps of send pings to keep.
 * The current value is 2 minutes.
 * @type {number} number of timestamps.
 */

var PING_TIMESTAMPS_TO_KEEP = 120000 / PING_INTERVAL;
/**
 * XEP-0199 ping plugin.
 *
 * Registers "urn:xmpp:ping" namespace under Strophe.NS.PING.
 */

var PingConnectionPlugin =
/*#__PURE__*/
function (_ConnectionPlugin) {
  _inherits(PingConnectionPlugin, _ConnectionPlugin);

  /**
   * Contructs new object
   * @param {XMPP} xmpp the xmpp module.
   * @constructor
   */
  function PingConnectionPlugin(xmpp) {
    var _this;

    _classCallCheck(this, PingConnectionPlugin);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PingConnectionPlugin).call(this));
    _this.failedPings = 0;
    _this.xmpp = xmpp;
    _this.pingExecIntervals = new Array(PING_TIMESTAMPS_TO_KEEP);
    return _this;
  }
  /**
   * Initializes the plugin. Method called by Strophe.
   * @param connection Strophe connection instance.
   */


  _createClass(PingConnectionPlugin, [{
    key: "init",
    value: function init(connection) {
      _get(_getPrototypeOf(PingConnectionPlugin.prototype), "init", this).call(this, connection);

      _strophe.Strophe.addNamespace('PING', 'urn:xmpp:ping');
    }
    /* eslint-disable max-params */

    /**
     * Sends "ping" to given <tt>jid</tt>
     * @param jid the JID to which ping request will be sent.
     * @param success callback called on success.
     * @param error callback called on error.
     * @param timeout ms how long are we going to wait for the response. On
     * timeout <tt>error<//t> callback is called with undefined error argument.
     */

  }, {
    key: "ping",
    value: function ping(jid, success, error, timeout) {
      this._addPingExecutionTimestamp();

      var iq = (0, _strophe.$iq)({
        type: 'get',
        to: jid
      });
      iq.c('ping', {
        xmlns: _strophe.Strophe.NS.PING
      });
      this.connection.sendIQ(iq, success, error, timeout);
    }
    /* eslint-enable max-params */

    /**
     * Starts to send ping in given interval to specified remote JID.
     * This plugin supports only one such task and <tt>stopInterval</tt>
     * must be called before starting a new one.
     * @param remoteJid remote JID to which ping requests will be sent to.
     * @param interval task interval in ms.
     */

  }, {
    key: "startInterval",
    value: function startInterval(remoteJid) {
      var _this2 = this;

      var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PING_INTERVAL;

      if (this.intervalId) {
        var errmsg = 'Ping task scheduled already';

        _GlobalOnErrorHandler["default"].callErrorHandler(new Error(errmsg));

        logger.error(errmsg);
        return;
      }

      this.intervalId = window.setInterval(function () {
        _this2.ping(remoteJid, function () {
          _this2.failedPings = 0;
        }, function (error) {
          _this2.failedPings += 1;
          var errmsg = "Ping ".concat(error ? 'error' : 'timeout');

          if (_this2.failedPings >= PING_THRESHOLD) {
            _GlobalOnErrorHandler["default"].callErrorHandler(new Error(errmsg));

            logger.error(errmsg, error); // FIXME it doesn't help to disconnect when 3rd PING
            // times out, it only stops Strophe from retrying.
            // Not really sure what's the right thing to do in that
            // situation, but just closing the connection makes no
            // sense.
            // self.connection.disconnect();
          } else {
            logger.warn(errmsg, error);
          }
        }, PING_TIMEOUT);
      }, interval);
      logger.info("XMPP pings will be sent every ".concat(interval, " ms"));
    }
    /**
     * Stops current "ping"  interval task.
     */

  }, {
    key: "stopInterval",
    value: function stopInterval() {
      if (this.intervalId) {
        window.clearInterval(this.intervalId);
        this.intervalId = null;
        this.failedPings = 0;
        logger.info('Ping interval cleared');
      }
    }
    /**
     * Adds the current time to the array of send ping timestamps.
     * @private
     */

  }, {
    key: "_addPingExecutionTimestamp",
    value: function _addPingExecutionTimestamp() {
      this.pingExecIntervals.push(new Date().getTime()); // keep array length to PING_TIMESTAMPS_TO_KEEP

      if (this.pingExecIntervals.length > PING_TIMESTAMPS_TO_KEEP) {
        this.pingExecIntervals.shift();
      }
    }
    /**
     * Returns the maximum time between the recent sent pings, if there is a
     * big value it means the computer was inactive for some time(suspended).
     * Checks the maximum gap between sending pings, considering and the
     * current time. Trying to detect computer inactivity (sleep).
     *
     * @returns {int} the time ping was suspended, if it was not 0 is returned.
     */

  }, {
    key: "getPingSuspendTime",
    value: function getPingSuspendTime() {
      var pingIntervals = this.pingExecIntervals.slice(); // we need current time, as if ping was sent now
      // if computer sleeps we will get correct interval after next
      // scheduled ping, bet we sometimes need that interval before waiting
      // for the next ping, on closing the connection on error.

      pingIntervals.push(new Date().getTime());
      var maxInterval = 0;
      var previousTS = pingIntervals[0];
      pingIntervals.forEach(function (e) {
        var currentInterval = e - previousTS;

        if (currentInterval > maxInterval) {
          maxInterval = currentInterval;
        }

        previousTS = e;
      }); // remove the interval between the ping sent
      // this way in normal execution there is no suspend and the return
      // will be 0 or close to 0.

      maxInterval -= PING_INTERVAL; // make sure we do not return less than 0

      return Math.max(maxInterval, 0);
    }
  }]);

  return PingConnectionPlugin;
}(_ConnectionPlugin2["default"]);
/**
 *
 * @param xmpp
 */


function _default(xmpp) {
  _strophe.Strophe.addConnectionPlugin('ping', new PingConnectionPlugin(xmpp));
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

var _jitsiMeetLogger = require("jitsi-meet-logger");

var _strophe = require("strophe.js");

var _ConnectionPlugin2 = _interopRequireDefault(require("./ConnectionPlugin"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var logger = (0, _jitsiMeetLogger.getLogger)(__filename);
var RAYO_XMLNS = 'urn:xmpp:rayo:1';
/**
 *
 */

var RayoConnectionPlugin =
/*#__PURE__*/
function (_ConnectionPlugin) {
  _inherits(RayoConnectionPlugin, _ConnectionPlugin);

  function RayoConnectionPlugin() {
    _classCallCheck(this, RayoConnectionPlugin);

    return _possibleConstructorReturn(this, _getPrototypeOf(RayoConnectionPlugin).apply(this, arguments));
  }

  _createClass(RayoConnectionPlugin, [{
    key: "init",

    /**
     *
     * @param connection
     */
    value: function init(connection) {
      _get(_getPrototypeOf(RayoConnectionPlugin.prototype), "init", this).call(this, connection);

      this.connection.addHandler(this.onRayo.bind(this), RAYO_XMLNS, 'iq', 'set', null, null);
    }
    /**
     *
     * @param iq
     */

  }, {
    key: "onRayo",
    value: function onRayo(iq) {
      logger.info('Rayo IQ', iq);
    }
    /* eslint-disable max-params */

    /**
     *
     * @param to
     * @param from
     * @param roomName
     * @param roomPass
     * @param focusMucJid
     */

  }, {
    key: "dial",
    value: function dial(to, from, roomName, roomPass, focusMucJid) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (!focusMucJid) {
          reject(new Error('Internal error!'));
          return;
        }

        var req = (0, _strophe.$iq)({
          type: 'set',
          to: focusMucJid
        });
        req.c('dial', {
          xmlns: RAYO_XMLNS,
          to: to,
          from: from
        });
        req.c('header', {
          name: 'JvbRoomName',
          value: roomName
        }).up();

        if (roomPass && roomPass.length) {
          req.c('header', {
            name: 'JvbRoomPassword',
            value: roomPass
          }).up();
        }

        _this.connection.sendIQ(req, function (result) {
          logger.info('Dial result ', result); // eslint-disable-next-line newline-per-chained-call

          var resource = $(result).find('ref').attr('uri');
          _this.callResource = resource.substr('xmpp:'.length);
          logger.info("Received call resource: ".concat(_this.callResource));
          resolve();
        }, function (error) {
          logger.info('Dial error ', error);
          reject(error);
        });
      });
    }
    /* eslint-enable max-params */

    /**
     *
     */

  }, {
    key: "hangup",
    value: function hangup() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (!_this2.callResource) {
          reject(new Error('No call in progress'));
          logger.warn('No call in progress');
          return;
        }

        var req = (0, _strophe.$iq)({
          type: 'set',
          to: _this2.callResource
        });
        req.c('hangup', {
          xmlns: RAYO_XMLNS
        });

        _this2.connection.sendIQ(req, function (result) {
          logger.info('Hangup result ', result);
          _this2.callResource = null;
          resolve();
        }, function (error) {
          logger.info('Hangup error ', error);
          _this2.callResource = null;
          reject(new Error('Hangup error '));
        });
      });
    }
  }]);

  return RayoConnectionPlugin;
}(_ConnectionPlugin2["default"]);
/**
 *
 */


function _default() {
  _strophe.Strophe.addConnectionPlugin('rayo', new RayoConnectionPlugin());
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

var _jitsiMeetLogger = require("jitsi-meet-logger");

var _strophe = require("strophe.js");

var _GlobalOnErrorHandler = _interopRequireDefault(require("../util/GlobalOnErrorHandler"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/* global __filename */

/**
 * Strophe logger implementation. Logs from level WARN and above.
 */
var logger = (0, _jitsiMeetLogger.getLogger)(__filename);
/**
 * This is the last HTTP error status captured from Strophe debug logs.
 * The purpose of storing it is to distinguish between the network and
 * infrastructure reason for connection being dropped (see connectionHandler in
 * xmpp.js). The value will be cleared (-1) if the subsequent request succeeds
 * which means that the failure could be transient.
 *
 * FIXME in the latest Strophe (not released on npm) there is API to handle
 * particular HTTP errors, but there is no way to learn if the subsequent
 * request succeeded in order to tell if the error was one time incident or if
 * it was the reason for dropping the connection by Strophe (the connection is
 * dropped after 5 subsequent failures). Ideally Strophe should provide more
 * details about the reason on why the connection stopped.
 *
 * @type {number}
 */

var lastErrorStatus = -1;
/**
 * A regular expression used to catch Strophe's log message indicating that the
 * last BOSH request was successful. When there is such message seen the
 * {@link lastErrorStatus} will be set back to '-1'.
 * @type {RegExp}
 */

var resetLastErrorStatusRegExpr = /request id \d+.\d+ got 200/;
/**
 * A regular expression used to capture the current value of the BOSH request
 * error status (HTTP error code or '0' or something else).
 * @type {RegExp}
 */

var lastErrorStatusRegExpr = /request errored, status: (\d+), number of errors: \d+/;
/**
 *
 */

function _default() {
  _strophe.Strophe.log = function (level, msg) {
    // Our global handler reports uncaught errors to the stats which may
    // interpret those as partial call failure.
    // Strophe log entry about secondary request timeout does not mean that
    // it's a final failure(the request will be restarted), so we lower it's
    // level here to a warning.
    logger.trace('Strophe', level, msg);

    if (typeof msg === 'string' && msg.indexOf('Request ') !== -1 && msg.indexOf('timed out (secondary), restarting') !== -1) {
      // eslint-disable-next-line no-param-reassign
      level = _strophe.Strophe.LogLevel.WARN;
    }
    /* eslint-disable no-case-declarations */


    switch (level) {
      case _strophe.Strophe.LogLevel.DEBUG:
        // The log message which reports successful status is logged on
        // Strophe's DEBUG level.
        if (lastErrorStatus !== -1 && resetLastErrorStatusRegExpr.test(msg)) {
          logger.debug('Reset lastErrorStatus');
          lastErrorStatus = -1;
        }

        break;

      case _strophe.Strophe.LogLevel.WARN:
        logger.warn("Strophe: ".concat(msg));
        var errStatusCapture = lastErrorStatusRegExpr.exec(msg);

        if (errStatusCapture && errStatusCapture.length === 2) {
          lastErrorStatus = parseInt(errStatusCapture[1], 10);
          logger.debug("lastErrorStatus set to: ".concat(lastErrorStatus));
        }

        break;

      case _strophe.Strophe.LogLevel.ERROR:
      case _strophe.Strophe.LogLevel.FATAL:
        // eslint-disable-next-line no-param-reassign
        msg = "Strophe: ".concat(msg);

        _GlobalOnErrorHandler["default"].callErrorHandler(new Error(msg));

        logger.error(msg);
        break;
    }
    /* eslint-enable no-case-declarations */

  };
  /**
   * Returns error status (HTTP error code) of the last BOSH request.
   *
   * @return {number} HTTP error code, '0' for unknown or "god knows what"
   * (this is a hack).
   */


  _strophe.Strophe.getLastErrorStatus = function () {
    return lastErrorStatus;
  };

  _strophe.Strophe.getStatusString = function (status) {
    switch (status) {
      case _strophe.Strophe.Status.ERROR:
        return 'ERROR';

      case _strophe.Strophe.Status.CONNECTING:
        return 'CONNECTING';

      case _strophe.Strophe.Status.CONNFAIL:
        return 'CONNFAIL';

      case _strophe.Strophe.Status.AUTHENTICATING:
        return 'AUTHENTICATING';

      case _strophe.Strophe.Status.AUTHFAIL:
        return 'AUTHFAIL';

      case _strophe.Strophe.Status.CONNECTED:
        return 'CONNECTED';

      case _strophe.Strophe.Status.DISCONNECTED:
        return 'DISCONNECTED';

      case _strophe.Strophe.Status.DISCONNECTING:
        return 'DISCONNECTING';

      case _strophe.Strophe.Status.ATTACHED:
        return 'ATTACHED';

      default:
        return 'unknown';
    }
  };
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.JITSI_MEET_MUC_TYPE = exports.DEFAULT_STUN_SERVERS = void 0;

var _jitsiMeetLogger = require("jitsi-meet-logger");

var _strophe = require("strophe.js");

require("strophejs-plugin-disco");

var _RandomUtil = _interopRequireDefault(require("../util/RandomUtil"));

var JitsiConnectionErrors = _interopRequireWildcard(require("../../JitsiConnectionErrors"));

var JitsiConnectionEvents = _interopRequireWildcard(require("../../JitsiConnectionEvents"));

var _browser = _interopRequireDefault(require("../browser"));

var _strophe2 = _interopRequireDefault(require("./strophe.emuc"));

var _strophe3 = _interopRequireDefault(require("./strophe.jingle"));

var _strophe4 = _interopRequireDefault(require("./strophe.util"));

var _strophe5 = _interopRequireDefault(require("./strophe.ping"));

var _strophe6 = _interopRequireDefault(require("./strophe.rayo"));

var _strophe7 = _interopRequireDefault(require("./strophe.logger"));

var _Listenable2 = _interopRequireDefault(require("../util/Listenable"));

var _Caps = _interopRequireDefault(require("./Caps"));

var _GlobalOnErrorHandler = _interopRequireDefault(require("../util/GlobalOnErrorHandler"));

var _XMPPEvents = _interopRequireDefault(require("../../service/xmpp/XMPPEvents"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var logger = (0, _jitsiMeetLogger.getLogger)(__filename);
/**
 *
 * @param token
 * @param bosh
 */

function createConnection(token) {
  var bosh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/http-bind';

  // Append token as URL param
  if (token) {
    // eslint-disable-next-line no-param-reassign
    bosh += "".concat(bosh.indexOf('?') === -1 ? '?' : '&', "token=").concat(token);
  }

  var conn = new _strophe.Strophe.Connection(bosh); // The default maxRetries is 5, which is too long.

  conn.maxRetries = 3;
  return conn;
} // FIXME: remove once we have a default config template. -saghul

/**
 * A list of ice servers to use by default for P2P.
 */


var DEFAULT_STUN_SERVERS = [{
  urls: 'stun:stun.l.google.com:19302'
}, {
  urls: 'stun:stun1.l.google.com:19302'
}, {
  urls: 'stun:stun2.l.google.com:19302'
}];
/**
 * The name of the field used to recognize a chat message as carrying a JSON
 * payload from another endpoint.
 * If the json-message of a chat message contains a valid JSON object, and
 * the JSON has this key, then it is a valid json-message to be sent.
 */

exports.DEFAULT_STUN_SERVERS = DEFAULT_STUN_SERVERS;
var JITSI_MEET_MUC_TYPE = 'type';
/**
 *
 */

exports.JITSI_MEET_MUC_TYPE = JITSI_MEET_MUC_TYPE;

var XMPP =
/*#__PURE__*/
function (_Listenable) {
  _inherits(XMPP, _Listenable);

  /**
   * FIXME describe all options
   * @param {Object} options
   * @param {Array<Object>} options.p2pStunServers see
   * {@link JingleConnectionPlugin} for more details.
   * @param token
   */
  function XMPP(options, token) {
    var _this;

    _classCallCheck(this, XMPP);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(XMPP).call(this));
    _this.connection = null;
    _this.disconnectInProgress = false;
    _this.connectionTimes = {};
    _this.options = options;
    _this.token = token;
    _this.authenticatedUser = false;

    _this._initStrophePlugins(_assertThisInitialized(_this));

    _this.connection = createConnection(token, options.bosh);
    _this.caps = new _Caps["default"](_this.connection, _this.options.clientNode); // Initialize features advertised in disco-info

    _this.initFeaturesList(); // Setup a disconnect on unload as a way to facilitate API consumers. It
    // sounds like they would want that. A problem for them though may be if
    // they wanted to utilize the connected connection in an unload handler
    // of their own. However, it should be fairly easy for them to do that
    // by registering their unload handler before us.


    $(window).on('beforeunload unload', _this.disconnect.bind(_assertThisInitialized(_this)));
    return _this;
  }
  /**
   * Initializes the list of feature advertised through the disco-info
   * mechanism.
   */


  _createClass(XMPP, [{
    key: "initFeaturesList",
    value: function initFeaturesList() {
      // http://xmpp.org/extensions/xep-0167.html#support
      // http://xmpp.org/extensions/xep-0176.html#support
      this.caps.addFeature('urn:xmpp:jingle:1');
      this.caps.addFeature('urn:xmpp:jingle:apps:rtp:1');
      this.caps.addFeature('urn:xmpp:jingle:transports:ice-udp:1');
      this.caps.addFeature('urn:xmpp:jingle:apps:dtls:0');
      this.caps.addFeature('urn:xmpp:jingle:transports:dtls-sctp:1');
      this.caps.addFeature('urn:xmpp:jingle:apps:rtp:audio');
      this.caps.addFeature('urn:xmpp:jingle:apps:rtp:video');

      if (!this.options.disableRtx && _browser["default"].supportsRtx()) {
        this.caps.addFeature('urn:ietf:rfc:4588');
      } // this is dealt with by SDP O/A so we don't need to announce this
      // XEP-0293
      // this.caps.addFeature('urn:xmpp:jingle:apps:rtp:rtcp-fb:0');
      // XEP-0294
      // this.caps.addFeature('urn:xmpp:jingle:apps:rtp:rtp-hdrext:0');


      this.caps.addFeature('urn:ietf:rfc:5761'); // rtcp-mux

      this.caps.addFeature('urn:ietf:rfc:5888'); // a=group, e.g. bundle
      // this.caps.addFeature('urn:ietf:rfc:5576'); // a=ssrc
      // Enable Lipsync ?

      if (_browser["default"].isChrome() && this.options.enableLipSync !== false) {
        logger.info('Lip-sync enabled !');
        this.caps.addFeature('http://jitsi.org/meet/lipsync');
      }

      if (this.connection.rayo) {
        this.caps.addFeature('urn:xmpp:rayo:client:1');
      }
    }
    /**
     * Returns {@code true} if the PING functionality is supported by the server
     * or {@code false} otherwise.
     * @returns {boolean}
     */

  }, {
    key: "isPingSupported",
    value: function isPingSupported() {
      return this._pingSupported !== false;
    }
    /**
     *
     */

  }, {
    key: "getConnection",
    value: function getConnection() {
      return this.connection;
    }
    /**
     * Receive connection status changes and handles them.
     *
     * @param {Object} credentials
     * @param {string} credentials.jid - The user's XMPP ID passed to the
     * connect method. For example, 'user@xmpp.com'.
     * @param {string} credentials.password - The password passed to the connect
     * method.
     * @param {string} status - One of Strophe's connection status strings.
     * @param {string} [msg] - The connection error message provided by Strophe.
     */

  }, {
    key: "connectionHandler",
    value: function connectionHandler() {
      var _this2 = this;

      var credentials = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var status = arguments.length > 1 ? arguments[1] : undefined;
      var msg = arguments.length > 2 ? arguments[2] : undefined;
      var now = window.performance.now();

      var statusStr = _strophe.Strophe.getStatusString(status).toLowerCase();

      this.connectionTimes[statusStr] = now;
      logger.log("(TIME) Strophe ".concat(statusStr).concat(msg ? "[".concat(msg, "]") : '', ":\t"), now);

      if (status === _strophe.Strophe.Status.CONNECTED || status === _strophe.Strophe.Status.ATTACHED) {
        if (this.options.useStunTurn || this.options.p2p && this.options.p2p.useStunTurn) {
          this.connection.jingle.getStunAndTurnCredentials();
        }

        logger.info("My Jabber ID: ".concat(this.connection.jid)); // Schedule ping ?

        var pingJid = this.connection.domain;
        this.caps.getFeaturesAndIdentities(pingJid).then(function (_ref) {
          var features = _ref.features,
              identities = _ref.identities;

          if (features.has(_strophe.Strophe.NS.PING)) {
            _this2._pingSupported = true;

            _this2.connection.ping.startInterval(pingJid);
          } else {
            logger.warn("Ping NOT supported by ".concat(pingJid));
          } // check for speakerstats


          identities.forEach(function (identity) {
            if (identity.type === 'speakerstats') {
              _this2.speakerStatsComponentAddress = identity.name;

              _this2.connection.addHandler(_this2._onPrivateMessage.bind(_this2), null, 'message', null, null);
            }
          });
        })["catch"](function (error) {
          var errmsg = 'Feature discovery error';

          _GlobalOnErrorHandler["default"].callErrorHandler(new Error("".concat(errmsg, ": ").concat(error)));

          logger.error(errmsg, error);
        });

        if (credentials.password) {
          this.authenticatedUser = true;
        }

        if (this.connection && this.connection.connected && _strophe.Strophe.getResourceFromJid(this.connection.jid)) {
          // .connected is true while connecting?
          // this.connection.send($pres());
          this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_ESTABLISHED, _strophe.Strophe.getResourceFromJid(this.connection.jid));
        }
      } else if (status === _strophe.Strophe.Status.CONNFAIL) {
        if (msg === 'x-strophe-bad-non-anon-jid') {
          this.anonymousConnectionFailed = true;
        } else {
          this.connectionFailed = true;
        }

        this.lastErrorMsg = msg;

        if (msg === 'giving-up') {
          this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_FAILED, JitsiConnectionErrors.OTHER_ERROR, msg);
        }
      } else if (status === _strophe.Strophe.Status.DISCONNECTED) {
        // Stop ping interval
        this.connection.ping.stopInterval();
        var wasIntentionalDisconnect = this.disconnectInProgress;
        var errMsg = msg || this.lastErrorMsg;
        this.disconnectInProgress = false;

        if (this.anonymousConnectionFailed) {
          // prompt user for username and password
          this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_FAILED, JitsiConnectionErrors.PASSWORD_REQUIRED);
        } else if (this.connectionFailed) {
          this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_FAILED, JitsiConnectionErrors.OTHER_ERROR, errMsg, undefined,
          /* credentials */
          this._getConnectionFailedReasonDetails());
        } else if (wasIntentionalDisconnect) {
          this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_DISCONNECTED, errMsg);
        } else {
          // XXX if Strophe drops the connection while not being asked to,
          // it means that most likely some serious error has occurred.
          // One currently known case is when a BOSH request fails for
          // more than 4 times. The connection is dropped without
          // supplying a reason(error message/event) through the API.
          logger.error('XMPP connection dropped!'); // XXX if the last request error is within 5xx range it means it
          // was a server failure

          var lastErrorStatus = _strophe.Strophe.getLastErrorStatus();

          if (lastErrorStatus >= 500 && lastErrorStatus < 600) {
            this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_FAILED, JitsiConnectionErrors.SERVER_ERROR, errMsg || 'server-error');
          } else {
            this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_FAILED, JitsiConnectionErrors.CONNECTION_DROPPED_ERROR, errMsg || 'connection-dropped-error');
          }
        }
      } else if (status === _strophe.Strophe.Status.AUTHFAIL) {
        // wrong password or username, prompt user
        this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_FAILED, JitsiConnectionErrors.PASSWORD_REQUIRED, msg, credentials);
      }
    }
    /**
     *
     * @param jid
     * @param password
     */

  }, {
    key: "_connect",
    value: function _connect(jid, password) {
      // connection.connect() starts the connection process.
      //
      // As the connection process proceeds, the user supplied callback will
      // be triggered multiple times with status updates. The callback should
      // take two arguments - the status code and the error condition.
      //
      // The status code will be one of the values in the Strophe.Status
      // constants. The error condition will be one of the conditions defined
      // in RFC 3920 or the condition strophe-parsererror.
      //
      // The Parameters wait, hold and route are optional and only relevant
      // for BOSH connections. Please see XEP 124 for a more detailed
      // explanation of the optional parameters.
      //
      // Connection status constants for use by the connection handler
      // callback.
      //
      //  Status.ERROR - An error has occurred (websockets specific)
      //  Status.CONNECTING - The connection is currently being made
      //  Status.CONNFAIL - The connection attempt failed
      //  Status.AUTHENTICATING - The connection is authenticating
      //  Status.AUTHFAIL - The authentication attempt failed
      //  Status.CONNECTED - The connection has succeeded
      //  Status.DISCONNECTED - The connection has been terminated
      //  Status.DISCONNECTING - The connection is currently being terminated
      //  Status.ATTACHED - The connection has been attached
      this.anonymousConnectionFailed = false;
      this.connectionFailed = false;
      this.lastErrorMsg = undefined;
      this.connection.connect(jid, password, this.connectionHandler.bind(this, {
        jid: jid,
        password: password
      }));
    }
    /**
     * Attach to existing connection. Can be used for optimizations. For
     * example: if the connection is created on the server we can attach to it
     * and start using it.
     *
     * @param options {object} connecting options - rid, sid, jid and password.
     */

  }, {
    key: "attach",
    value: function attach(options) {
      var now = this.connectionTimes.attaching = window.performance.now();
      logger.log("(TIME) Strophe Attaching\t:".concat(now));
      this.connection.attach(options.jid, options.sid, parseInt(options.rid, 10) + 1, this.connectionHandler.bind(this, {
        jid: options.jid,
        password: options.password
      }));
    }
    /**
     *
     * @param jid
     * @param password
     */

  }, {
    key: "connect",
    value: function connect(jid, password) {
      if (!jid) {
        var _this$options$hosts = this.options.hosts,
            anonymousdomain = _this$options$hosts.anonymousdomain,
            domain = _this$options$hosts.domain;
        var configDomain = anonymousdomain || domain; // Force authenticated domain if room is appended with '?login=true'
        // or if we're joining with the token
        // FIXME Do not rely on window.location because (1) React Native
        // does not have a window.location by default and (2) here we cannot
        // know for sure that query/search has not be stripped from
        // window.location by the time the following executes.

        var _window = window,
            location = _window.location;

        if (anonymousdomain) {
          var search = location && location.search;

          if (search && search.indexOf('login=true') !== -1 || this.token) {
            configDomain = domain;
          }
        } // eslint-disable-next-line no-param-reassign


        jid = configDomain || location && location.hostname;
      }

      return this._connect(jid, password);
    }
    /**
     *
     * @param roomName
     * @param options
     */

  }, {
    key: "createRoom",
    value: function createRoom(roomName, options) {
      // By default MUC nickname is the resource part of the JID
      var mucNickname = _strophe.Strophe.getNodeFromJid(this.connection.jid);

      var roomjid = "".concat(roomName, "@").concat(this.options.hosts.muc, "/");
      var cfgNickname = options.useNicks && options.nick ? options.nick : null;

      if (cfgNickname) {
        // Use nick if it's defined
        mucNickname = options.nick;
      } else if (!this.authenticatedUser) {
        // node of the anonymous JID is very long - here we trim it a bit
        mucNickname = mucNickname.substr(0, 8);
      } // Constant JIDs need some random part to be appended in order to be
      // able to join the MUC more than once.


      if (this.authenticatedUser || cfgNickname !== null) {
        mucNickname += "-".concat(_RandomUtil["default"].randomHexString(6));
      }

      roomjid += mucNickname;
      return this.connection.emuc.createRoom(roomjid, null, options);
    }
    /**
     * Returns the logs from strophe.jingle.
     * @returns {Object}
     */

  }, {
    key: "getJingleLog",
    value: function getJingleLog() {
      var jingle = this.connection.jingle;
      return jingle ? jingle.getLog() : {};
    }
    /**
     * Returns the logs from strophe.
     */

  }, {
    key: "getXmppLog",
    value: function getXmppLog() {
      return (this.connection.logger || {}).log || null;
    }
    /**
     *
     */

  }, {
    key: "dial",
    value: function dial() {
      var _this$connection$rayo;

      (_this$connection$rayo = this.connection.rayo).dial.apply(_this$connection$rayo, arguments);
    }
    /**
     * Pings the server. Remember to check {@link isPingSupported} before using
     * this method.
     * @param timeout how many ms before a timeout should occur.
     * @returns {Promise} resolved on ping success and reject on an error or
     * a timeout.
     */

  }, {
    key: "ping",
    value: function ping(timeout) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3.isPingSupported()) {
          _this3.connection.ping.ping(_this3.connection.domain, resolve, reject, timeout);
        } else {
          reject('PING operation is not supported by the server');
        }
      });
    }
    /**
     *
     * @param jid
     * @param mute
     */

  }, {
    key: "setMute",
    value: function setMute(jid, mute) {
      this.connection.moderate.setMute(jid, mute);
    }
    /**
     *
     * @param jid
     */

  }, {
    key: "eject",
    value: function eject(jid) {
      this.connection.moderate.eject(jid);
    }
    /**
     *
     */

  }, {
    key: "getSessions",
    value: function getSessions() {
      return this.connection.jingle.sessions;
    }
    /**
     * Disconnects this from the XMPP server (if this is connected).
     *
     * @param ev optionally, the event which triggered the necessity to
     * disconnect from the XMPP server (e.g. beforeunload, unload).
     */

  }, {
    key: "disconnect",
    value: function disconnect(ev) {
      if (this.disconnectInProgress || !this.connection) {
        this.eventEmitter.emit(JitsiConnectionEvents.WRONG_STATE);
        return;
      }

      this.disconnectInProgress = true; // XXX Strophe is asynchronously sending by default. Unfortunately, that
      // means that there may not be enough time to send an unavailable
      // presence or disconnect at all. Switching Strophe to synchronous
      // sending is not much of an option because it may lead to a noticeable
      // delay in navigating away from the current location. As a compromise,
      // we will try to increase the chances of sending an unavailable
      // presence and/or disconecting within the short time span that we have
      // upon unloading by invoking flush() on the connection. We flush() once
      // before disconnect() in order to attemtp to have its unavailable
      // presence at the top of the send queue. We flush() once more after
      // disconnect() in order to attempt to have its unavailable presence
      // sent as soon as possible.

      this.connection.flush();

      if (ev !== null && typeof ev !== 'undefined') {
        var evType = ev.type;

        if (evType === 'beforeunload' || evType === 'unload') {// XXX Whatever we said above, synchronous sending is the best
          // (known) way to properly disconnect from the XMPP server.
          // Consequently, it may be fine to have the source code and
          // comment it in or out depending on whether we want to run with
          // it for some time.
          // This no longer works in Chrome
          // this.connection.options.sync = true;
        }
      }

      this.connection.disconnect();

      if (this.connection.options.sync !== true) {
        this.connection.flush();
      }
    }
    /**
     *
     */

  }, {
    key: "_initStrophePlugins",
    value: function _initStrophePlugins() {
      var iceConfig = {
        jvb: {
          iceServers: []
        },
        p2p: {
          iceServers: []
        }
      };
      var p2pStunServers = this.options.p2p && this.options.p2p.stunServers || DEFAULT_STUN_SERVERS;

      if (Array.isArray(p2pStunServers)) {
        logger.info('P2P STUN servers: ', p2pStunServers);
        iceConfig.p2p.iceServers = p2pStunServers;
      }

      if (this.options.p2p && this.options.p2p.iceTransportPolicy) {
        logger.info('P2P ICE transport policy: ', this.options.p2p.iceTransportPolicy);
        iceConfig.p2p.iceTransportPolicy = this.options.p2p.iceTransportPolicy;
      }

      (0, _strophe2["default"])(this);
      (0, _strophe3["default"])(this, this.eventEmitter, iceConfig);
      (0, _strophe4["default"])();
      (0, _strophe5["default"])(this);
      (0, _strophe6["default"])();
      (0, _strophe7["default"])();
    }
    /**
     * Returns details about connection failure. Shard change or is it after
     * suspend.
     * @returns {object} contains details about a connection failure.
     * @private
     */

  }, {
    key: "_getConnectionFailedReasonDetails",
    value: function _getConnectionFailedReasonDetails() {
      var details = {}; // check for moving between shard if information is available

      if (this.options.deploymentInfo && this.options.deploymentInfo.shard && this.connection._proto && this.connection._proto.lastResponseHeaders) {
        // split headers by line
        var headersArr = this.connection._proto.lastResponseHeaders.trim().split(/[\r\n]+/);

        var headers = {};
        headersArr.forEach(function (line) {
          var parts = line.split(': ');
          var header = parts.shift();
          var value = parts.join(': ');
          headers[header] = value;
        });
        /* eslint-disable camelcase */

        details.shard_changed = this.options.deploymentInfo.shard !== headers['x-jitsi-shard'];
        /* eslint-enable camelcase */
      }
      /* eslint-disable camelcase */
      // check for possible suspend


      details.suspend_time = this.connection.ping.getPingSuspendTime();
      /* eslint-enable camelcase */

      return details;
    }
    /**
     * Notifies speaker stats component if available that we are the new
     * dominant speaker in the conference.
     * @param {String} roomJid - The room jid where the speaker event occurred.
     */

  }, {
    key: "sendDominantSpeakerEvent",
    value: function sendDominantSpeakerEvent(roomJid) {
      // no speaker stats component advertised
      if (!this.speakerStatsComponentAddress || !roomJid) {
        return;
      }

      var msg = (0, _strophe.$msg)({
        to: this.speakerStatsComponentAddress
      });
      msg.c('speakerstats', {
        xmlns: 'http://jitsi.org/jitmeet',
        room: roomJid
      }).up();
      this.connection.send(msg);
    }
    /**
     * Check if the given argument is a valid JSON ENDPOINT_MESSAGE string by
     * parsing it and checking if it has a field called 'type'.
     *
     * @param {string} jsonString check if this string is a valid json string
     * and contains the special structure.
     * @returns {boolean, object} if given object is a valid JSON string, return
     * the json object. Otherwise, returns false.
     */

  }, {
    key: "tryParseJSONAndVerify",
    value: function tryParseJSONAndVerify(jsonString) {
      try {
        var json = JSON.parse(jsonString); // Handle non-exception-throwing cases:
        // Neither JSON.parse(false) or JSON.parse(1234) throw errors,
        // hence the type-checking,
        // but... JSON.parse(null) returns null, and
        // typeof null === "object",
        // so we must check for that, too.
        // Thankfully, null is falsey, so this suffices:

        if (json && _typeof(json) === 'object') {
          var type = json[JITSI_MEET_MUC_TYPE];

          if (typeof type !== 'undefined') {
            return json;
          }

          logger.debug('parsing valid json but does not have correct ' + 'structure', 'topic: ', type);
        }
      } catch (e) {
        return false;
      }

      return false;
    }
    /**
     * A private message is received, message that is not addressed to the muc.
     * We expect private message coming from speaker stats component if it is
     * enabled and running.
     *
     * @param {string} msg - The message.
     */

  }, {
    key: "_onPrivateMessage",
    value: function _onPrivateMessage(msg) {
      var from = msg.getAttribute('from');

      if (!this.speakerStatsComponentAddress || from !== this.speakerStatsComponentAddress) {
        return;
      }

      var jsonMessage = $(msg).find('>json-message').text();
      var parsedJson = this.tryParseJSONAndVerify(jsonMessage);

      if (parsedJson && parsedJson[JITSI_MEET_MUC_TYPE] === 'speakerstats' && parsedJson.users) {
        this.eventEmitter.emit(_XMPPEvents["default"].SPEAKER_STATS_RECEIVED, parsedJson.users);
      }

      return true;
    }
  }]);

  return XMPP;
}(_Listenable2["default"]);

exports["default"] = XMPP;

